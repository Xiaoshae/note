# 虚拟块设备

块设备是指一类能够以**固定大小的块**（Block，通常为 512 字节、4KB 等）为单位进行数据传输和寻址的硬件设备或设备驱动接口。其核心特征是支持**随机访问**（Random Access），即系统可以在设备的任意位置读取或写入数据。

虚拟块设备是一种通过**软件抽象**模拟出的块设备。它向操作系统呈现出标准的块设备接口，表现得像一个物理硬盘，但其后端存储并非直接对应的物理磁盘控制器，而是映射到**文件、内存区域、网络协议**或**其他块设备的逻辑组合**上。

本文主要介绍基于文件的块设备。



## 文件块设备

**文件块设备**通常指的是**Loop device（回环设备）虚拟磁盘镜像**。这类技术允许操作系统将一个普通文件挂载为块设备（Block Device），使其看起来像是一个物理硬盘、分区或闪存盘。

**虚拟化磁盘格式 (Virtual Disk Formats)** 是专门为虚拟机设计的文件格式，它们不仅作为块设备使用，还包含元数据以支持高级功能。它们通常需要特定的驱动（如 QEMU 的 `nbd` 驱动）才能映射为宿主机的块设备。



**Raw Image (.img, .raw)**

**Raw Image** 使用**最原始的二进制数据转储形式**，其工作原理非常直观，即文件内部的第 n 个字节直接且精准地对应于虚拟磁盘中的第 n 个字节，中间没有任何复杂的映射或封装。Raw 格式在理论上能够提供最快的 I/O 性能。

这种纯粹性也带来了极佳的通用性，使其成为几乎所有虚拟化软件都能轻松读取和兼容的格式。

利用现代文件系统的稀疏文件（Sparse File）特性，Raw 镜像可以做到仅占用实际写入数据的物理空间。



**QCOW2 (QEMU Copy On Write v2)**

QCOW2 是 Linux KVM 和 QEMU 虚拟化生态系统中的原生标准格式，其核心特性在于“写时复制”（Copy On Write）。与 Raw 格式不同，QCOW2 文件在初始创建时占用的空间极小，只有在数据被实际写入时，文件体积才会动态增长。

除了动态分配，QCOW2 最强大的优势在于其丰富的元数据功能。它原生支持内部快照（Snapshots），可以同时保存虚拟机的磁盘数据和内存状态。

它支持“后端镜像”（Backing Files）机制，允许基于一个只读的基础镜像创建多个增量镜像，这对于虚拟机模板的快速部署至关重要。虽然由于元数据操作的存在，其性能在旧版本中略低于 Raw，但随着 QCOW2 v3 规范的优化，其性能差距正在迅速缩小。



**VMDK (Virtual Machine Disk)**

VMDK 是由 VMware 创建并主导的虚拟磁盘格式，长期以来一直是企业级虚拟化领域的实际标准。它的设计非常成熟且稳定，广泛应用于 VMware ESXi、Workstation 等产品中。

VMDK 的一个独特功能是支持“拆分存储”，即可以将一个巨大的虚拟硬盘拆分为多个 2GB 大小的独立文件，这在旧的文件系统或需要跨网络传输时非常有用。

尽管 VMware 的核心实现代码是闭源的，但 VMDK 的文件格式规范（作为 OVF 标准的一部分）是公开的。这意味着几乎所有的主流虚拟化工具（包括开源的 QEMU 和 VirtualBox）都支持导入和读取 VMDK 文件，使其成为了不同虚拟化平台之间迁移数据时的首选兼容格式。



**VHD / VHDX (Virtual Hard Disk)**

VHD 和 VHDX 是微软开发的虚拟磁盘标准，其中 VHDX 是目前主流的现代版本，主要用于 Hyper-V 虚拟化平台和 WSL2（Windows Subsystem for Linux）。VHDX 在设计上突破了旧版 VHD 的限制，支持高达 64TB 的存储容量，并针对现代大容量存储设备进行了 4KB 扇区对齐优化，从而提升了性能表现。

VHDX 的一个显著特性是内置了防腐蚀的日志机制。这种机制类似于日志文件系统，能够在系统突然断电或崩溃时保护磁盘的元数据不被损坏，极大提升了数据的可靠性。

在 Windows 生态中，VHDX 拥有无与伦比的系统级集成度，用户可以直接在 Windows 资源管理器中将 VHDX 文件挂载为物理盘符，甚至支持从 VHDX 文件直接引导启动操作系统。





## QCOW2

qcow2 (QEMU Copy On Write v2) 是 QEMU/KVM 虚拟化环境中最常用的默认磁盘格式。它在保持不错性能的同时，提供了比原始格式（raw）丰富得多的**高级特性**。



**动态分配 / 稀疏文件 (Thin Provisioning)**

当你创建一个 100GB 的 qcow2 镜像时，它在物理磁盘上最初可能只占用几百 KB 的元数据空间。文件大小会随着数据的实际写入而动态增长，直到达到设定的上限。



**写时复制与后端文件 (Copy-on-Write & Backing Files)**

这是 qcow2 名称的由来，也是其最强大的功能之一，允许创建**增量镜像**。

你可以创建一个只读的“基础镜像”（Base Image），然后基于它创建多个“覆盖镜像”（Overlay Image）。虚拟机只向覆盖镜像写入数据，读取时若覆盖镜像没有数据，则回溯读取基础镜像。



**内部快照 (Internal Snapshots)**

qcow2 是少数支持**内部快照**的虚拟磁盘格式之一。

快照数据和当前的磁盘数据存储在**同一个** `.qcow2` 文件中。

记录某个时间点磁盘的数据。可以选择性地保存虚拟机的 RAM 状态（Live Snapshot），允许虚拟机恢复到运行时的确切状态。



**数据压缩 (Compression)**

qcow2 支持对镜像内的数据进行压缩。支持传统的 `zlib` 和较新的 `zstd`（性能更好）。

通常用于只读的模板镜像或归档。写入压缩镜像会有较大的性能开销，但读取性能通常可以接受。



## VMDK

VMDK (Virtual Machine Disk) 是 VMware 开发并广泛使用的虚拟磁盘格式。除了基本的数据存储功能外，它设计了许多高级特性来支持企业级虚拟化环境的需求，如高性能、备份效率和灵活性。



**灵活的置备模式 (Provisioning)**

VMDK 允许在创建时选择不同的磁盘空间分配策略，以平衡性能和存储利用率：

**精简置备 (Thin Provisioning):** 磁盘文件最初只占用极小的空间，随着数据的写入自动增长，直到达到设定的最大容量。这极大节省了物理存储空间。

**厚置备 (Thick Provisioning):**

- **延迟置零 (Lazy Zeroed):** 创建时预占所有空间，但只有在首次写入数据时才进行“置零”操作。
- **置零 (Eager Zeroed):** 创建时预占空间并立即全部写零。这是**性能最高**的模式，也是通过 Fault Tolerance (FT) 和 Oracle RAC 等集群功能所需的模式。



**强大的快照与增量链 (Snapshots & Delta Disks)**

这是 VMDK 最核心的高级特性之一，支持非破坏性的时间点恢复：

- **增量磁盘 (Redo Logs):** 当创建快照时，原始 VMDK 变为只读，新的写入操作会被重定向到一个新的“子磁盘”（Delta Disk/Sparse Disk）。
- **快照链:** 支持多层级的父子关系，形成快照树。
- **链接克隆 (Linked Clones):** 多个虚拟机可以共享同一个只读的“父” VMDK，每个虚拟机仅拥有自己的差异数据。这在 VDI (虚拟桌面) 场景中极大地节省了空间并加快了部署速度。



## QEMU

**语法**：

```
qemu-img [standard options] command [command options]
```



**QEMU 磁盘镜像工具**

- `-h`, `--help`       显示此帮助信息并退出
- `-V`, `--version`    输出版本信息并退出
- `-T`, `--trace`      `[[enable=]<模式>][,events=<文件>][,file=<文件>]` 指定追踪选项



### create

创建一个新的虚拟机磁盘镜像文件。你可以指定格式、大小以及是否基于另一个镜像（后端文件/Backing File）创建。

```
create [--object objectdef] [-q] [-f fmt] [-b backing_file [-F backing_fmt]] [-u] [-o options] filename [size]
```

**[size]**

支持 `k` (KB), `M` (MB), `G` (GB), `T` (TB), `P` (PB), `E` (EB)。

如果使用了 `-b` (后端文件)，则可以省略大小，此时新镜像的大小默认等于后端文件的大小。

**-b backing_file**

指定一个“后端文件”（基础镜像）。新创建的镜像将是该基础镜像的**覆盖层 (Overlay)**。新镜像初始几乎不占空间，读取时读基础镜像，写入时将变化的数据写入新镜像（Copy-on-Write）。

**-F backing_fmt**

指定后端文件的格式（如 `qcow2` 或 `raw`）。为了安全起见，当使用 `-b` 时，**强烈建议**始终搭配使用 `-F`，以防止恶意文件伪造格式进行攻击。

**-u**

允许在不打开后端文件的情况下创建镜像。当你需要创建一个基于后端文件的镜像，但该后端文件当前路径不存在或不可访问时（例如用于稍后重命名文件或准备目录结构）。



#### qcow2 典型示例

**创建一个标准的 qcow2 镜像**

这是最常见的用法，创建一个最大容量为 20GB 的虚拟磁盘，初始文件很小，随写入增长。

```
qemu-img create -f qcow2 my_vm_disk.qcow2 20G
```



**创建一个 raw 格式镜像**

创建一个 10GB 的原始镜像。性能通常比 qcow2 好，但功能较少。

```
qemu-img create -f raw my_vm_disk.raw 10G
```



**创建基于后端文件的“增量”镜像 (Overlay)**

假设你有一个基础系统镜像 `base_os.qcow2`，你想创建一个新的虚拟机，但不想复制整个基础镜像。

```
qemu-img create -f qcow2 -b base_os.qcow2 -F qcow2 new_vm.qcow2
```

`new_vm.qcow2` 将记录相对于 `base_os.qcow2` 的所有更改。

**注意**：一旦创建了 Overlay，**绝对不要修改** `base_os.qcow2`，否则会导致 `new_vm.qcow2` 数据损坏。



**使用预分配 (Preallocation) 优化性能**

默认情况下 `qcow2` 是按需分配元数据的，这会稍微影响写入性能。通过 `-o` 可以预先分配元数据。

```
qemu-img create -f qcow2 -o preallocation=metadata perf_disk.qcow2 50G
```

`preallocation` 的值通常有 `off` (默认), `metadata` (推荐平衡), `full` (完全分配，创建慢但在某些文件系统上运行快)。



**查看特定格式支持的选项**

如果你想知道 `qcow2` 格式还支持哪些 `-o` 选项：

```
qemu-img create -f qcow2 -o help
```



#### vmdk 典型示例

下面我将构建一个**三层快照链**场景，模拟企业级环境中的**“黄金镜像 -> 部门镜像 -> 员工个人镜像”**结构，并演示如何创建、验证以及合并这些复杂的链条。

**Level 0 (Base)**: `base_os_gold.vmdk` —— 纯净的操作系统（只读，所有人共享）。

**Level 1 (Mid)**: `dept_dev.vmdk` —— 开发部的预装环境（基于 Base，安装了编译器等）。

**Level 2 (Top)**: `user_alice.vmdk` —— 员工 Alice 的日常使用镜像（基于 Dev 镜像，存储个人数据）。



**创建基础黄金镜像 (Level 0)**

首先创建一个 20G 的基础镜像。为了演示真实性，我们指定子格式为单文件稀疏格式（默认）。

```
qemu-img create -f vmdk -o subformat=monolithicSparse base_os_gold.vmdk 20G
```



**创建部门级镜像 (Level 1) - 链接到 Base**

现在我们需要创建一个基于 `base_os_gold.vmdk` 的镜像。

**关键参数**：`-b` 指定后端文件，`-F` 指定后端文件格式（**极其重要**，显式指定 `vmdk` 防止安全风险）。

```
qemu-img create -f vmdk \
  -b base_os_gold.vmdk \
  -F vmdk \
  dept_dev.vmdk
```

*此时，`dept_dev.vmdk` 的大小极小，它只记录相对于 `base_os_gold.vmdk` 的修改。*



**创建用户级镜像 (Level 2) - 链接到 Level 1**

Alice 的电脑将基于开发部的镜像运行。创建 Alice 的镜像，基于 dept_dev.vmdk

```
qemu-img create -f vmdk \
  -b dept_dev.vmdk \
  -F vmdk \
  user_alice.vmdk
```



**验证快照链 (复杂链条可视化)**

创建完成后，我们必须验证这条链是否完整。使用 `info` 命令配合 `--backing-chain` 参数。

```
qemu-img info --backing-chain user_alice.vmdk
```

**预期的输出结果（简化版）：**

```
image: user_alice.vmdk
file format: vmdk
virtual size: 20 GiB (21474836480 bytes)
disk size: 12 KiB
backing file: dept_dev.vmdk    <-- 指向上一级
backing file format: vmdk

---------
image: dept_dev.vmdk
file format: vmdk
virtual size: 20 GiB (21474836480 bytes)
disk size: 12 KiB
backing file: base_os_gold.vmdk  <-- 指向根部
backing file format: vmdk

---------
image: base_os_gold.vmdk
file format: vmdk
virtual size: 20 GiB (21474836480 bytes)
disk size: 4.0 KiB
```



### convert

**qemu-img convert** 是 QEMU 磁盘镜像工具中最强大且最常用的子命令。它的主要功能是将磁盘镜像从一种格式转换为另一种格式（例如从 VMDK 转为 QCOW2），同时还可以用于压缩镜像、加密、提取快照或合并后端文件（backing files）。

```
convert [--object objectdef] [--image-opts] [--target-image-opts] [--target-is-zero] [--bitmaps] [-U] [-C] [-c] [-p] [-q] [-n] [-f fmt] [-t cache] [-T src_cache] [-O output_fmt] [-B backing_file [-F backing_fmt]] [-o options] [-l snapshot_param] [-S sparse_size] [-r rate_limit] [-m num_coroutines] [-W] [--salvage] filename [filename2 [...]] output_filename
```

**filename [filename2 [...]] output_filename**

指定源镜像文件（`filename`）和转换后的目标文件（`output_filename`）。 虽然支持指定多个源文件进行拼接，但在常规格式转换中通常只指定一个源文件。

**-f fmt**

指定**输入**文件的格式。 虽然 `qemu-img` 通常能自动检测输入格式，但在脚本中显式指定该参数更安全，也可以防止某些格式欺骗攻击。

**-O output_fmt**

指定**输出**文件的格式（例如 `qcow2`, `raw`, `vmdk`, `vdi`）。 这是转换时最重要的参数。如果不指定，默认格式通常为 `raw`。

**-c**

对目标镜像进行压缩（仅支持 `qcow` 和 `qcow2` 格式）。 启用后，生成的镜像体积会显著减小，但转换过程和虚拟机运行时的写入速度会受到一定影响。

**-p**

显示命令执行的进度条（百分比）。在处理大文件转换时非常有帮助。

**-n**

跳过目标卷的创建过程。 当你希望将数据写入一个**已经存在**的文件或块设备（如 LVM 卷、`/dev/sdb`）时使用此参数。如果未使用此参数，`qemu-img` 会尝试创建一个新的文件头。

**-l snapshot_param**

指定从源镜像中的某个**快照**进行转换。 参数可以是快照的 ID 或名称。这允许你将某个特定时间点的快照提取为一个独立的镜像文件。

**-m num_coroutines**

指定转换过程中并行工作的协程数量（默认为 8）。 在多核性能较强的机器上，增加此数值可以加快转换速度。

**-W**

允许乱序写入目标文件。 通常建议与 `-m` 配合使用以提升并行性能。注意：如果直接写入块设备，使用此参数通常是安全的；但如果是某些特殊的文件系统，需确保其支持稀疏写入。

**-S sparse_size**

设置稀疏文件的检测阈值（默认为 4k）。 如果设置为 `0`，则禁用稀疏检测，源镜像中的所有数据（包括全零块）都会被实打实地写入目标，导致目标文件完全分配（Fully Allocated）。

**-B backing_file**

指定目标镜像的后端文件。 这使得转换后的镜像成为一个基于该后端文件的增量镜像（Overlay），而不是一个完整独立的镜像。



### info

显示磁盘镜像文件的详细信息。这通常包括镜像的虚拟大小（Virtual size）、实际磁盘占用大小（Disk size）、文件格式、簇大小（Cluster size）、后端文件路径（Backing file）以及现有的内部快照列表。

```
info [--object objectdef] [--image-opts] [-f fmt] [--output=ofmt] [--backing-chain] [-U] filename
```

**filename**

指定要查询的磁盘镜像文件名。

**-f fmt**

显式指定镜像文件的格式（例如 `qcow2`, `raw`）。 如果不指定，`qemu-img` 会尝试自动检测格式。在某些情况下（例如文件头损坏或为了安全审计），显式指定格式很有用。

**--output=ofmt**

指定信息输出的格式。

- `human`（默认）：以人类可读的文本格式显示，自动转换单位（如 K, M, G）。
- `json`：以 JSON 格式输出所有元数据。这非常适合在脚本或程序中解析镜像信息。

**--backing-chain**

递归显示完整的后端文件链（Backing Chain）。 如果该镜像是一个覆盖层（Overlay），此参数不仅会显示直接的后端文件，还会递归列出后端文件的后端文件，直到基础镜像。这对于调试镜像链断裂或理解复杂的增量备份结构非常关键。

**-U**

以“非独占”模式（Unsafe / Force Share）打开镜像文件。 默认情况下，如果一个镜像正被虚拟机（QEMU 进程）使用，`info` 命令可能会因为无法获取文件锁而报错。使用 `-U` 可以在不获取写锁的情况下读取信息。 

*注意：虽然这对 `info` 这种只读操作通常是安全的，但如果文件正在发生剧烈变化，读取到的元数据可能不是最新的。*

**--image-opts**

将文件名参数视为一组选项键值对，而不是单纯的文件名。 这通常用于查询配置复杂的镜像（例如需要指定特定驱动参数）或带有加密设置的镜像（配合 `--object` 提供密钥）。



### rebase

改变镜像文件的后端文件（Backing File）。这主要用于两种场景：一是后端文件被移动或重命名了，需要更新路径；二是将当前的增量镜像（Overlay）“嫁接”到一个新的、内容有所不同的基础镜像上。

```
rebase [--object objectdef] [--image-opts] [-U] [-q] [-f fmt] [-t cache] [-T src_cache] [-p] [-u] [-c] -b backing_file [-F backing_fmt] filename
```

**filename**

指定要修改的**增量镜像**（Overlay）文件名。

**-b backing_file**

指定**新**的后端文件路径。 如果设为一个空字符串（`""`），`qemu-img` 将会把当前后端文件中的数据合并到 `filename` 中，使 `filename` 变成一个独立运行、不再依赖任何后端文件的镜像（这一过程通常称为 Flattening）。

**-F backing_fmt**

指定**新**后端文件的格式（如 `qcow2`, `raw`）。 为了安全起见，当使用 `-b` 指定后端文件时，**强烈建议**始终搭配使用 `-F`，以防止恶意文件伪造格式进行攻击。

**-u**

启用“非安全”模式（Unsafe Mode）。

- **如果不加 `-u`（默认安全模式）：** `qemu-img` 会比较“旧后端文件”和“新后端文件”的内容。如果发现两者有差异，它会将旧后端文件中不同的部分读取出来并写入到 `filename` 中。这确保了虚拟机看到的逻辑数据保持不变。这是一个 I/O 密集型操作。
- **如果加了 `-u`：** `qemu-img` 仅仅修改 `filename` 头部的指针，将其指向新的后端文件，而不进行任何数据校验或复制。这瞬间即可完成。
  - **适用场景：** 仅当新旧后端文件的**内容完全一致**（例如只是文件被重命名、移动路径，或者从克隆的备份恢复）时使用。
  - **警告：** 如果新旧后端文件内容不同且使用了 `-u`，镜像数据将会损坏。

**-p**

显示命令执行的进度条。在默认（安全）模式下，因为涉及数据比对和复制，操作可能较慢，建议开启此选项。

**-f fmt**

指定输入文件（`filename`）的格式。

**-c**

压缩镜像。 如果在变基过程中需要将数据从旧后端复制到 `filename`（即默认的安全模式下），开启此选项可以对写入 `filename` 的新数据簇进行压缩（前提是目标格式支持压缩，如 `qcow2`）。



### resize

修改磁盘镜像文件的虚拟大小（Virtual Size）。最常用的场景是给虚拟机扩容（增加磁盘空间），但也支持缩容（减少空间）。

```
resize [--object objectdef] [--image-opts] [-f fmt] [--preallocation=prealloc] [-q] [--shrink] filename [+ | -]size
```

**filename**

指定要调整大小的磁盘镜像文件名。

**[+ | -]size**

指定新的大小或大小的变化量。

- **绝对大小**：直接输入数字加单位（例如 `100G`），镜像大小将被设定为这个值。
- **相对大小**：使用 `+` 或 `-` 前缀（例如 `+10G` 或 `-5G`），镜像大小将在当前基础上增加或减少。
- 支持的单位：`k` (KB), `M` (MB), `G` (GB), `T` (TB), `P` (PB), `E` (EB)。

**--shrink**

启用“缩容”模式。 默认情况下，`qemu-img` 禁止减小镜像大小，以防止意外丢失数据。如果你确定要减小镜像，必须加上此参数。

- **严重警告**：在使用 `qemu-img resize --shrink` 之前，**必须**先在虚拟机内部通过文件系统工具（如 Linux 的 `resize2fs` 或 Windows 的磁盘管理）缩小文件系统和分区。如果在缩小镜像之前没有先缩小文件系统，**将会导致文件系统损坏和数据永久丢失**。

**--preallocation=prealloc**

指定扩容时的预分配策略（主要针对 `raw` 格式，部分支持 `qcow2`）。

- `off`（默认）：不预分配空间。对于稀疏文件（如 qcow2），扩容后的新增部分通常只是修改元数据，瞬间完成，实际磁盘空间占用不增加。
- `metadata`：预分配元数据。
- `falloc`：使用 `posix_fallocate()` 分配空间（速度较快，占用实际磁盘空间）。
- `full`：分配所有空间并将数据置零（速度最慢，占用实际磁盘空间）。

**-f fmt**

显式指定镜像文件的格式。 通常 `resize` 操作后，你需要重新启动虚拟机，并在虚拟机操作系统内部扩展分区和文件系统，才能真正利用新增的空间。











### dd

类似 Linux 系统标准的 `dd` 命令，用于在文件之间复制和转换数据。与系统 `dd` 最大的不同在于，`qemu-img dd` 能够理解并处理 QEMU 支持的各种虚拟磁盘格式（如 `qcow2`, `vmdk`），而不仅仅是将文件视为原始字节流。这使得它非常适合从复杂的镜像格式中提取特定数据块，或向其中写入数据。

```
dd [--image-opts] [-U] [-f fmt] [-O output_fmt] [bs=block_size] [count=blocks] [skip=blocks] if=input of=output
```

**if=input**

指定输入文件（Input File）。 这是你要读取数据的源镜像文件。

**of=output**

指定输出文件（Output File）。 这是你要写入数据的目标文件。

**bs=block_size**

指定读写的块大小（Block Size）。 默认值为 **512** 字节。`count` 和 `skip` 参数都将以这个大小为单位进行计算。支持常见的后缀单位（如 `1M`, `4k`）。

**count=blocks**

仅复制指定数量（`blocks`）的块。 如果省略此参数，默认将一直复制到输入文件的末尾。

**skip=blocks**

在开始复制之前，跳过输入文件开头的指定数量（`blocks`）的块。 这通常用于提取分区或跳过文件头。

**-f fmt**

指定**输入**文件（`if`）的格式。 例如，如果你从一个 `qcow2` 文件中读取数据，指定 `-f qcow2` 后，`qemu-img` 会正确解析 qcow2 的内部结构，读取其**虚拟磁盘数据**（Payload），而不是读取 qcow2 文件本身的元数据头或压缩数据。

**-O output_fmt**

指定**输出**文件（`of`）的格式。 这允许你在复制数据的同时进行格式转换，或者将数据写入到一个特定格式的现有镜像中。

**-U**

以“非独占”模式（Unsafe / Force Share）打开文件。 允许在其他进程正在使用该镜像时运行 `dd` 命令。这对于只读操作通常是安全的，但需谨慎使用。

**--image-opts**

将 `if` 或 `of` 的文件名参数视为一组复杂的选项键值对。 用于处理需要特殊驱动参数（如对象存储、加密密钥等）的输入或输出源。



### map

导出磁盘镜像文件的分配映射信息。该命令会详细列出镜像中每一段数据在虚拟磁盘上的偏移量（Guest Offset）与实际物理文件中的偏移量（Host Offset）之间的对应关系。它常用于分析镜像文件的稀疏程度、检查数据碎片、或者判断哪些数据块是全零的、哪些是未分配的。

```
map [--object objectdef] [--image-opts] [-f fmt] [--start-offset=offset] [--max-length=len] [--output=ofmt] [-U] filename
```

**filename**

指定要分析的磁盘镜像文件名。

**--output=ofmt**

指定输出格式。

- `human`（默认）：以文本表格形式显示，适合人类快速查看。
- `json`：以 JSON 格式输出。这是该命令最强大的用法，输出包含详细的标志位（如 `zero` 是否全零, `data` 是否包含数据, `offset` 物理偏移量）。这非常适合配合脚本（如 Python）来分析磁盘结构或编写自定义的备份/迁移工具。

**--start-offset=offset**

指定开始分析的**虚拟磁盘**字节偏移量。 默认从 0 开始。如果你只关心磁盘后半部分的分配情况，可以使用此参数跳过前面。

**--max-length=len**

指定要分析的数据长度（字节数）。 配合 `--start-offset` 使用，可以只扫描镜像文件中的特定一段区域，而不是扫描整个文件，这在分析超大镜像时能节省时间。

**-f fmt**

指定输入文件的格式。 如果不指定，会自动检测。对于 `qcow2` 等复杂格式，指定格式有助于准确解析 L1/L2 表结构。

**-U**

以“非独占”模式（Unsafe / Force Share）打开镜像。 允许在虚拟机正在运行（持有锁）的情况下读取映射信息。虽然 `map` 是只读操作，但在数据频繁写入时读取到的映射表可能会出现瞬时不一致。

**--image-opts**

将文件名参数视为一组选项键值对。 用于处理复杂的后端配置（如加密、网络存储源）。



### compare

比较两个磁盘镜像文件的内容。该命令通过读取两个镜像的**逻辑数据**进行比较，而不是简单地比对文件本身的二进制字节。这意味着你可以比较两个不同格式的镜像（例如，验证一个 `raw` 格式的源文件和一个转换后的 `qcow2` 目标文件内容是否一致）。

如果两个镜像的内容相同，命令的退出状态码（Exit Code）为 **0**；如果内容不同，状态码为 **1**；如果有错误发生，状态码为 **2**。

```
compare [--object objectdef] [--image-opts] [-f fmt] [-F fmt] [-T src_cache] [-p] [-q] [-s] [-U] filename1 filename2
```

**filename1 filename2**

指定要比较的两个磁盘镜像文件。

**-f fmt**

指定第一个镜像（`filename1`）的格式。

**-F fmt**

指定第二个镜像（`filename2`）的格式。 当你比较不同格式的镜像（例如验证格式转换的完整性）时，这是一个非常常用的参数。

**-s**

启用“严格”模式（Strict Mode）。

- **默认模式下**：如果两个镜像大小不同，但较大的那个镜像多出来的部分全都是零（Zeros），`qemu-img` 仍然会认为它们是“相等”的。此外，它主要关注读取出的数据是否一致。
- **严格模式下 (`-s`)**：如果两个镜像的虚拟大小（Virtual Size）不完全一致，或者扇区的分配状态（Allocation status）存在特定差异，命令会直接报错并认为镜像不相等。

**-p**

显示比较过程的进度条。 由于比较操作需要全量读取两个文件的所有数据，对于大文件来说耗时较长，建议开启此选项。

**-q**

静默模式（Quiet Mode）。 不输出任何文本信息，仅通过程序的**退出状态码**来反馈结果。

- **0**: 镜像内容完全相同。
- **1**: 镜像内容不同。
- **>1**: 发生错误（如文件无法打开）。 这非常适合在 Shell 脚本中使用。

**-U**

以“非独占”模式（Unsafe / Force Share）打开镜像。 允许在其他进程（如运行中的虚拟机）正在使用这些镜像时进行比较。 *注意：如果在比较过程中虚拟机正在写入数据，可能会导致比较结果显示“不一致”或出现读取错误。*



### commit

提交更改。将指定镜像文件（通常是一个增量镜像/Overlay）中的所有更改合并回其**后端文件**（Backing File）。

一旦操作完成，后端文件将包含最新的数据，而当前的增量镜像文件在逻辑上可能变得冗余（除非你继续使用它记录新的差异）。

这是一个修改基础镜像的操作，因此需确保没有其他虚拟机正在以独占方式使用该基础镜像。

```
commit [--object objectdef] [--image-opts] [-q] [-f fmt] [-t cache] [-b base] [-r rate_limit] [-d] [-p] filename
```

**filename**

指定要提交的镜像文件（即包含增量数据的覆盖层）。 注意：这是数据的**来源**，数据将从这里流向其后端文件。

**-b base**

指定要合并到的**目标**后端文件。 在多层镜像链中（例如：`Base <- Middle <- Top`），默认情况下，`commit Top` 会将数据合并到 `Middle`。 如果你指定了 `-b Base`，`qemu-img` 将会把 `Top` 以及它与 `Base` 之间的所有中间层（如 `Middle`）的数据全部合并进 `Base` 中。这允许你跨层合并数据。

**-d**

在提交完成后，**清空**（Discard）源镜像文件中的数据。

- 如果不使用 `-d`：数据被复制到后端文件后，源镜像中依然保留着这些数据副本。
- 如果使用 `-d`：提交成功后，源镜像中的对应数据块将被标记为“未分配”或清零。这使得源镜像变回一个空的增量层，能够释放磁盘空间（取决于文件系统支持）。

**-p**

显示提交过程的进度条。 由于提交操作涉及大量数据写入后端文件，建议开启此选项以监控进度。

**-f fmt**

显式指定输入文件（`filename`）的格式。

**-r rate_limit**

限制提交操作的 I/O 速率（字节/秒）。 如果你的服务器负载较高，为了避免 `commit` 操作占满磁盘 I/O 导致其他虚拟机卡顿，可以使用此参数进行限速。

**-q**

静默模式。不输出任何信息（除非报错）。





### 参数

`filename` 磁盘镜像文件名。

`objectdef` QEMU 用户可创建对象的定义。请参阅 `qemu(1)` 手册页了解对象属性的描述。最常见的对象类型是 `secret`，用于提供密码和/或加密密钥。

`fmt` 磁盘镜像格式。大多数情况下会自动识别。

`cache` 用于写入输出磁盘镜像的缓存模式。有效的选项包括：

- `none`
- `writeback`（默认，`convert` 命令除外）
- `writethrough`
- `directsync`
- `unsafe`（`convert` 命令的默认值）

`src_cache` 用于读取输入磁盘镜像的缓存模式，有效的选项与 `cache` 选项相同。

`size` 磁盘镜像大小（以字节为单位）。支持的可选后缀包括：

- `k` 或 `K` (千字节, 1024)
- `M` (兆字节, 1024k)
- `G` (吉字节, 1024M)
- `T` (太字节, 1024G)
- `P` (拍字节, 1024T)
- `E` (艾字节, 1024P)
- `b` 将被忽略。

`output_filename` 目标磁盘镜像文件名。

`output_fmt` 目标格式。

`options` 以逗号分隔的特定格式选项列表，采用 `name=value` 格式。使用 `-o help` 可查看所用格式支持的选项概览。

`snapshot_param` 用于内部快照的参数，格式为 `snapshot.id=[ID],snapshot.name=[NAME]`，或 `[ID_OR_NAME]`。

`-c` 表示目标镜像必须被压缩（仅限 qcow 格式）。

`-u` 允许不安全的后备链（backing chains）。

- 对于变基（rebasing），假设旧的和新的后备文件完全匹配。在这种情况下，变基前镜像不需要可用的后备文件（对于重命名后备文件很有用）。
- 对于镜像创建，允许在不尝试打开后备文件的情况下创建。

`-h` 带或不带命令显示此帮助并列出支持的格式。

`-p` 显示命令进度（仅限特定命令）。

`-q` 使用静默模式 - 不打印任何输出（错误除外）。

`-S` 指示连续字节数（默认为 4k），这些字节必须全为零，以便 `qemu-img` 在转换期间创建稀疏镜像。如果字节数为 0，则不会扫描源的未分配或零扇区，并且目标镜像将始终完全分配。

`--output` 指定输出必须采用的格式（`human` 或 `json`）。

`-n` 跳过目标卷创建（如果卷在运行 `qemu-img` 之前已创建，则很有用）。



**bitmap 子命令参数**

`bitmap` 要操作的位图名称，通过以下一个或多个动作进行操作： `--add`, `--remove`, `--clear`, `--enable`, `--disable`, 或 `--merge source`。

`-g granularity` 设置 `--add` 动作的粒度。

`-b source` 和 `-F src_fmt` 告诉 `--merge` 动作从替代文件中查找源位图。



**check 子命令参数**

`-r` 尝试修复检查期间发现的任何不一致。

- `-r leaks`：仅修复簇泄漏（cluster leaks）。
- `-r all`：修复所有类型的错误，但这会有较高的风险选错修复方式或掩盖已经发生的损坏。



**convert 子命令参数**

`--bitmaps` 将所有顶层持久位图复制到目标。

`-m` 指定转换过程中并行工作的协程（coroutines）数量（默认为 8）。

`-W` 允许乱序写入目标，而不是顺序写入。



**snapshot 子命令参数**

`snapshot` 要创建、应用或删除的快照名称。

`-a` 应用快照（将磁盘恢复到保存的状态）。

`-c` 创建快照。

`-d` 删除快照。

`-l` 列出给定镜像中的所有快照。



**compare 子命令参数**

`-f` 第一个镜像的格式。

`-F` 第二个镜像的格式。

`-s` 在严格模式下运行 - 当镜像大小或扇区分配不同时失败。



**dd 子命令参数**

`bs=BYTES` 每次读写最多 BYTES 字节（默认：512）。

`count=N` 仅复制 N 个输入块。

`if=FILE` 从 FILE 读取。

`of=FILE` 写入 FILE。

`skip=N` 跳过输入开头的 N 个 bs 大小的块。



### 典型示例

#### qcow2 合并

创建一个 10GB 的 disk-a.qcow2 磁盘

```
qemu-img create -f qcow2 disk-a.qcow2 10g
```



将 disk-a.qcow2 映射为块设备，格式化为 xfs 文件系统，挂载到 /mnt/nbd0 路径下，并向文件系统中写入 1GB 的文件（内容随机）

```
qemu-nbd -c /dev/nbd0 disk-a.qcow2
```

```
mkfs.xfs /dev/nbd0 
```

```
# mkfs.xfs /dev/nbd0 
meta-data=/dev/nbd0              isize=512    agcount=4, agsize=655360 blks
         =                       sectsz=512   attr=2, projid32bit=1
         =                       crc=1        finobt=1, sparse=1, rmapbt=1
         =                       reflink=1    bigtime=1 inobtcount=1 nrext64=0
data     =                       bsize=4096   blocks=2621440, imaxpct=25
         =                       sunit=0      swidth=0 blks
naming   =version 2              bsize=4096   ascii-ci=0, ftype=1
log      =internal log           bsize=4096   blocks=16384, version=2
         =                       sectsz=512   sunit=0 blks, lazy-count=1
realtime =none                   extsz=4096   blocks=0, rtextents=0
Discarding blocks...Done.
```

```
mkdir /mnt/nbd0
```

```
mount /dev/nbd0 /mnt/nbd0
```

```
cd /mnt/nbd0
```

```
dd if=/dev/urandom of=1G_random_file bs=1M count=1024 status=progress
```



将 disk-a.qco2 取消挂载，并取消映射

```
umount /mnt/nbd0
qemu-nbd -d /dev/nbd0
```

**注意：需要离开 /mnt/nbd0 目录，否则无法取消挂载。**





将 disk-a.qcow2 文件复制一份，命名为 disk-b.qcow2 ，向 disk-b.qcow2 文件中写入 512MB 数据（内容随机）

```
cp -p disk-a.qcow2 disk-b.qcow2
```

```
qemu-nbd -c /dev/nbd0 disk-b.qcow2
```

```
mount /dev/nbd0 /mnt/nbd0
```

```
cd /mnt/nbd0
```

```
dd if=/dev/urandom of=512MB_random_file bs=1M count=512 status=progress
```



将 disk-a.qco2 取消挂载，并取消映射

```
umount /mnt/nbd0
qemu-nbd -d /dev/nbd0
```



将 disk-b.qcow2文件复制一份，命名为 disk-c.qcow2。

```
cp -p disk-b.qcow2 disk-c.qcow2
```

```
# du -sh * 
1.1G	disk-a.qcow2
1.6G	disk-b.qcow2
1.6G	disk-c.qcow2
```

```
# qemu-img info --backing-chain disk-c.qcow2 
image: disk-c.qcow2
file format: qcow2
virtual size: 10 GiB (10737418240 bytes)
disk size: 1.56 GiB
cluster_size: 65536
Format specific information:
    compat: 1.1
    compression type: zlib
    lazy refcounts: false
    refcount bits: 16
    corrupt: false
    extended l2: false
Child node '/file':
    filename: disk-c.qcow2
    protocol type: file
    file length: 1.56 GiB (1678966784 bytes)
    disk size: 1.56 GiB
```



将 disk-c.qcow2 变基到 disk-a.qcow2。虽然 disk-c.qcow2 没有父磁盘，但是也可以变基成功。

```
qemu-img rebase -f qcow2 -b disk-a.qcow2 -F qcow2 disk-c.qcow2 -p 
```

```
# qemu-img info --backing-chain disk-c.qcow2  
image: disk-c.qcow2
file format: qcow2
virtual size: 10 GiB (10737418240 bytes)
disk size: 1.56 GiB
cluster_size: 65536
backing file: disk-a.qcow2
backing file format: qcow2
Format specific information:
    compat: 1.1
    compression type: zlib
    lazy refcounts: false
    refcount bits: 16
    corrupt: false
    extended l2: false
Child node '/file':
    filename: disk-c.qcow2
    protocol type: file
    file length: 1.56 GiB (1678966784 bytes)
    disk size: 1.56 GiB

image: disk-a.qcow2
file format: qcow2
virtual size: 10 GiB (10737418240 bytes)
disk size: 1.06 GiB
cluster_size: 65536
Format specific information:
    compat: 1.1
    compression type: zlib
    lazy refcounts: false
    refcount bits: 16
    corrupt: false
    extended l2: false
Child node '/file':
    filename: disk-a.qcow2
    protocol type: file
    file length: 1.06 GiB (1142030336 bytes)
    disk size: 1.06 GiB
    Format specific information:
        extent size hint: 1048576

```



`qemu-img rebase` 的主要功能是修改镜像链的指向。在执行变基时，如果子镜像（Overlay）中已经存在被分配的数据块，即使该数据与新的父镜像（Backing file）完全一致，rebase 操作也**不会**主动回收子镜像中的空间。这将导致父子镜像中存在冗余数据，即数据被保存了两份，无法实现自动去重。

```
# du -sh * 
1.1G	disk-a.qcow2
1.6G	disk-b.qcow2
1.6G	disk-c.qcow2
```



删除 disk-c.qcow2 文件。

```
rm -f disk-c.qcow2
```



不要直接复制 disk-b.qcow2，而是以  disk-b.qcow2 为父镜像（Backing File），创建一个名为 disk-c.qcow2 的子磁盘。

此时 disk-c.qcow2 仅含元数据（约 4MB），本身不存数据，但对外呈现的内容与 disk-b.qcow2 完全一致。

将 disk-c.qcow2 变基至 disk-a.qcow2。变基后，disk-c.qcow2 将保存 disk-b.qcow2 与 disk-a.qcow2 之间的差异部分。

```
qemu-img create -f qcow2 -b disk-b.qcow2 -F qcow2 disk-c.qcow2
```

```
# du -sh * 
1.1G	disk-a.qcow2
1.6G	disk-b.qcow2
196K	disk-c.qcow2
```

```
# qemu-img info --backing-chain disk-c.qcow2 
image: disk-c.qcow2
file format: qcow2
virtual size: 10 GiB (10737418240 bytes)
disk size: 196 KiB
cluster_size: 65536
backing file: disk-b.qcow2
backing file format: qcow2
Format specific information:
    compat: 1.1
    compression type: zlib
    lazy refcounts: false
    refcount bits: 16
    corrupt: false
    extended l2: false
Child node '/file':
    filename: disk-c.qcow2
    protocol type: file
    file length: 192 KiB (197120 bytes)
    disk size: 196 KiB
    Format specific information:
        extent size hint: 1048576

image: disk-b.qcow2
file format: qcow2
virtual size: 10 GiB (10737418240 bytes)
disk size: 1.56 GiB
cluster_size: 65536
Format specific information:
    compat: 1.1
    compression type: zlib
    lazy refcounts: false
    refcount bits: 16
    corrupt: false
    extended l2: false
Child node '/file':
    filename: disk-b.qcow2
    protocol type: file
    file length: 1.56 GiB (1678966784 bytes)
    disk size: 1.56 GiB
```

```
qemu-img rebase -f qcow2 -b disk-a.qcow2 -F qcow2 disk-c.qcow2
```

```
# du -sh * 
1.1G	disk-a.qcow2
1.6G	disk-b.qcow2
515M	disk-c.qcow2
```

```
# qemu-img info --backing-chain disk-c.qcow2 
image: disk-c.qcow2
file format: qcow2
virtual size: 10 GiB (10737418240 bytes)
disk size: 515 MiB
cluster_size: 65536
backing file: disk-a.qcow2
backing file format: qcow2
Format specific information:
    compat: 1.1
    compression type: zlib
    lazy refcounts: false
    refcount bits: 16
    corrupt: false
    extended l2: false
Child node '/file':
    filename: disk-c.qcow2
    protocol type: file
    file length: 515 MiB (539754496 bytes)
    disk size: 515 MiB
    Format specific information:
        extent size hint: 1048576

image: disk-a.qcow2
file format: qcow2
virtual size: 10 GiB (10737418240 bytes)
disk size: 1.06 GiB
cluster_size: 65536
Format specific information:
    compat: 1.1
    compression type: zlib
    lazy refcounts: false
    refcount bits: 16
    corrupt: false
    extended l2: false
Child node '/file':
    filename: disk-a.qcow2
    protocol type: file
    file length: 1.06 GiB (1142030336 bytes)
    disk size: 1.06 GiB
    Format specific information:
        extent size hint: 1048576
```





#### vmdk 合并

创建一个 10GB 的 disk-a.vmdk磁盘

```
qemu-img create -f vmdk disk-a.vmdk 10g
```



将 disk-a.qcow2 映射为块设备，格式化为 xfs 文件系统，挂载到 /mnt/nbd0 路径下，并向文件系统中写入 1GB 的文件（内容随机）

```
qemu-nbd -c /dev/nbd0 disk-a.vmdk
```

```
mkfs.xfs /dev/nbd0 
```

```
# mkfs.xfs /dev/nbd0 
meta-data=/dev/nbd0              isize=512    agcount=4, agsize=655360 blks
         =                       sectsz=512   attr=2, projid32bit=1
         =                       crc=1        finobt=1, sparse=1, rmapbt=1
         =                       reflink=1    bigtime=1 inobtcount=1 nrext64=0
data     =                       bsize=4096   blocks=2621440, imaxpct=25
         =                       sunit=0      swidth=0 blks
naming   =version 2              bsize=4096   ascii-ci=0, ftype=1
log      =internal log           bsize=4096   blocks=16384, version=2
         =                       sectsz=512   sunit=0 blks, lazy-count=1
realtime =none                   extsz=4096   blocks=0, rtextents=0
Discarding blocks...Done.
```

```
mkdir /mnt/nbd0
```

```
mount /dev/nbd0 /mnt/nbd0
```

```
cd /mnt/nbd0
```

```
dd if=/dev/urandom of=1G_random_file bs=1M count=1024 status=progress
```



将 disk-a.vmdk 取消挂载，并取消映射

```
umount /mnt/nbd0
qemu-nbd -d /dev/nbd0
```

**注意：需要离开 /mnt/nbd0 目录，否则无法取消挂载。**





将 disk-a.vmdk文件复制一份，命名为 disk-b.vmdk，向 disk-b.vmdk文件中写入 512MB 数据（内容随机）

```
cp -p disk-a.vmdk disk-b.vmdk
```

```
qemu-nbd -c /dev/nbd0 disk-b.vmdk
```

```
mount /dev/nbd0 /mnt/nbd0
```

```
cd /mnt/nbd0
```

```
dd if=/dev/urandom of=512MB_random_file bs=1M count=512 status=progress
```



将 disk-a.vmdk取消挂载，并取消映射

```
umount /mnt/nbd0
qemu-nbd -d /dev/nbd0
```



基于 disk-b.vmdk 创建 disk-c.vmdk 磁盘

```
qemu-img create -f vmdk -b disk-b.vmdk -F vmdk disk-c.vmdk
```

```
# du -sh * 
1.1G	disk-a.vmdk
1.6G	disk-b.vmdk
1.0M	disk-c.vmdk
```

```
#qemu-img info --backing-chain disk-c.vmdk 
image: disk-c.vmdk
file format: vmdk
virtual size: 10 GiB (10737418240 bytes)
disk size: 1 MiB
cluster_size: 65536
backing file: disk-b.vmdk
backing file format: vmdk
Format specific information:
    cid: 3744897792
    parent cid: 2398414176
    create type: monolithicSparse
    extents:
        [0]:
            virtual size: 10737418240
            filename: disk-c.vmdk
            cluster size: 65536
            format: 
Child node '/file':
    filename: disk-c.vmdk
    protocol type: file
    file length: 1.31 MiB (1376256 bytes)
    disk size: 1 MiB
    Format specific information:
        extent size hint: 1048576

image: disk-b.vmdk
file format: vmdk
virtual size: 10 GiB (10737418240 bytes)
disk size: 1.56 GiB
cluster_size: 65536
Format specific information:
    cid: 2398414176
    parent cid: 4294967295
    create type: monolithicSparse
    extents:
        [0]:
            virtual size: 10737418240
            filename: disk-b.vmdk
            cluster size: 65536
            format: 
Child node '/file':
    filename: disk-b.vmdk
    protocol type: file
    file length: 1.56 GiB (1679556608 bytes)
    disk size: 1.56 GiB
```



尝试将 disk-c.vmdk 变基到 disk-a.vmdk 上，数据从成功迁移过去，但是无法修改父磁盘的指向，最后会失败。

```
qemu-img rebase -f vmdk -b disk-a.vmdk -F vmdk disk-c.vmdk
```

```
# qemu-img rebase -f vmdk -b disk-a.vmdk -F vmdk disk-c.vmdk 
qemu-img: Could not change the backing file to 'disk-a.vmdk': Operation not supported
```

```
# du -sh * 
1.1G	disk-a.vmdk
1.6G	disk-b.vmdk
516M	disk-c.vmdk
```

```
# qemu-img info --backing-chain disk-c.vmdk 
image: disk-c.vmdk
file format: vmdk
virtual size: 10 GiB (10737418240 bytes)
disk size: 516 MiB
cluster_size: 65536
backing file: disk-b.vmdk
backing file format: vmdk
Format specific information:
    cid: 143469794
    parent cid: 2398414176
    create type: monolithicSparse
    extents:
        [0]:
            virtual size: 10737418240
            filename: disk-c.vmdk
            cluster size: 65536
            format: 
Child node '/file':
    filename: disk-c.vmdk
    protocol type: file
    file length: 516 MiB (540606464 bytes)
    disk size: 516 MiB
    Format specific information:
        extent size hint: 1048576

image: disk-b.vmdk
file format: vmdk
virtual size: 10 GiB (10737418240 bytes)
disk size: 1.56 GiB
cluster_size: 65536
Format specific information:
    cid: 2398414176
    parent cid: 4294967295
    create type: monolithicSparse
    extents:
        [0]:
            virtual size: 10737418240
            filename: disk-b.vmdk
            cluster size: 65536
            format: 
Child node '/file':
    filename: disk-b.vmdk
    protocol type: file
    file length: 1.56 GiB (1679556608 bytes)
    disk size: 1.56 GiB

```



删除 disk-c.vmdk 文件。

```
rm -rf disk-c.vmdk
```



基于 disk-b.vmdk 创建 disk-c.qcow2 文件，将 disk-c.qcow2 文件变基到 disk-a.vmdk 文件，最后将 disk-c.qcow2 文件转为 disk-c.vmdk 文件，并指定父磁盘文件为 disk-a.vmdk 文件。

注意：在将 disk-c.qcow2 文件转为 disk-c.vmdk 文件时，必须指定后端为 disk-a.vmdk，否则会转换为一个独立的磁盘。

```
qemu-img create -f qcow2 -b disk-b.vmdk -F vmdk disk-c.qcow2
```

```
# du -sh * 
1.1G	disk-a.vmdk
1.6G	disk-b.vmdk
196K	disk-c.qcow2
```

```
# qemu-img info --backing-chain disk-c.qcow2 
image: disk-c.qcow2
file format: qcow2
virtual size: 10 GiB (10737418240 bytes)
disk size: 196 KiB
cluster_size: 65536
backing file: disk-b.vmdk
backing file format: vmdk
Format specific information:
    compat: 1.1
    compression type: zlib
    lazy refcounts: false
    refcount bits: 16
    corrupt: false
    extended l2: false
Child node '/file':
    filename: disk-c.qcow2
    protocol type: file
    file length: 192 KiB (197120 bytes)
    disk size: 196 KiB
    Format specific information:
        extent size hint: 1048576

image: disk-b.vmdk
file format: vmdk
virtual size: 10 GiB (10737418240 bytes)
disk size: 1.56 GiB
cluster_size: 65536
Format specific information:
    cid: 2398414176
    parent cid: 4294967295
    create type: monolithicSparse
    extents:
        [0]:
            virtual size: 10737418240
            filename: disk-b.vmdk
            cluster size: 65536
            format: 
Child node '/file':
    filename: disk-b.vmdk
    protocol type: file
    file length: 1.56 GiB (1679556608 bytes)
    disk size: 1.56 GiB
```

```
qemu-img rebase -f qcow2 -b disk-a.vmdk -F vmdk disk-c.qcow2
```

```
# du -sh * 
1.1G	disk-a.vmdk
1.6G	disk-b.vmdk
515M	disk-c.qcow2
```

```
# qemu-img info --backing-chain disk-c.qcow2 
image: disk-c.qcow2
file format: qcow2
virtual size: 10 GiB (10737418240 bytes)
disk size: 515 MiB
cluster_size: 65536
backing file: disk-a.vmdk
backing file format: vmdk
Format specific information:
    compat: 1.1
    compression type: zlib
    lazy refcounts: false
    refcount bits: 16
    corrupt: false
    extended l2: false
Child node '/file':
    filename: disk-c.qcow2
    protocol type: file
    file length: 515 MiB (539754496 bytes)
    disk size: 515 MiB
    Format specific information:
        extent size hint: 1048576

image: disk-a.vmdk
file format: vmdk
virtual size: 10 GiB (10737418240 bytes)
disk size: 1.06 GiB
cluster_size: 65536
Format specific information:
    cid: 1884613872
    parent cid: 4294967295
    create type: monolithicSparse
    extents:
        [0]:
            virtual size: 10737418240
            filename: disk-a.vmdk
            cluster size: 65536
            format: 
Child node '/file':
    filename: disk-a.vmdk
    protocol type: file
    file length: 1.06 GiB (1142685696 bytes)
    disk size: 1.06 GiB
    Format specific information:
        extent size hint: 1048576
```

```
qemu-img convert -f qcow2 -O vmdk -B disk-a.vmdk -F vmdk disk-c.qcow2 disk-c.vmdk
```

```
# du -sh * 
1.1G	disk-a.vmdk
1.6G	disk-b.vmdk
515M	disk-c.qcow2
516M	disk-c.vmdk
```

```
# qemu-img info --backing-chain disk-c.vmdk 
image: disk-c.vmdk
file format: vmdk
virtual size: 10 GiB (10737418240 bytes)
disk size: 516 MiB
cluster_size: 65536
backing file: disk-a.vmdk
backing file format: vmdk
Format specific information:
    cid: 1949635101
    parent cid: 1884613872
    create type: monolithicSparse
    extents:
        [0]:
            virtual size: 10737418240
            filename: disk-c.vmdk
            cluster size: 65536
            format: 
Child node '/file':
    filename: disk-c.vmdk
    protocol type: file
    file length: 516 MiB (540606464 bytes)
    disk size: 516 MiB
    Format specific information:
        extent size hint: 1048576

image: disk-a.vmdk
file format: vmdk
virtual size: 10 GiB (10737418240 bytes)
disk size: 1.06 GiB
cluster_size: 65536
Format specific information:
    cid: 1884613872
    parent cid: 4294967295
    create type: monolithicSparse
    extents:
        [0]:
            virtual size: 10737418240
            filename: disk-a.vmdk
            cluster size: 65536
            format: 
Child node '/file':
    filename: disk-a.vmdk
    protocol type: file
    file length: 1.06 GiB (1142685696 bytes)
    disk size: 1.06 GiB
    Format specific information:
        extent size hint: 1048576
```



#### dd_rescue

`dd_rescue` (Kurt Garloff 版) 是一个功能极其强大的数据复制和恢复工具。

与标准的 `dd` 相比，它最大的优势在于：**遇到读写错误时不会终止**，而是自动调整块大小尝试读取剩余数据；同时，它还具备高级特性，如你在上一步使用的“增量同步”（`-W`）。



dd_rescue 在大部分 Linux 发型版本中无法通过官方包管理器进行安装，通常需要通过编译源代码进行安装，不过 dd_rescue 需要的依赖较少，非常容易编译成功。以下是在 Alpine Linux 中编译 dd_rescue 命令的示例。



软件包官网：https://www.garloff.de/kurt/linux/ddrescue/

软件包下载地址（官网）：https://www.garloff.de/kurt/linux/ddrescue/#Downloads



系统环境（来自 /etc/os-release 文件、uname -a 的输出）：

```
NAME="Alpine Linux"
ID=alpine
VERSION_ID=3.22.2
PRETTY_NAME="Alpine Linux v3.22"
HOME_URL="https://alpinelinux.org/"
BUG_REPORT_URL="https://gitlab.alpinelinux.org/alpine/aports/-/issues"
```

```
Linux localhost 6.12.53-0-virt #1-Alpine SMP PREEMPT_DYNAMIC 2025-10-15 20:12:44 x86_64 Linux
```



安装编译环境

```
apk update
apk add build-base autoconf bash linux-headers openssl-dev lzo-dev xz-dev attr-dev acl-dev
```



解压软件包并进入

```
tar -xvf dd_rescue-1.99.21.tar.bz2
cd dd_rescue-1.99.21
```



编译并安装

```
make
make install
```



验证

```
# dd_rescue -V 

dd_rescue Version 1.99.21, kurt@garloff.de, GNU GPL v2/v3
 (DD_RESCUE_1_99_21)
 (compiled Nov 22 2025 10:12:30 by gcc (Alpine 14.2.0) 14.2.0)
 (features: O_DIRECT dl/libfallocate fallocate splice fitrim xattr rdrnd sha vaes avx2)
dd_rescue is free software. It's protected by the terms of GNU GPL v2 or v3
 (at your option).
```



创建一个 10GB 的 disk-a.vmdk磁盘

```
qemu-img create -f vmdk disk-a.vmdk 10g
```



将 disk-a.qcow2 映射为块设备，格式化为 xfs 文件系统，挂载到 /mnt/nbd0 路径下，并向文件系统中写入 1GB 的文件（内容随机）

```
qemu-nbd -c /dev/nbd0 disk-a.vmdk
```

```
mkfs.xfs /dev/nbd0 
```

```
# mkfs.xfs /dev/nbd0 
meta-data=/dev/nbd0              isize=512    agcount=4, agsize=655360 blks
         =                       sectsz=512   attr=2, projid32bit=1
         =                       crc=1        finobt=1, sparse=1, rmapbt=1
         =                       reflink=1    bigtime=1 inobtcount=1 nrext64=0
data     =                       bsize=4096   blocks=2621440, imaxpct=25
         =                       sunit=0      swidth=0 blks
naming   =version 2              bsize=4096   ascii-ci=0, ftype=1
log      =internal log           bsize=4096   blocks=16384, version=2
         =                       sectsz=512   sunit=0 blks, lazy-count=1
realtime =none                   extsz=4096   blocks=0, rtextents=0
Discarding blocks...Done.
```

```
mkdir /mnt/nbd0
```

```
mount /dev/nbd0 /mnt/nbd0
```

```
cd /mnt/nbd0
```

```
dd if=/dev/urandom of=1G_random_file bs=1M count=1024 status=progress
```



将 disk-a.vmdk 取消挂载，并取消映射

```
umount /mnt/nbd0
qemu-nbd -d /dev/nbd0
```

**注意：需要离开 /mnt/nbd0 目录，否则无法取消挂载。**





将 disk-a.vmdk文件复制一份，命名为 disk-b.vmdk，向 disk-b.vmdk文件中写入 512MB 数据（内容随机）

```
cp -p disk-a.vmdk disk-b.vmdk
```

```
qemu-nbd -c /dev/nbd0 disk-b.vmdk
```

```
mount /dev/nbd0 /mnt/nbd0
```

```
cd /mnt/nbd0
```

```
dd if=/dev/urandom of=512MB_random_file bs=1M count=512 status=progress
```



将 disk-a.vmdk取消挂载，并取消映射

```
umount /mnt/nbd0
qemu-nbd -d /dev/nbd0
```



基于 disk-a.vmdk 创建 disk-c.vmdk 磁盘

```
qemu-img create -f vmdk -b disk-a.vmdk -F vmdk disk-c.vmdk
```

```
# du -sh * 
1.1G	disk-a.vmdk
1.6G	disk-b.vmdk
1.0M	disk-c.vmdk
```

```
# qemu-img info --backing-chain disk-c.vmdk 
image: disk-c.vmdk
file format: vmdk
virtual size: 10 GiB (10737418240 bytes)
disk size: 1 MiB
cluster_size: 65536
backing file: disk-a.vmdk
backing file format: vmdk
Format specific information:
    cid: 51600576
    parent cid: 1884613872
    create type: monolithicSparse
    extents:
        [0]:
            virtual size: 10737418240
            filename: disk-c.vmdk
            cluster size: 65536
            format: 
Child node '/file':
    filename: disk-c.vmdk
    protocol type: file
    file length: 1.31 MiB (1376256 bytes)
    disk size: 1 MiB
    Format specific information:
        extent size hint: 1048576

image: disk-a.vmdk
file format: vmdk
virtual size: 10 GiB (10737418240 bytes)
disk size: 1.06 GiB
cluster_size: 65536
Format specific information:
    cid: 1884613872
    parent cid: 4294967295
    create type: monolithicSparse
    extents:
        [0]:
            virtual size: 10737418240
            filename: disk-a.vmdk
            cluster size: 65536
            format: 
Child node '/file':
    filename: disk-a.vmdk
    protocol type: file
    file length: 1.06 GiB (1142685696 bytes)
    disk size: 1.06 GiB
    Format specific information:
        extent size hint: 1048576
```



将 disk-b.vmdk 和 disk-c.vmdk 映射到 /dev/nbd0 和 /dev/nbd1

```
qemu-nbd -c /dev/nbd0 disk-b.vmdk
qemu-nbd -c /dev/nbd1 disk-c.vmdk
```



使用 dd_rescue 命令将 /dev/nbd0 克隆到 /dev/nbd1，并使用 -W 参数，读取目标位置的数据，如果与源数据一致，则跳过写入；如果不一致，则写入。这极大地减少了对目标设备的写入磨损，并加快了在大部分数据一致时的同步速度。

```
dd_rescue -W /dev/nbd0 /dev/nbd1
```

```
# dd_rescue -W /dev/nbd0 /dev/nbd1 
dd_rescue: (info): Using softbs=128.0kiB, hardbs=4.0kiB
dd_rescue: (warning): /dev/nbd1 is a block device; -a not recommended; -A recommended
dd_rescue: (info): expect to copy 10485760.0kiB from /dev/nbd0
dd_rescue: (info): ipos:  10407936.0k, opos:  10407936.0k, xferd:  10407936.0k
                   errs:      0, errxfer:         0.0k, succxfer:  10407936.0k
             +curr.rate:  1391517kB/s, avg.rate:   799024kB/s, avg.load: 75.3%
             >----------------------------------------.<  99%  ETA:  0:00:00 
dd_rescue: (info): read /dev/nbd0 (10485760.0kiB): EOF
dd_rescue: (info): Summary for /dev/nbd0 -> /dev/nbd1
dd_rescue: (info): ipos:  10485760.0k, opos:  10485760.0k, xferd:  10485760.0k
                   errs:      0, errxfer:         0.0k, succxfer:  10485760.0k
             +curr.rate:  1048367kB/s, avg.rate:   611765kB/s, avg.load: 62.1%
             >-----------------------------------------< 100%  TOT:  0:00:17 
dd_rescue: (info): Avoided 9959040.0kiB of writes (performed 526720.0kiB)
```



取消 /dev/nbd0 和 /dev/nbd1 的映射

```
qemu-nbd -d /dev/nbd0
qemu-nbd -d /dev/nbd1
```



查看 disk-c.vmdk 文件的大小，disk-c.vmdk 仅存储了 vmdk-a.vmdk 与 vmdk-b.vmdk 的差异。

```
# du -sh * 
1.1G	disk-a.vmdk
1.6G	disk-b.vmdk
516M	disk-c.vmdk
```



使用 compare 验证 disk-c.vmdk 和 disk-b.vmdk 数据是否一致。

```
qemu-img compare -f vmdk -F vmdk disk-c.vmdk disk-b.vmdk
```

```
# qemu-img compare -f vmdk -F vmdk disk-c.vmdk disk-b.vmdk  
Images are identical.
```

**注：数据完全一致。**



基于 VMDK 快照链（Backing Chain）的存储原理，要理解为什么必须仅复制“差异部分”而不能使用标准 `dd` 进行全盘复制，关键在于理解“写时复制（Copy-On-Write）”机制中**读取**与**写入**行为的根本不对称性。

在 VMDK 的快照链结构中，disk-c 作为 disk-a 的子磁盘，本质上是一个增量文件。虽然在读取像 disk-c 这样的子磁盘数据时，如果请求的数据块在 disk-c 中尚未被写入（即该位置处于未分配或“稀疏”状态），虚拟化层会自动透传请求，转而去读取父盘 disk-a 中的对应数据，从而让用户感觉到仿佛是在访问一个完整的数据盘。但在写入数据时，逻辑则截然不同：为了保证 I/O 性能和写入效率，底层驱动并不会预先去验证当前准备写入的数据是否与父磁盘中的既有数据内容一致，而是简单粗暴地直接将所有接收到的写入请求保存到子磁盘 disk-c 中。

这就导致了标准 `dd` 命令在处理此类场景时的致命缺陷。`dd` 是一个“盲目”的复制工具，它只负责将源端（disk-b）的数据逐字节读出，并强行写入到目标端（disk-c）。当 `dd` 读取 disk-b 中那些其实未发生变化、原本就继承自 disk-a 的数据块时，它并不知道这些数据在 disk-c 的父盘中已经存在。随后的写入操作会触发上述的“写入逻辑”，导致 disk-c 在物理上重新分配空间并存储了一份与父盘 disk-a 完全相同的冗余数据。结果就是，disk-c 会迅速膨胀，失去了快照盘仅存储“差异”的意义，变成了一个包含大量重复数据的臃肿文件。

相反，`dd_rescue` 的 `-W`（避免写入）参数正是利用了 VMDK 的“读取逻辑”来规避“写入逻辑”的缺陷。在写入前，它会先读取目标位置的数据（此时如果 disk-c 没数据，读到的就是 disk-a 的数据），并与源数据（disk-b）进行比对。只有当两者内容不一致时，它才执行写入操作。这样，对于那些未修改的数据块，disk-c 保持“未写入”状态，继续透明地引用 disk-a，从而实现了真正的增量同步，将 disk-c 的体积维持在最小限度。

