# MySQL

## 概念

**什么是 SQL**

**结构化查询语言（Structured Query Language, SQL）** 是一种为**管理关系型数据库**管理系统（RDBMS）中的数据而设计的、具备高度标准化的领域特定语言（Domain-Specific Language, DSL）。

SQL的根本目的在于提供一个统一的、声明式（Declarative）的接口，用以执行数据查询、数据操纵、数据定义以及数据访问控制。



**SQL 标准**

SQL由美国国家标准协会（ANSI）和国际标准化组织（ISO）进行标准化，其正式标准为 ISO/IEC 9075。这个标准定义了语言的语法、数据类型和核心功能集，旨在确保不同数据库系统之间的可移植性和互操作性。



**SQL 与 RDBMS 的关系**

SQL本身只是一套语言规范，它需要一个强大的软件系统来解释、执行并管理底层数据。这个软件系统就是关系型数据库管理系统（Relational Database Management System, RDBMS）。

RDBMS是用于创建、更新和管理关系型数据库的应用程序 。它是一个复杂的软件集合，提供了数据存储、检索、安全、备份、恢复和性能优化等一系列功能。市面上知名的RDBMS产品包括MySQL、PostgreSQL、Oracle Database、Microsoft SQL Server等 。  

- **核心是关系模型**：RDBMS的核心是严格遵循埃德加·科德定义的关系模型。数据被逻辑地组织在二维表中，表由行和列构成。这种直观的结构使得用户可以轻松地理解和操作数据 。  
- **关系的建立**：“关系型”的精髓在于表与表之间可以建立关联。这是通过主键（Primary Key）和外键（Foreign Key）实现的。主键是表中唯一标识一行的列（或列的组合），而外键是A表中的一个列，其值引用了B表的主键。通过这种机制，RDBMS可以在不同数据实体之间建立清晰、可靠的关联 。  
- **逻辑与物理分离**：RDBMS的一个关键设计原则是逻辑数据结构与物理存储结构的分离。用户和应用程序操作的是逻辑层面的表和视图，而数据库管理员可以在不影响上层应用的情况下，调整底层的物理存储，如重命名数据文件、将数据迁移到不同的磁盘等。



**SQL 方言**

尽管存在统一的ANSI/ISO标准，但在实际应用中，几乎每个RDBMS都有自己独特的SQL语法变体，这些变体被称为“SQL方言”（SQL Dialects）。SQL方言的存在是SQL生态系统成熟和商业化的自然产物，是理论的纯洁性与市场现实性之间博弈的结果。



SQL方言的差异体现在多个层面，从基本的数据类型定义到复杂的查询语法，几乎无处不在。以下是一些最常见的差异领域：

- 自增列定义：MySQL使用`AUTO_INCREMENT`，PostgreSQL使用`SERIAL`或`GENERATED AS IDENTITY`。
- 字符串拼接：SQL Server使用`+`运算符，而PostgreSQL使用`||`运算符。
- 限制查询结果：SQL Server使用`TOP N`，MySQL和PostgreSQL使用`LIMIT N`。



## SQL命令的五大分类

结构化查询语言 (SQL) 是用于管理和操作关系型数据库的标准语言。为了更好地组织和理解其功能，SQL 命令被划分为五个主要的类别。理解这些分类有助于掌握在数据库上执行不同类型操作的正确命令。

这五大分类分别是：

1. **数据定义语言 (DDL - Data Definition Language)**
2. **数据操纵语言 (DML - Data Manipulation Language)**
3. **数据查询语言 (DQL - Data Query Language)**
4. **数据控制语言 (DCL - Data Control Language)**
5. **事务控制语言 (TCL - Transaction Control Language)**



1. 数据定义语言 (DDL)

DDL 用于**定义和管理数据库的结构**。这些命令负责创建、修改和删除数据库对象，如表、索引、视图等。DDL 操作是自动提交的，意味着一旦执行，就无法回滚。

**核心命令包括：**

- `CREATE`：用于创建新的数据库对象。
- `ALTER`：用于修改现有数据库对象的结构。
- `DROP`：用于完全删除一个现有的数据库对象。
- `TRUNCATE`：用于快速删除表中的所有行，但保留表结构。此操作比 `DELETE` 更快，且通常无法回滚。
- `RENAME`：用于重命名一个数据库对象。



2. 数据操纵语言 (DML)

DML 用于**管理数据库中的数据**，包括插入、更新和删除记录。这些是数据库日常使用中最频繁的操作。DML 操作可以被 TCL 命令（如 `COMMIT` 或 `ROLLBACK`）管理。

**核心命令包括：**

- `INSERT`：向表中添加新的数据行。
- `UPDATE`：修改表中的现有数据。
- `DELETE`：从表中删除一条或多条数据行。



3. 数据查询语言 (DQL)

DQL 可能是最常用的 SQL 命令，专门用于**从数据库中检索数据**。它最核心也是唯一的命令就是 `SELECT`。

**核心命令包括：**

- `SELECT`：用于从一个或多个表中查询数据。它可以与各种子句（如 `FROM`, `WHERE`, `GROUP BY`, `ORDER BY`, `HAVING`）结合使用以实现复杂的查询。



4. 数据控制语言 (DCL)

DCL 用于**管理数据库的访问权限**。它控制哪个用户可以执行哪些 SQL 命令。这对于数据库的安全性至关重要。

**核心命令包括：**

- `GRANT`：授予用户对数据库对象的特定权限（如 `SELECT`, `INSERT`, `UPDATE` 等）。
- `REVOKE`：撤销之前授予用户的权限。



5. 事务控制语言 (TCL)

TCL 用于**管理事务**，确保数据库操作的原子性、一致性、隔离性和持久性（ACID 属性）。事务是一组作为一个逻辑单元执行的 SQL 语句，要么全部成功，要么全部失败。

**核心命令包括：**

- `COMMIT`：永久保存事务中所做的所有更改。
- `ROLLBACK`：撤销当前事务中所做的所有未提交的更改，将数据恢复到上一次 `COMMIT` 时的状态。
- `SAVEPOINT`：在当前事务中设置一个保存点。这允许你之后可以回滚到这个特定的点，而不是整个事务。



## Install

### RHEL 10

#### 安装

RHEL 10 提供了 MySQL 8.4 作为应用程序流的初始版本，其可作为 RPM 软件包轻松地安装。



安装 MySQL 服务器软件包：

```
dnf -y install mysql-server
```



系统启用了 systemd，应使用标准的 **systemctl** 命令，例如 **stop**、**start**、**status** 和 **restart** 来管理 MySQL 服务器服务。默认情况下，`mysqld` 服务已启用，并且会在系统重启时启动。



启用并启动 mysqld 服务：

```
systemctl enable --now mysqld.service
```



安装后提高安全性：

```
mysql_secure_installation
```

此命令启动一个完全交互的脚本，该脚本会提示过程中的每一步。该脚本可让您通过以下方法提高安全性：

- 为 root 帐户设置密码
- 删除匿名用户
- 禁止远程 root 登录（在本地主机之外）



注：在执行此脚本前确保 mysql 服务已经正常运行，可多次执行此脚本修改设置。如果已经设置 MySQL 数据库 root 密码，则第二次执行此脚本时需要输入 root 密码。



如果你在执行 `mysql_secure_installation` 时遇到 `Error: Can't connect to local MySQL server through socket '/var/lib/mysql/mysql.sock' (2)` 错误，这意味着 MySQL 服务器守护程序 (Unix) 或服务 (Windows) 未运行。



执行 mysql_secure_installation 典型示例。

```vim
mysql_secure_installation 

Securing the MySQL server deployment.

Connecting to MySQL using a blank password.

VALIDATE PASSWORD COMPONENT can be used to test passwords
and improve security. It checks the strength of password
and allows the users to set only those passwords which are
secure enough. Would you like to setup VALIDATE PASSWORD component?

Press y|Y for Yes, any other key for No:  # Enter
Please set the password for root here.

New password: # Pass-1234

Re-enter new password: # Pass-1234 
By default, a MySQL installation has an anonymous user,
allowing anyone to log into MySQL without having to have
a user account created for them. This is intended only for
testing, and to make the installation go a bit smoother.
You should remove them before moving into a production
environment.

Remove anonymous users? (Press y|Y for Yes, any other key for No) : # y
Success.


Normally, root should only be allowed to connect from
'localhost'. This ensures that someone cannot guess at
the root password from the network.

Disallow root login remotely? (Press y|Y for Yes, any other key for No) : # n

 ... skipping.
By default, MySQL comes with a database named 'test' that
anyone can access. This is also intended only for testing,
and should be removed before moving into a production
environment.


Remove test database and access to it? (Press y|Y for Yes, any other key for No) : # y
 - Dropping test database...
Success.

 - Removing privileges on test database...
Success.

Reloading the privilege tables will ensure that all changes
made so far will take effect immediately.

Reload privilege tables now? (Press y|Y for Yes, any other key for No) : # y
Success.

All done! 
```



执行 mysql_secure_installation 典型示例（中文翻译）。

```
mysql_secure_installation

保护 MySQL 服务器部署。

使用空白密码连接到 MySQL。

“验证密码组件”可用于测试密码
并提高安全性。它会检查密码强度，
并允许用户仅设置足够安全的密码。
是否要设置“验证密码组件”？

按 y|Y 表示“是”，按任何其他键表示“否”：# Enter
请在此处设置 root 用户的密码。

新密码：# Pass-1234

重新输入新密码：# Pass-1234
默认情况下，MySQL 安装会有一个匿名用户，
允许任何人登录 MySQL，而无需为其创建用户帐户。
这仅用于测试，并使安装过程更顺畅。
在进入生产环境之前，您应该删除它们。

删除匿名用户？ （按 y|Y 表示是，按任何其他键表示否）：# y
成功。

通常，root 只应被允许从
“localhost”连接。这确保了其他人无法从网络猜测到
root 密码。

是否禁止远程 root 登录？（按 y|Y 表示是，按任何其他键表示否）：# n

……跳过。
默认情况下，MySQL 自带一个名为“test”的数据库，
任何人都可以访问。该数据库也仅用于测试，
在迁移到生产环境之前应将其删除。

是否删除测试数据库及其访问权限？（按 y|Y 表示是，按任何其他键表示否）：# y
- 正在删除测试数据库……
成功。

- 正在删除测试数据库的权限……
成功。

重新加载权限表将确保迄今为止所做的所有更改
立即生效。

现在重新加载权限表吗？ （按 y|Y 表示“是”，按任何其他键表示“否”）：# y
成功。

全部完成！
```



#### 配置对 MySQL 的网络访问



## 教程

### 连接和断开服务器

要连接到服务器，您通常需要在调用 **mysql** 时提供一个 MySQL 用户名，并且很有可能还需要提供密码。

如果服务器运行在您登录的机器之外，您还必须指定主机名。



**本地连接**

连接在本机上运行的 mysql 数据库

```
mysql -u root -p
Enter password: ********
```

*`user`* 代表运行 MySQL 帐户的用户名，`********` 代表您的密码，当 mysql 显示 Enter password: 提示符时输入它。



**不安全的登录方式**

可以直接在 -p 参数后面**（此处无空格）**输入密码

```
mysql -u root -pPass-1234
```

**这非常不安全，在生产环境下请不要使用这种方法。此处仅介绍存在该功能。**



**连接其他主机上的 mysql 数据库**

```
mysql -h host -P port -u user -p
Enter password: ********
```

*`host`* 和 *`port`* 代表运行 MySQL 服务器的主机名（ IP 地址）和端口号。

如果你不指定主机名则通过 uninx socket 连接到本地 MySQL 服务器。

仅指定主机名时才允许指定端口，如果你不指定端口号，默认为 3306。



如果这有效，您应该会看到一些介绍性信息，然后是一个 `mysql>` 提示符

```
$> mysql -h 127.0.0.1 -P 3306 -u root -p
Enter password: ********
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 25338 to server version: 8.4.0-standard

Type 'help;' or '\h' for help. Type '\c' to clear the buffer.

mysql>
```



**匿名连接**

某些 MySQL 安装允许用户以匿名（未命名）用户身份连接到运行在本地主机上的服务器。能够直接使用 `mysql` 而不使用任何选项来连接到该服务器。

```
$> mysql
```



成功连接后，您可以随时通过在 `mysql>` 提示符下键入 `QUIT`（或 `\q`）来断开连接

```
mysql> QUIT
Bye
```

在 Unix 上，您也可以通过按下 Control+D 来断开连接。



如果您在尝试登录时收到错误消息，例如 `Error: Can't connect to local MySQL server through socket '/var/lib/mysql/mysql.sock' (2)`，这意味着 MySQL 服务器守护程序 (Unix) 或服务 (Windows) 未运行。



### 输入查询

#### 简单查询

以下是一个简单的查询，它要求服务器告诉您其版本号和当前日期。

```
mysql> SELECT VERSION(), CURRENT_DATE;
+-----------+--------------+
| VERSION() | CURRENT_DATE |
+-----------+--------------+
| 8.4.0-tr  | 2024-01-25   |
+-----------+--------------+
1 row in set (0.00 sec)

mysql>
```

此查询说明了有关 mysql 的几件事

- 查询通常由一个 SQL 语句和一个分号组成。（在某些情况下，可以省略分号。QUIT，前面提到过，就是其中之一。我们稍后会讨论其他情况。）

- 当您发出查询时，**mysql** 会将其发送到服务器执行并显示结果，然后打印另一个 **mysql>** 提示符，表示它已准备好进行另一个查询。

- **mysql** 以表格形式（行和列）显示查询输出。第一行包含列的标签。后面的行是查询结果。通常，列标签是您从数据库表中获取的列的名称。如果您要检索表达式的值而不是表列（如刚才的示例所示），**mysql** 会使用表达式本身标记该列。
- **mysql** 显示返回了多少行以及查询执行了多长时间，这使您可以粗略了解服务器性能。这些值并不精确，因为它们表示的是挂钟时间（而不是 CPU 或机器时间），并且它们会受到服务器负载和网络延迟等因素的影响。



#### 大小写不敏感

关键字可以用任何大小写输入。以下查询是等效的

```
mysql> SELECT VERSION(), CURRENT_DATE;
mysql> select version(), current_date;
mysql> SeLeCt vErSiOn(), current_DATE;
```



目前为止显示的查询都是相对较短的单行语句。您甚至可以在一行中输入多个语句。只需在每个语句后面加上一个分号

```
mysql> SELECT VERSION(); SELECT NOW();
+-----------+
| VERSION() |
+-----------+
| 8.4.0-tr  |
+-----------+
1 row in set (0.00 sec)

+---------------------+
| NOW()               |
+---------------------+
| 2024-01-25 18:33:04 |
+---------------------+
1 row in set (0.00 sec)
```



查询不必全部在一行中给出，因此需要多行的冗长查询也不是问题。

**mysql** 通过查找终止分号来确定语句的结束位置，而不是通过查找输入行的结尾。

以下是一个简单的多行语句：

```
mysql> SELECT
    -> USER()
    -> ,
    -> CURRENT_DATE;
+---------------+--------------+
| USER()        | CURRENT_DATE |
+---------------+--------------+
| jon@localhost | 2018-08-24   |
+---------------+--------------+
```



#### 多行语句

在此示例中，请注意在您输入多行查询的第一行后，提示符如何从 `mysql>` 更改为 `->`。

这就是 **mysql** 指示它尚未看到完整语句并正在等待其余部分的方式。

提示符提供了有价值的反馈。如果您使用该反馈，您始终可以知道 mysql 正在等待什么。

```
mysql> SELECT
    -> USER()
    -> \c
mysql>
```

在这里，还要注意提示符。在您键入 \c 后，它会切换回 mysql>，提供反馈以指示 **mysql** 已准备好进行新的查询。



#### 多行提示符

下表显示了您可能会看到的每个提示符，并总结了它们对 **mysql** 所处状态的含义。

| 提示符   | 含义                                            |
| -------- | ----------------------------------------------- |
| `mysql>` | 准备好进行新的查询                              |
| `->`     | 等待多行查询的下一行                            |
| `'>`     | 等待下一行，等待以单引号 (`'`) 开头的字符串完成 |
| `">`     | 等待下一行，等待以双引号 (`"`) 开头的字符串完成 |
| ``>`     | 等待下一行，等待以反引号 (```) 开头的标识符完成 |
| `/*>`    | 等待下一行，等待以 `/*` 开头的注释完成          |



#### `->` 提示符

当您打算在一行中发出查询但忘记了终止分号时，通常会意外出现多行语句。在这种情况下，**mysql** 会等待更多输入

```
mysql> SELECT USER()
    ->
```



如果这种情况发生在您身上（您认为您已经输入了一个语句，但唯一的响应是 -> 提示符），很可能是 **mysql** 正在等待分号。

如果您没有注意到提示符告诉您什么，您可能会在那里坐一会儿，然后才意识到您需要做什么。输入一个分号来完成语句，然后 **mysql** 将执行它：

```
mysql> SELECT USER()
    -> ;
+---------------+
| USER()        |
+---------------+
| jon@localhost |
+---------------+
```



#### `'>` 提示符

`'>` 和 `">` 提示符出现在字符串收集期间（另一种说法是 MySQL 正在等待字符串完成）。在 MySQL 中，您可以编写用 `'` 或 `"` 字符包围的字符串（例如，`'hello'` 或 `"goodbye"`）。

**mysql 允许您输入跨越多行的字符串**。当您看到 '> 或 "> 提示符时，表示您输入了一行包含以 ' 或 " 引号字符开头的字符串，但尚未输入终止该字符串的匹配引号。这通常表示您**无意中遗漏了一个引号字符**。例如

```
mysql> SELECT * FROM my_table WHERE name = 'Smith AND age < 30;
    '>
```



如果您输入此 **SELECT** 语句，然后按 Enter 键并等待结果，则什么也不会发生。与其想知道为什么此查询需要这么长时间，不如注意 '> 提示符提供的线索。

它告诉您 **mysql** 期望看到**未终止字符串的其余部分**。（您在语句中看到错误了吗？字符串 'Smith 缺少第二个单引号。）

发生这种情况，最简单的方法是取消查询。但是，在这种情况下，您不能只键入 `\c`，因为 mysql 会将其解释为正在收集的字符串的一部分。

应该输入结束引号字符（以便 **mysql** 知道您已经完成了字符串），然后键入 `\c`

```
mysql> SELECT * FROM my_table WHERE name = 'Smith AND age < 30;
    '> '\c
mysql>
```

提示符将更改回 mysql>，表示 **mysql** 已准备好进行新的查询。



``>` 提示符与 `'>` 和 `">` 提示符类似，但表示您已开始但尚未完成反引号括起来的标识符。

了解 `'>`、`">` 和 ``>` 提示符的含义非常重要，因为如果您错误地输入了未终止的字符串，您键入的任何后续行似乎都会被 **mysql** 忽略，包括包含 `QUIT` 的行。这可能会造成很大困扰，尤其是在您不知道需要先提供终止引号才能取消当前查询的情况下。



### 数据库

#### 查询和切换

**查询数据库列表**

使用 **SHOW** 语句找出当前服务器上存在哪些数据库

```
mysql> SHOW DATABASES;
+----------+
| Database |
+----------+
| mysql    |
| test     |
| tmp      |
+----------+
```

`mysql` 数据库描述用户访问权限。 `test` 数据库通常可用作用户试用事物的空间。

语句显示的数据库列表可能在你的机器上有所不同；如果你没有 SHOW DATABASES 权限，则 SHOW DATABASES 不会显示你没有权限访问的数据库。



**切换数据库**

使用 USE 语句可以切换数据库，尝试切换到 `test` 数据库

```
mysql> USE test
Database changed
```

`USE`，就像 `QUIT` 一样，不需要分号。（如果你愿意，可以使用分号来终止这些语句；不会造成任何危害。）`USE` 语句必须放在单行中。



你可以使用 `test` 数据库（如果你有权访问它）来进行以下示例，但任何你在该数据库中创建的内容都可以被任何其他有权访问该数据库的人删除。因此，你最好向 MySQL 管理员请求使用你自己的数据库的权限。假设你想把数据库命名为 `menagerie`。管理员需要执行类似于以下的语句

```
mysql> GRANT ALL ON menagerie.* TO 'your_mysql_name'@'your_client_host';
```

其中 `your_mysql_name` 是分配给你的 MySQL 用户名，`your_client_host` 是你连接到服务器的主机。



#### 创建数据库

创建数据库并命名为 menagerie

```
mysql> CREATE DATABASE menagerie;
```



在 Unix 下，数据库名称区分大小写（与 SQL 关键字不同），因此您必须始终将数据库称为 `menagerie`，而不是 `Menagerie`、`MENAGERIE` 或其他变体。表名也是如此。

在 Windows 下，此限制不适用，但您必须在给定查询中使用相同的字母大小写来引用数据库和表。但是，出于各种原因，建议的最佳做法始终是使用与创建数据库时相同的字母大小写。



创建数据库不会自动切换过去；您必须明确执行此操作。

```
mysql> USE menagerie
Database changed
```



您的数据库只需要创建一次，但每次开始 mysq 会话时都必须手动切换过去。

您可以在调用 mysql 时在命令行上选择数据库。只需在您可能需要提供的任何连接参数之后指定其名称即可。例如

```
$> mysql -h host -u user -p menagerie
Enter password: ********
```



#### 查看当前数据库

您可以随时使用 `SELECT DATABASE()` 查看当前选择了哪个数据库。

```
mysql> SELECT DATABASE();
+------------+
| DATABASE() 
+------------+
| mysql      |
+------------+
```



#### 创建表

在设计一个宠物数据库表时，核心思想是存储稳定、基础的信息而非动态变化的数据。这个名为 `pet` 的表应包含宠物的 `name`（名称）、`owner`（主人）、`species`（物种）和 `sex`（性别）。关键在于，不应直接存储 `age`（年龄），因为它会随时间变化而需要频繁更新。更优的方案是存储固定的 `birth`（出生日期），然后通过数据库的日期计算功能随时得出当前年龄。这种方法不仅简化了维护，还能轻松实现更多功能，例如，结合当前日期生成生日提醒，或是在有 `death`（死亡日期）记录的情况下计算宠物离世时的年龄。



使用 `CREATE TABLE` 语句来创建表。

```mysql
mysql> CREATE TABLE pet (name VARCHAR(20), owner VARCHAR(20),
       species VARCHAR(20), sex CHAR(1), birth DATE, death DATE);
```



VARCHAR 是 name、owner 和 species 列的良好选择，因为列值长度不同。这些列定义中的长度不必全部相同，也不必是 20。通常，您可以从 1 到 65535 中选择任何长度。如果您做出了错误的选择，并且后来发现您需要更长的字段，可以使用 `ALTER TABLE` 语句。

可以选择几种类型的值来表示动物记录中的性别，例如 `'m'` 和 `'f'`，或者可能是 `'male'` 和 `'female'`。使用单个字符 `'m'` 和 `'f'` 最简单。

使用 `DATE` 数据类型表示 **birth** 和 **death** 列是一个相当明显的选择。



####  查看表

创建表后，SHOW TABLES 应该产生一些输出

```
mysql> SHOW TABLES;
+---------------------+
| Tables in menagerie |
+---------------------+
| pet                 |
+---------------------+
```



#### 查看表结构

若要验证您的表是否按预期方式创建，请使用 DESCRIBE 语句

```
mysql> DESCRIBE pet;
+---------+-------------+------+-----+---------+-------+
| Field   | Type        | Null | Key | Default | Extra |
+---------+-------------+------+-----+---------+-------+
| name    | varchar(20) | YES  |     | NULL    |       |
| owner   | varchar(20) | YES  |     | NULL    |       |
| species | varchar(20) | YES  |     | NULL    |       |
| sex     | char(1)     | YES  |     | NULL    |       |
| birth   | date        | YES  |     | NULL    |       |
| death   | date        | YES  |     | NULL    |       |
+---------+-------------+------+-----+---------+-------+
```



#### 将数据加载到表中

创建表后，您需要填充它。可以使用 `LOAD DATA` 和 `INSERT` 语句。

假设您的宠物记录可以描述如下。

| 姓名     | 主人   | 物种 | 性别 | 出生日期   | 死亡日期   |
| -------- | ------ | ---- | ---- | ---------- | ---------- |
| Fluffy   | Harold | 猫   | 雌性 | 1993-02-04 |            |
| Claws    | Gwen   | 猫   | 雄性 | 1994-03-17 |            |
| Buffy    | Harold | 狗   | 雌性 | 1989-05-13 |            |
| Fang     | Benny  | 狗   | 雄性 | 1990-08-27 |            |
| Bowser   | Diane  | 狗   | 雄性 | 1979-08-31 | 1995-07-29 |
| Chirpy   | Gwen   | 鸟   | 雌性 | 1998-09-11 |            |
| Whistler | Gwen   | 鸟   |      | 1997-12-09 |            |
| Slim     | Benny  | 蛇   | 雄性 | 1996-04-29 |            |



因为您是从一个空表开始，所以填充它的一个简单方法是创建一个文本文件，其中包含每只动物的一行记录，然后使用一条语句将文件的内容加载到表中。

您可以创建一个文本文件 `pet.txt`，其中每行包含一条记录，值之间用制表符分隔，并按照 `CREATE TABLE`语句中列出的顺序给出。对于缺失值（例如未知性别或仍然存活的动物的死亡日期），您可以使用 `NULL` 值。要在文本文件中表示 NULL，请使用 `\N`（反斜杠，大写 N）。

例如，Whistler 这只鸟的记录如下所示（其中值之间的空白是一个制表符）

```
Whistler        Gwen    bird    \N      1997-12-09      \N
```



要将文本文件 `pet.txt` 加载到 `pet` 表中，请使用以下语句

```
mysql> LOAD DATA LOCAL INFILE '/path/pet.txt' INTO TABLE pet;
```



如果您在 Windows 上使用以 `\r\n` 作为行终止符的编辑器创建了该文件，则应改用以下语句

```
mysql> LOAD DATA LOCAL INFILE '/path/pet.txt' INTO TABLE pet
       LINES TERMINATED BY '\r\n';
```

（在运行 macOS 的 Apple 机器上，您可能希望使用 `LINES TERMINATED BY '\r'`。）

如果您愿意，可以在 `LOAD DATA` 语句中明确指定列值分隔符和行尾标记，但默认值为制表符和换行符。这些足以使语句正确读取文件 pet.txt。

如果语句失败，则可能是您的 MySQL 安装默认情况下未启用本地文件功能。



当您想一次添加一条新记录时，`INSERT` 语句很有用。在最简单的形式中，您需要为每个列提供值，顺序与 `CREATE TABLE` 语句中列出的顺序相同。

假设 Diane 得到了一只名为 “Puffball” 的新仓鼠。您可以使用如下所示的 `INSERT` 语句添加新记录

```
mysql> INSERT INTO pet
       VALUES ('Puffball','Diane','hamster','f','1999-03-30',NULL);
```

字符串和日期值在此处指定为带引号的字符串。此外，使用 `INSERT`，您可以直接插入 **NULL** 来表示缺失值。您不需要像使用 `LOAD DATA` 那样使用 \N。



#### 从表中检索信息

`SELECT` 语句用于从表中提取信息。该语句的一般形式为

```
SELECT what_to_select
FROM which_table
WHERE conditions_to_satisfy;
```

*`what_to_select`* 指示您要查看的内容。这可以是列列表，也可以是 `*`，表示“所有列”。*`which_table`* 指示您要从中检索数据的表。`WHERE` 子句是可选的。如果存在，*`conditions_to_satisfy`* 指定行必须满足的一个或多个条件才能被检索。



#### 检索所有数据

最简单的形式 SELECT 从表中检索所有内容：

```
mysql> SELECT * FROM pet;
+----------+--------+---------+------+------------+------------+
| name     | owner  | species | sex  | birth      | death      |
+----------+--------+---------+------+------------+------------+
| Fluffy   | Harold | cat     | f    | 1993-02-04 | NULL       |
| Claws    | Gwen   | cat     | m    | 1994-03-17 | NULL       |
| Buffy    | Harold | dog     | f    | 1989-05-13 | NULL       |
| Fang     | Benny  | dog     | m    | 1990-08-27 | NULL       |
| Bowser   | Diane  | dog     | m    | 1979-08-31 | 1995-07-29 |
| Chirpy   | Gwen   | bird    | f    | 1998-09-11 | NULL       |
| Whistler | Gwen   | bird    | NULL | 1997-12-09 | NULL       |
| Slim     | Benny  | snake   | m    | 1996-04-29 | NULL       |
| Puffball | Diane  | hamster | f    | 1999-03-30 | NULL       |
+----------+--------+---------+------+------------+------------+
```

这种形式的 **SELECT** 使用 `*`，它是 “选择所有列” 的简写。如果您想查看整个表，例如，在您刚用初始数据集加载完表后，这将很有用。

**`SELECT *` 选择所有列的原则有一个例外。如果表包含不可见的列，`*` 不包含它们。**



假设，您可能会认为 Bowser 的出生日期似乎不太正确。查阅您的原始家谱文件后，您发现正确的出生年份应该是 1989 年，而不是 1979 年。

编辑文件 pet.txt 以更正错误，然后使用 `DELETE` 和 `LOAD DATA` 清空表并重新加载它：

```
mysql> DELETE FROM pet;
mysql> LOAD DATA LOCAL INFILE 'pet.txt' INTO TABLE pet;
```



仅使用 `UPDATE` 语句更正错误的记录

```
mysql> UPDATE pet SET birth = '1989-08-31' WHERE name = 'Bowser';
```

该 `UPDATE` 仅更改相关记录，而不必重新加载表。



#### 检索特定行

您可以只从表中选择特定的行。例如，如果您想验证您对 Bowser 出生日期所做的更改，请像这样选择 Bowser 的记录：

```
mysql> SELECT * FROM pet WHERE name = 'Bowser';
+--------+-------+---------+------+------------+------------+
| name   | owner | species | sex  | birth      | death      |
+--------+-------+---------+------+------------+------------+
| Bowser | Diane | dog     | m    | 1989-08-31 | 1995-07-29 |
+--------+-------+---------+------+------------+------------+
```

输出确认年份正确记录为 1989 年，而不是 1979 年。

字符串比较通常不区分大小写，因此您可以将名称指定为 `'bowser'`、`'BOWSER'` 等。查询结果是相同的。



您可以在任何列上指定条件，而不仅仅是 `name` 列。

例如，如果您想知道哪些动物出生于 1998 年或之后，请测试 `birth` 列

```
mysql> SELECT * FROM pet WHERE birth >= '1998-1-1';
+----------+-------+---------+------+------------+-------+
| name     | owner | species | sex  | birth      | death |
+----------+-------+---------+------+------------+-------+
| Chirpy   | Gwen  | bird    | f    | 1998-09-11 | NULL  |
| Puffball | Diane | hamster | f    | 1999-03-30 | NULL  |
+----------+-------+---------+------+------------+-------+
```



您可以组合条件，例如，找到雌性犬

```
mysql> SELECT * FROM pet WHERE species = 'dog' AND sex = 'f';
+-------+--------+---------+------+------------+-------+
| name  | owner  | species | sex  | birth      | death |
+-------+--------+---------+------+------------+-------+
| Buffy | Harold | dog     | f    | 1989-05-13 | NULL  |
+-------+--------+---------+------+------------+-------+
```



前面的查询使用了 `AND` 逻辑运算符。还有一个 `OR` 运算符

```
mysql> SELECT * FROM pet WHERE species = 'snake' OR species = 'bird';
+----------+-------+---------+------+------------+-------+
| name     | owner | species | sex  | birth      | death |
+----------+-------+---------+------+------------+-------+
| Chirpy   | Gwen  | bird    | f    | 1998-09-11 | NULL  |
| Whistler | Gwen  | bird    | NULL | 1997-12-09 | NULL  |
| Slim     | Benny | snake   | m    | 1996-04-29 | NULL  |
+----------+-------+---------+------+------------+-------+
```



`AND` 和 `OR` 可以混合使用，尽管 `AND` 的优先级高于 `OR`。

如果同时使用这两个运算符，最好使用括号明确指示条件应该如何分组

```
mysql> SELECT * FROM pet WHERE (species = 'cat' AND sex = 'm')
    -> OR (species = 'dog' AND sex = 'f');
+-------+--------+---------+------+------------+-------+
| name  | owner  | species | sex  | birth      | death |
+-------+--------+---------+------+------------+-------+
| Claws | Gwen   | cat     | m    | 1994-03-17 | NULL  |
| Buffy | Harold | dog     | f    | 1989-05-13 | NULL  |
+-------+--------+---------+------+------------+-------+
```



#### 检索特定列

如果您不想查看来自表的整行，只需列出您感兴趣的列，用逗号分隔。

例如，如果您想知道您的动物何时出生，请选择 `name` 和 `birth` 列

```
mysql> SELECT name, birth FROM pet;
+----------+------------+
| name     | birth      |
+----------+------------+
| Fluffy   | 1993-02-04 |
| Claws    | 1994-03-17 |
| Buffy    | 1989-05-13 |
| Fang     | 1990-08-27 |
| Bowser   | 1989-08-31 |
| Chirpy   | 1998-09-11 |
| Whistler | 1997-12-09 |
| Slim     | 1996-04-29 |
| Puffball | 1999-03-30 |
+----------+------------+
```



要找出谁拥有宠物，请使用此查询

```
mysql> SELECT owner FROM pet;
+--------+
| owner  |
+--------+
| Harold |
| Gwen   |
| Harold |
| Benny  |
| Diane  |
| Gwen   |
| Gwen   |
| Benny  |
| Diane  |
+--------+
```



请注意，该查询只是从每条记录中检索 `owner` 列，其中一些列出现不止一次。

为了最小化输出，通过添加关键字 `DISTINCT` 仅检索每个唯一的输出记录一次

```
mysql> SELECT DISTINCT owner FROM pet;
+--------+
| owner  |
+--------+
| Benny  |
| Diane  |
| Gwen   |
| Harold |
+--------+
```



您可以使用 `WHERE` 子句将行选择与列选择结合起来。

例如，要获取仅限于狗和猫的出生日期，请使用此查询

```
mysql> SELECT name, species, birth FROM pet
    -> WHERE species = 'dog' OR species = 'cat';
+--------+---------+------------+
| name   | species | birth      |
+--------+---------+------------+
| Fluffy | cat     | 1993-02-04 |
| Claws  | cat     | 1994-03-17 |
| Buffy  | dog     | 1989-05-13 |
| Fang   | dog     | 1990-08-27 |
| Bowser | dog     | 1989-08-31 |
+--------+---------+------------+
```



#### 对行排序

`ORDER BY` 子句用于让行按某种有意义的方式排序。

以下是按日期排序的动物生日

```mysql
mysql> SELECT name, birth FROM pet ORDER BY birth;
+----------+------------+
| name     | birth      |
+----------+------------+
| Buffy    | 1989-05-13 |
| Bowser   | 1989-08-31 |
| Fang     | 1990-08-27 |
| Fluffy   | 1993-02-04 |
| Claws    | 1994-03-17 |
| Slim     | 1996-04-29 |
| Whistler | 1997-12-09 |
| Chirpy   | 1998-09-11 |
| Puffball | 1999-03-30 |
+----------+------------+
```

在字符类型列上，排序（像所有其他比较操作一样）通常以不区分大小写的方式执行。

这意味着对于除大小写外完全相同的列，顺序是不定义的。您可以通过像这样使用 `BINARY` 来强制对列进行区分大小写的排序：`ORDER BY BINARY col_name`。



默认排序顺序是升序，最小的值排在最前面。要在相反（降序）顺序中排序，请将 `DESC` 关键字添加到要排序的列的名称中：

```sql
mysql> SELECT name, birth FROM pet ORDER BY birth DESC;
+----------+------------+
| name     | birth      |
+----------+------------+
| Puffball | 1999-03-30 |
| Chirpy   | 1998-09-11 |
| Whistler | 1997-12-09 |
| Slim     | 1996-04-29 |
| Claws    | 1994-03-17 |
| Fluffy   | 1993-02-04 |
| Fang     | 1990-08-27 |
| Bowser   | 1989-08-31 |
| Buffy    | 1989-05-13 |
+----------+------------+
```



#### 日期计算

MySQL 提供了多个函数，您可以使用这些函数对日期执行计算，例如，计算年龄或提取日期的各个部分。

要确定您的每只宠物的年龄，请使用 `TIMESTAMPDIFF()` 函数。它的参数是您希望结果以其表达的单位以及要计算差值的两个日期。以下查询显示了每个宠物的出生日期、当前日期和年龄（以年为单位）。使用了 *别名* (`age`) 使最终输出列标签更有意义。

```
mysql> SELECT name, birth, CURDATE(),
       TIMESTAMPDIFF(YEAR,birth,CURDATE()) AS age
       FROM pet;
+----------+------------+------------+------+
| name     | birth      | CURDATE()  | age  |
+----------+------------+------------+------+
| Fluffy   | 1993-02-04 | 2003-08-19 |   10 |
| Claws    | 1994-03-17 | 2003-08-19 |    9 |
| Buffy    | 1989-05-13 | 2003-08-19 |   14 |
| Fang     | 1990-08-27 | 2003-08-19 |   12 |
| Bowser   | 1989-08-31 | 2003-08-19 |   13 |
| Chirpy   | 1998-09-11 | 2003-08-19 |    4 |
| Whistler | 1997-12-09 | 2003-08-19 |    5 |
| Slim     | 1996-04-29 | 2003-08-19 |    7 |
| Puffball | 1999-03-30 | 2003-08-19 |    4 |
+----------+------------+------------+------+
```



此查询可以正常工作，但如果以某种顺序显示行，则结果将更容易理解。

要按 `age` 排序输出。

```sql
mysql> SELECT name, birth, CURDATE(),
       TIMESTAMPDIFF(YEAR,birth,CURDATE()) AS age
       FROM pet ORDER BY age;
+----------+------------+------------+------+
| name     | birth      | CURDATE()  | age  |
+----------+------------+------------+------+
| Chirpy   | 1998-09-11 | 2003-08-19 |    4 |
| Puffball | 1999-03-30 | 2003-08-19 |    4 |
| Whistler | 1997-12-09 | 2003-08-19 |    5 |
| Slim     | 1996-04-29 | 2003-08-19 |    7 |
| Claws    | 1994-03-17 | 2003-08-19 |    9 |
| Fluffy   | 1993-02-04 | 2003-08-19 |   10 |
| Fang     | 1990-08-27 | 2003-08-19 |   12 |
| Bowser   | 1989-08-31 | 2003-08-19 |   13 |
| Buffy    | 1989-05-13 | 2003-08-19 |   14 |
+----------+------------+------------+------+
```



类似的查询可用于确定已死亡动物的死亡年龄。

您可以通过检查 `death` 值是否为 `NULL` 来确定哪些动物已死亡。然后，对于那些具有非 `NULL` 值的动物，计算 `death` 和 `birth` 值之间的差值。

```sql
mysql> SELECT name, birth, death,
       TIMESTAMPDIFF(YEAR,birth,death) AS age
       FROM pet WHERE death IS NOT NULL ORDER BY age;
+--------+------------+------------+------+
| name   | birth      | death      | age  |
+--------+------------+------------+------+
| Bowser | 1989-08-31 | 1995-07-29 |    5 |
+--------+------------+------------+------+
```

此查询使用 `death IS NOT NULL` 而不是 `death <> NULL`，因为 `NULL` 是一个特殊值，不能使用常规比较运算符进行比较。



计算哪些动物将在下个月过生日。对于这种类型的计算，年和日无关紧要；您只需要提取 `birth` 列的月份部分。

MySQL 提供了多个函数用于提取日期的各个部分，例如 `YEAR()`、`MONTH()` 和 `DAYOFMONTH()`。在这里，`MONTH()` 是合适的函数。

```sql
mysql> SELECT name, birth, MONTH(birth) FROM pet;
+----------+------------+--------------+
| name     | birth      | MONTH(birth) |
+----------+------------+--------------+
| Fluffy   | 1993-02-04 |            2 |
| Claws    | 1994-03-17 |            3 |
| Buffy    | 1989-05-13 |            5 |
| Fang     | 1990-08-27 |            8 |
| Bowser   | 1989-08-31 |            8 |
| Chirpy   | 1998-09-11 |            9 |
| Whistler | 1997-12-09 |           12 |
| Slim     | 1996-04-29 |            4 |
| Puffball | 1999-03-30 |            3 |
+----------+------------+--------------+
```



查找在下个月过生日的动物也很简单。假设当前月份为 4 月。然后月份值为 `4`，您可以查找出生于 5 月（月份 `5`）的动物，如下所示。

```sql
mysql> SELECT name, birth FROM pet WHERE MONTH(birth) = 5;
+-------+------------+
| name  | birth      |
+-------+------------+
| Buffy | 1989-05-13 |
+-------+------------+
```



如果当前月份为 12 月，则会出现一个小问题。您不能简单地将月份数 (`12`) 加 1，然后查找出生于月份 `13` 的动物，因为不存在这样的月份。相反，您需要查找出生于 1 月（月份 `1`）的动物。

您可以编写查询，使其无论当前月份是什么都能正常工作，因此您不必使用特定月份的数字。 `DATE_ADD()` 使您能够将时间间隔添加到给定日期。如果您将一个月添加到 `CURDATE()` 的值中，然后使用 `MONTH()` 提取月份部分，结果将生成要查找生日的月份。

```sql
mysql> SELECT name, birth FROM pet
       WHERE MONTH(birth) = MONTH(DATE_ADD(CURDATE(),INTERVAL 1 MONTH));
```



完成相同任务的另一种方法是在使用模运算符 (`MOD`) 将月份值包装到 `0`（如果当前为 `12`）后，加 1 以获得当前月份后的下一个月份。

```sql
mysql> SELECT name, birth FROM pet
       WHERE MONTH(birth) = MOD(MONTH(CURDATE()), 12) + 1;
```



 `MONTH()` 返回 1 到 12 之间的数字。而 `MOD(something,12)` 返回 0 到 11 之间的数字。因此，加法必须在 `MOD()` 之后，否则我们将从 11 月 (11) 变为 1 月 (1)。

如果计算使用无效日期，则计算将失败并产生警告。

```sql
mysql> SELECT '2018-10-31' + INTERVAL 1 DAY;
+-------------------------------+
| '2018-10-31' + INTERVAL 1 DAY |
+-------------------------------+
| 2018-11-01                    |
+-------------------------------+

mysql> SELECT '2018-10-32' + INTERVAL 1 DAY;
+-------------------------------+
| '2018-10-32' + INTERVAL 1 DAY |
+-------------------------------+
| NULL                          |
+-------------------------------+

mysql> SHOW WARNINGS
+---------+------+----------------------------------------+
| Level   | Code | Message                                |
+---------+------+----------------------------------------+
| Warning | 1292 | Incorrect datetime value: '2018-10-32' |
+---------+------+----------------------------------------+
```



#### 处理 NULL 值

从概念上讲，`NULL` 表示 “缺少的未知值”，并且它的处理方式与其他值略有不同。

要测试 `NULL`，请使用 `IS NULL` 和 `IS NOT NULL` 运算符，如下所示：

```
mysql> SELECT 1 IS NULL, 1 IS NOT NULL;
+-----------+---------------+
| 1 IS NULL | 1 IS NOT NULL |
+-----------+---------------+
|         0 |             1 |
+-----------+---------------+
```



与 NULL 进行算术比较的结果均为 NULL，不要使用 `=`、`<` 或 `<>` 等算术比较运算符来测试 NULL 值。

```
mysql> SELECT 1 = NULL, 1 <> NULL, 1 < NULL, 1 > NULL;
+----------+-----------+----------+----------+
| 1 = NULL | 1 <> NULL | 1 < NULL | 1 > NULL |
+----------+-----------+----------+----------+
|     NULL |      NULL |     NULL |     NULL |
+----------+-----------+----------+----------+
```



在 MySQL 中，`0` 或 `NULL` 表示 false，而其他任何值都表示 true。布尔运算的默认真值为 `1`。

`NULL` 的这种特殊处理方式解释了为什么在上一节中，需要使用 `death IS NOT NULL` 而不是 `death <> NULL` 来确定哪些动物不再存活。

在 `GROUP BY` 中，两个 `NULL` 值被视为相等。

执行 `ORDER BY` 时，如果执行 `ORDER BY ... ASC`，则 `NULL` 值将首先显示；如果执行 `ORDER BY ... DESC`，则 `NULL` 值将最后显示。



使用 **NULL** 时，一个常见的错误是**误认为空值或空字符串 ('') 与 NULL 相同**。然而事实并非如此。**NULL** 在 SQL 中表示**“没有值”或“缺少值”**，而空字符串 ('') 是一个**实际的值**。

您可以使用 **IS NULL** 或 **IS NOT NULL** 轻松地区分它们，如下所示：

```sql
mysql> SELECT 0 IS NULL, 0 IS NOT NULL, '' IS NULL, '' IS NOT NULL;
+-------------+---------------+------------+----------------+
| 0 IS NULL   | 0 IS NOT NULL | '' IS NULL | '' IS NOT NULL |
+-------------+---------------+------------+----------------+
|           0 |             1 |          0 |              1 |
+-------------+---------------+------------+----------------+
```

**空值（NULL）或空字符串（''）都可以插入到被定义为 NOT NULL 的列中。**



