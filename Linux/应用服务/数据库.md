# MySQL

## 概念

**什么是 SQL**

**结构化查询语言（Structured Query Language, SQL）** 是一种为**管理关系型数据库**管理系统（RDBMS）中的数据而设计的、具备高度标准化的领域特定语言（Domain-Specific Language, DSL）。

SQL的根本目的在于提供一个统一的、声明式（Declarative）的接口，用以执行数据查询、数据操纵、数据定义以及数据访问控制。



**SQL 标准**

SQL由美国国家标准协会（ANSI）和国际标准化组织（ISO）进行标准化，其正式标准为 ISO/IEC 9075。这个标准定义了语言的语法、数据类型和核心功能集，旨在确保不同数据库系统之间的可移植性和互操作性。



**SQL 与 RDBMS 的关系**

SQL本身只是一套语言规范，它需要一个强大的软件系统来解释、执行并管理底层数据。这个软件系统就是关系型数据库管理系统（Relational Database Management System, RDBMS）。

RDBMS是用于创建、更新和管理关系型数据库的应用程序 。它是一个复杂的软件集合，提供了数据存储、检索、安全、备份、恢复和性能优化等一系列功能。市面上知名的RDBMS产品包括MySQL、PostgreSQL、Oracle Database、Microsoft SQL Server等 。  

- **核心是关系模型**：RDBMS的核心是严格遵循埃德加·科德定义的关系模型。数据被逻辑地组织在二维表中，表由行和列构成。这种直观的结构使得用户可以轻松地理解和操作数据 。  
- **关系的建立**：“关系型”的精髓在于表与表之间可以建立关联。这是通过主键（Primary Key）和外键（Foreign Key）实现的。主键是表中唯一标识一行的列（或列的组合），而外键是A表中的一个列，其值引用了B表的主键。通过这种机制，RDBMS可以在不同数据实体之间建立清晰、可靠的关联 。  
- **逻辑与物理分离**：RDBMS的一个关键设计原则是逻辑数据结构与物理存储结构的分离。用户和应用程序操作的是逻辑层面的表和视图，而数据库管理员可以在不影响上层应用的情况下，调整底层的物理存储，如重命名数据文件、将数据迁移到不同的磁盘等。



**SQL 方言**

尽管存在统一的ANSI/ISO标准，但在实际应用中，几乎每个RDBMS都有自己独特的SQL语法变体，这些变体被称为“SQL方言”（SQL Dialects）。SQL方言的存在是SQL生态系统成熟和商业化的自然产物，是理论的纯洁性与市场现实性之间博弈的结果。



SQL方言的差异体现在多个层面，从基本的数据类型定义到复杂的查询语法，几乎无处不在。以下是一些最常见的差异领域：

- 自增列定义：MySQL使用`AUTO_INCREMENT`，PostgreSQL使用`SERIAL`或`GENERATED AS IDENTITY`。
- 字符串拼接：SQL Server使用`+`运算符，而PostgreSQL使用`||`运算符。
- 限制查询结果：SQL Server使用`TOP N`，MySQL和PostgreSQL使用`LIMIT N`。



## SQL命令的五大分类

结构化查询语言 (SQL) 是用于管理和操作关系型数据库的标准语言。为了更好地组织和理解其功能，SQL 命令被划分为五个主要的类别。理解这些分类有助于掌握在数据库上执行不同类型操作的正确命令。

这五大分类分别是：

1. **数据定义语言 (DDL - Data Definition Language)**
2. **数据操纵语言 (DML - Data Manipulation Language)**
3. **数据查询语言 (DQL - Data Query Language)**
4. **数据控制语言 (DCL - Data Control Language)**
5. **事务控制语言 (TCL - Transaction Control Language)**



1. 数据定义语言 (DDL)

DDL 用于**定义和管理数据库的结构**。这些命令负责创建、修改和删除数据库对象，如表、索引、视图等。DDL 操作是自动提交的，意味着一旦执行，就无法回滚。

**核心命令包括：**

- `CREATE`：用于创建新的数据库对象。
- `ALTER`：用于修改现有数据库对象的结构。
- `DROP`：用于完全删除一个现有的数据库对象。
- `TRUNCATE`：用于快速删除表中的所有行，但保留表结构。此操作比 `DELETE` 更快，且通常无法回滚。
- `RENAME`：用于重命名一个数据库对象。



2. 数据操纵语言 (DML)

DML 用于**管理数据库中的数据**，包括插入、更新和删除记录。这些是数据库日常使用中最频繁的操作。DML 操作可以被 TCL 命令（如 `COMMIT` 或 `ROLLBACK`）管理。

**核心命令包括：**

- `INSERT`：向表中添加新的数据行。
- `UPDATE`：修改表中的现有数据。
- `DELETE`：从表中删除一条或多条数据行。



3. 数据查询语言 (DQL)

DQL 可能是最常用的 SQL 命令，专门用于**从数据库中检索数据**。它最核心也是唯一的命令就是 `SELECT`。

**核心命令包括：**

- `SELECT`：用于从一个或多个表中查询数据。它可以与各种子句（如 `FROM`, `WHERE`, `GROUP BY`, `ORDER BY`, `HAVING`）结合使用以实现复杂的查询。



4. 数据控制语言 (DCL)

DCL 用于**管理数据库的访问权限**。它控制哪个用户可以执行哪些 SQL 命令。这对于数据库的安全性至关重要。

**核心命令包括：**

- `GRANT`：授予用户对数据库对象的特定权限（如 `SELECT`, `INSERT`, `UPDATE` 等）。
- `REVOKE`：撤销之前授予用户的权限。



5. 事务控制语言 (TCL)

TCL 用于**管理事务**，确保数据库操作的原子性、一致性、隔离性和持久性（ACID 属性）。事务是一组作为一个逻辑单元执行的 SQL 语句，要么全部成功，要么全部失败。

**核心命令包括：**

- `COMMIT`：永久保存事务中所做的所有更改。
- `ROLLBACK`：撤销当前事务中所做的所有未提交的更改，将数据恢复到上一次 `COMMIT` 时的状态。
- `SAVEPOINT`：在当前事务中设置一个保存点。这允许你之后可以回滚到这个特定的点，而不是整个事务。



## 数据查询语言 SELECT

`SELECT` 语句是 SQL 中最核心、最复杂的语句，其唯一目的是从数据库表中检索数据。它允许用户精确地指定需要哪些列、来自哪些表、满足什么条件，并可以对结果进行聚合、排序和格式化。

一个完整且结构复杂的 `SELECT` 语句遵循严格的书写顺序。虽然在实际应用中很少有查询会同时使用所有子句，但了解它们的完整顺序和功能对于编写高级查询至关重要。



**`SELECT` 语句的结构与书写顺序**

以下是 `SELECT` 语句所有主要子句的 **标准书写顺序**。您在编写查询时必须遵循这个次序。

```
SELECT [DISTINCT | ALL] select_list
FROM table_source
[JOIN join_type join_table ON join_condition]
[WHERE search_condition]
[GROUP BY group_by_expression]
[HAVING search_condition]
[WINDOW window_name AS (window_definition)]
[ORDER BY order_by_expression [ASC | DESC]]
[OFFSET offset_count ROW | ROWS]
[FETCH FIRST | NEXT row_count ROW | ROWS ONLY]
```

**注意**： 不同的数据库实现（如 MySQL, PostgreSQL）可能使用 `LIMIT` 和 `OFFSET` 的简化语法，但 `OFFSET ... FETCH ...` 是 ANSI SQL:2008 标准引入的官方语法。



### SELECT 子句

`SELECT` 子句是数据查询语言（DQL）中 `SELECT` 语句的第一个也是必需的组成部分。其核心功能是**投影（Projection）**，即定义查询结果集（Result Set）应包含哪些列。它指定了最终返回的每一行数据所应具备的结构和值。



`SELECT` 子句的基本语法结构如下：

```
SELECT [ <Set Quantifier> ] <Select List>
```

此结构包含两个主要部分：

1. **集合量词 (Set Quantifier)**：一个可选的关键字，用于指定如何处理结果集中的重复行。
2. **选择列表 (Select List)**：一个或多个表达式的逗号分隔列表，用于定义结果集的列。



**集合量词 (Set Quantifier)**

```
[ <Set Quantifier> ] = ALL | DISTINCT
```

集合量词用于控制是否在最终结果中保留或消除完全相同的行。

- `ALL`: 这是默认的量词。如果指定 `ALL` 或不指定任何量词，查询将返回所有满足条件的行，包括完全相同的重复行。
- `DISTINCT`: 此量词指示数据库在返回结果之前，必须移除结果集中所有完全重复的行，确保每一行都是唯一的。一行为另一行的“重复”是指该行中由 **`SELECT` 列表所定义的每一列的值都与另一行相应列的值完全相同**。

```
-- 返回所有行，包括重复的部门ID
SELECT ALL department_id FROM employees;

-- 返回唯一的部门ID列表
SELECT DISTINCT department_id FROM employees;
```



**选择列表 (Select List)**

选择列表是 `SELECT` 子句的核心，它是一个或多个**选择表达式（Select Expression）**的列表，表达式之间用逗号（`,`）分隔。它定义了结果集中每一列的内容。



`<Select List>` 子语法可以拆解为如下：

```
SELECT [ <Set Quantifier> ]
	select_expression_1 [ [ AS ] alias_1 ],
	select_expression_2 [ [ AS ] alias_2 ],
	...
```



定义列或表的别名时，某些数据库要求必须使用 AS 关键字，而另一些数据库则允许省略 AS，直接在表达式后添加空格和别名。

因此，`<Select List>` 子句的语法可以进一步拆解如下：

```
SELECT [ <Set Quantifier> ]
	select_expression_1 [ AS alias_1 ],
	select_expression_2 [ AS alias_2 ],
	...
```



#### 表达式

在 SQL 标准语法中，**选择表达式（Select Expression）**式严格来说就是**表达式（Expression）**。

在 SQL 中，**表达式**是一个可以被数据库求值的**代码片段（**一个或多个值、运算符（Operators）、函数（Functions）和 SQL 其他语法元素，如 `CASE` 表达式组合而成），其最终结果是为每一行数据返回一个**单一、具体的值**。



**表达式的语法构成**

一个 SQL 表达式可以由以下一个或多个部分构成：

- **字面量 (Literals)**：固定的数据值，例如 `'some text'`、`101`、`TRUE`。
- **列引用 (Column References)**：来自表中的列名，例如 `user_id`、`product_price`。
- **运算符 (Operators)**：用于执行算术、比较、逻辑或字符串操作的符号，例如 `+`、`>`、`AND`、`||`。
- **函数调用 (Function Calls)**：对数据进行处理的 SQL 内置或自定义函数，例如 `UPPER()`、`COUNT()`、`GETDATE()`。
- **CASE 表达式**：用于在查询中添加 `if-then-else` 这样的条件判断逻辑。
- **子查询 (Subqueries)**：嵌套在表达式中、且返回单个值的 `SELECT` 查询。
- **括号 (Parentheses)**：用于控制运算的执行顺序和分组。



### FROM 子句

`FROM` 子句的主要功能是指定一个或多个“表引用”（Table Reference），并将它们组合起来，生成一个临时的、虚拟的中间结果集。后续的所有子句（如 `WHERE`, `GROUP BY`, `SELECT` 等）都将在这个中间结果集上进行操作。



`SELECT` 子句和 `FROM` 子句是 SQL 查询中最基本、最核心的两个部分，它们的关系是**提供者与消费者**的关系。

- `FROM` 子句：是**数据提供者**。它定义了本次查询的数据来源（即从哪些表或视图中获取数据）。
- `SELECT` 子句：是**数据消费者（和塑造者）**。它从 `FROM` 提供的数据源中，挑选、计算并构造出最终想要显示的列。



**查询处理流程（简化版）**

1. 数据库首先查看 `FROM` 子句，确定要访问的表（例如 `employees` 表）。如果存在 `JOIN`，数据库会在此步骤执行连接，生成一个包含所有相关数据的、临时的、庞大的虚拟数据集。
2. 如果指定了 `WHERE`、`GROUP BY` 和 `HAVING` 等子句，数据库还会对 `FROM` 产生的数据集进行**过滤、分组、对分组进行再过滤**。
3. 数据库才查看 `SELECT` 子句，从上一步（`HAVING` 或 `GROUP BY` 或 `WHERE` 或 `FROM`）的结果中，挑选出您指定的列（如 `first_name`, `salary`），并执行计算（如 `salary * 1.1`）和应用别名（如 `AS new_salary`）。
4. 如果指定了 `ORDER BY` 子句，数据库会对 `SELECT` 产生的结果进行排序。



#### 笛卡尔积 (CROSS JOIN)

在早期的 SQL 标准（SQL-89）中，连接表是通过在 `FROM` 子句中用逗号分隔表名，然后在 `WHERE` 子句中指定连接条件来实现的。

这是一种过时的语法，应该避免使用他它。

```sql
SELECT e.first_name, d.department_name
FROM employees e, departments d
WHERE e.department_id = d.id;
```

它将“连接条件”（`e.department_id = d.id`）和“过滤条件”（例如 `AND e.salary > 5000`）混在了一起，代码难以阅读和维护。

如果你忘记在 `WHERE` 中写连接条件，查询不会报错，而是会执行一个 `CROSS JOIN`（笛卡尔积），导致数据量爆炸和完全错误的结果。

现代的 `JOIN ... ON` 语法将连接逻辑和过滤逻辑清晰地分开，是目前唯一的标准实践。



不使用 `JOIN` 关键字，而是在 `FROM` 子句中用逗号分隔多个表的写法，是早期 SQL-89 标准中的语法。它执行的操作在现代 SQL 中被称为 **`CROSS JOIN` (交叉连接)**，也常常被称为 **笛卡尔积 (Cartesian Product)**。

```sql
MariaDB [test]> select * from a ; 
+------+------+
| name | id   |
+------+------+
| aaa  |    1 |
| bbb  |    2 |
| ccc  |    3 |
+------+------+
3 rows in set (0.000 sec)

MariaDB [test]> select * from b ;
+------+------+
| id   | type |
+------+------+
|    1 | a    |
|    2 | b    |
|    3 | c    |
+------+------+
3 rows in set (0.001 sec)

MariaDB [test]> select * from a , b ;
+------+------+------+------+
| name | id   | id   | type |
+------+------+------+------+
| aaa  |    1 |    1 | a    |
| bbb  |    2 |    1 | a    |
| ccc  |    3 |    1 | a    |
| aaa  |    1 |    2 | b    |
| bbb  |    2 |    2 | b    |
| ccc  |    3 |    2 | b    |
| aaa  |    1 |    3 | c    |
| bbb  |    2 |    3 | c    |
| ccc  |    3 |    3 | c    |
+------+------+------+------+
9 rows in set (0.000 sec)
```



### JOIN 子句

`JOIN` 子句是 SQL 的核心功能之一，它用于根据两个或多个表中的相关列之间的关系，将这些表中的行组合起来。

`JOIN` 的主要目的是从规范化（Normalization）的数据库中检索数据。在规范化数据库中，数据被分散到多个逻辑表中，以减少数据冗余并提高数据一致性。`JOIN` 允许我们在查询时将这些表“重新拼装”在一起。



#### INNER JOIN (内连接)

`INNER JOIN` 是最常用、也是默认的 `JOIN` 类型。它只返回在**两个表**中都存在匹配项的行。

`INNER JOIN` 的工作机制是：对于左表（`a` 表）的每一行，它会去右表（`b` 表）中查找所有满足 `ON` 条件（`a.id = b.id`）的行。只要找到一个匹配项，它就会将左表行和右表行组合起来，生成一条结果。

```sql
MariaDB [test]> select * from a ; 
+------+------+
| name | id   |
+------+------+
| aaa  |    1 |
| bbb  |    2 |
| ccc  |    3 |
+------+------+
3 rows in set (0.000 sec)

MariaDB [test]> select * from b ;
+------+------+
| id   | type |
+------+------+
|    1 | a    |
|    2 | b    |
|    3 | c    |
+------+------+
3 rows in set (0.001 sec)

MariaDB [test]> select * from a join b on a.id = b.id ; 
+------+------+------+------+
| name | id   | id   | type |
+------+------+------+------+
| aaa  |    1 |    1 | a    |
| bbb  |    2 |    2 | b    |
| ccc  |    3 |    3 | c    |
+------+------+------+------+
3 rows in set (0.000 sec)

MariaDB [test]> insert into b values ( 1 , 'd' ) ; 
Query OK, 1 row affected (0.001 sec)

MariaDB [test]> 
MariaDB [test]> 
MariaDB [test]> select * from a join b on a.id = b.id ;
+------+------+------+------+
| name | id   | id   | type |
+------+------+------+------+
| aaa  |    1 |    1 | a    |
| bbb  |    2 |    2 | b    |
| ccc  |    3 |    3 | c    |
| aaa  |    1 |    1 | d    |
+------+------+------+------+
4 rows in set (0.000 sec)
```



#### LEFT JOIN (左连接)

`LEFT JOIN` (也写作 `LEFT OUTER JOIN`) 返回**左表** (`FROM` 子句中列出的第一个表) 的**所有**行，以及右表中匹配的行。如果右表中没有匹配项，则右表的列将显示为 `NULL`。



**工作原理是**：

- **以左表（`FROM` 后面的表）为基准，返回左表中的所有行，并附带右表中匹配的行。**
- 如果左表的某行在右表中**没有**找到匹配项，那么结果集中这一行**仍然会被保留**，只是所有来自右表的列的值都会被填充为 `NULL`。



**示例**：

```sql
MariaDB [test]> select * from a ; 
+------+------+
| name | id   |
+------+------+
| aaa  |    1 |
| bbb  |    2 |
| ccc  |    3 |
+------+------+
3 rows in set (0.000 sec)

MariaDB [test]> select * from b ;
+------+------+
| id   | type |
+------+------+
|    1 | a    |
|    2 | b    |
+------+------+
2 rows in set (0.000 sec)

MariaDB [test]> 
MariaDB [test]> select * from a left join b on a.id = b.id ; 
+------+------+------+------+
| name | id   | id   | type |
+------+------+------+------+
| aaa  |    1 |    1 | a    |
| bbb  |    2 |    2 | b    |
| ccc  |    3 | NULL | NULL |
+------+------+------+------+
3 rows in set (0.000 sec)

MariaDB [test]> insert into b values ( 1 , 'd' ) ;
Query OK, 1 row affected (0.001 sec)

MariaDB [test]> select * from a left join b on a.id = b.id ;
+------+------+------+------+
| name | id   | id   | type |
+------+------+------+------+
| aaa  |    1 |    1 | a    |
| bbb  |    2 |    2 | b    |
| aaa  |    1 |    1 | d    |
| ccc  |    3 | NULL | NULL |
+------+------+------+------+
4 rows in set (0.000 sec)
```



#### RIGHT JOIN (右连接)

`RIGHT JOIN` (也写作 `RIGHT OUTER JOIN`) 与 `LEFT JOIN` 完全相反。它返回**右表** (`JOIN` 子句中列出的第二个表) 的**所有**行，以及左表中匹配的行。如果左表中没有匹配项，则左表的列将显示为 `NULL`。



工作原理是：

- **以右表（`JOIN` 后面的表）为基准，返回右表中的所有行，并附带左表中匹配的行。**
- 如果右表的某行在左表中**没有**找到匹配项，那么结果集中这一行**仍然会被保留**，只是所有来自左表的列的值都会被填充为 `NULL`。



**示例：**

```sql
MariaDB [test]> select * from a ; 
+------+------+
| name | id   |
+------+------+
| aaa  |    1 |
| bbb  |    2 |
| ccc  |    3 |
+------+------+
3 rows in set (0.000 sec)

MariaDB [test]> select * from b ;
+------+------+
| id   | type |
+------+------+
|    1 | a    |
|    2 | b    |
|    3 | c    |
|    4 | d    |
+------+------+
4 rows in set (0.000 sec)

MariaDB [test]> select * from a right join b on a.id = b.id ; 
+------+------+------+------+
| name | id   | id   | type |
+------+------+------+------+
| aaa  |    1 |    1 | a    |
| bbb  |    2 |    2 | b    |
| ccc  |    3 |    3 | c    |
| NULL | NULL |    4 | d    |
+------+------+------+------+
4 rows in set (0.000 sec)

MariaDB [test]> insert into a values ( 'ddd' , 1 ) ;
Query OK, 1 row affected (0.001 sec)

MariaDB [test]> 
MariaDB [test]> select * from a right join b on a.id = b.id ;
+------+------+------+------+
| name | id   | id   | type |
+------+------+------+------+
| aaa  |    1 |    1 | a    |
| bbb  |    2 |    2 | b    |
| ccc  |    3 |    3 | c    |
| ddd  |    1 |    1 | a    |
| NULL | NULL |    4 | d    |
+------+------+------+------+
5 rows in set (0.000 sec)
```



#### FULL OUTER JOIN (全外连接)

`FULL OUTER JOIN` 返回左表和右表中的**所有**行。如果某一行在另一个表中没有匹配项，则另一个表的列将显示为 `NULL`。可以把它想象成两个表的“并集”。



工作原理是：**返回左表（`table_A`）和右表（`table_B`）中的所有行。**

- 如果左表的行在右表有匹配项，则正常组合返回。
- 如果左表的行在右表**没有**匹配项，则该行依然被返回，并且右表对应的列填充为 `NULL`（这是 `LEFT JOIN` 的特性）。
- 如果右表的行在左表**没有**匹配项，则该行也依然被返回，并且左表对应的列填充为 `NULL`（这是 `RIGHT JOIN` 的特性）。



**重要：** MySQL **不直接支持** `FULL OUTER JOIN` 关键字。但是，我们可以使用 `LEFT JOIN` 和 `RIGHT JOIN` 结合 `UNION` 来模拟它。

```sql
MariaDB [test]> select * from a ; 
+------+------+
| name | id   |
+------+------+
| aaa  |    1 |
| bbb  |    2 |
| ccc  |    3 |
| eee  |    5 |
+------+------+
4 rows in set (0.000 sec)

MariaDB [test]> select * from b ;
+------+------+
| id   | type |
+------+------+
|    1 | a    |
|    2 | b    |
|    3 | c    |
|    4 | d    |
+------+------+
4 rows in set (0.000 sec)

MariaDB [test]> select * from a left join b on a.id = b.id union select * from a right join b on a.id = b.id ; 
+------+------+------+------+
| name | id   | id   | type |
+------+------+------+------+
| aaa  |    1 |    1 | a    |
| bbb  |    2 |    2 | b    |
| ccc  |    3 |    3 | c    |
| eee  |    5 | NULL | NULL |
| NULL | NULL |    4 | d    |
+------+------+------+------+
5 rows in set (0.001 sec)
```



#### CROSS JOIN (交叉连接)

`CROSS JOIN` 返回两个表的**笛卡尔积** (Cartesian Product)。它会返回左表中每一行与右表中每一行的所有可能组合。



`CROSS JOIN` **不需要 `ON` 连接条件**。

```sql
MariaDB [test]> select * from a ;
+------+------+
| name | id   |
+------+------+
| aaa  |    1 |
| bbb  |    2 |
| ccc  |    3 |
+------+------+
3 rows in set (0.000 sec)

MariaDB [test]> select * from b ;
+------+------+
| id   | type |
+------+------+
|    1 | a    |
|    2 | b    |
|    3 | c    |
+------+------+
3 rows in set (0.000 sec)

MariaDB [test]> select * from a cross join b ;
+------+------+------+------+
| name | id   | id   | type |
+------+------+------+------+
| aaa  |    1 |    1 | a    |
| bbb  |    2 |    1 | a    |
| ccc  |    3 |    1 | a    |
| aaa  |    1 |    2 | b    |
| bbb  |    2 |    2 | b    |
| ccc  |    3 |    2 | b    |
| aaa  |    1 |    3 | c    |
| bbb  |    2 |    3 | c    |
| ccc  |    3 |    3 | c    |
+------+------+------+------+
9 rows in set (0.000 sec)
```



#### SELF JOIN (自连接)

`SELF JOIN` 不是一种新的 `JOIN` 类型，而是一种特殊的用法：**一个表与它自己连接**。

这在处理具有层级关系，或在同一张表中进行行比较时非常有用。



假设 `employees` 表结构如下，包含一个 `manager_id` 列，指向该员工的经理 (经理的 `id`)：

| **id** | **name** | **manager_id** |
| ------ | -------- | -------------- |
| 1      | 老板     | NULL           |
| 2      | 经理A    | 1              |
| 3      | 经理B    | 1              |
| 4      | 员工C    | 2              |
| 5      | 员工D    | 3              |



要查询每个员工及其对应的经理名称，我们必须使用**表别名 (Alias)** 来区分 "员工表" 和 "经理表" (尽管它们是同一个表)。

```sql
SELECT
  e.name AS employee_name, -- 员工的名字
  m.name AS manager_name   -- 经理的名字
FROM
  employees AS e
  LEFT JOIN employees AS m ON e.manager_id = m.id; -- 员工的manager_id 匹配 经理的id
```



**结果**

| **employee_name** | **manager_name** |
| ----------------- | ---------------- |
| 老板              | NULL             |
| 经理A             | 老板             |
| 经理B             | 老板             |
| 员工C             | 经理A            |
| 员工D             | 经理B            |



### WHERE 子句

`WHERE` 子句的核心功能是 **过滤行 (Row Filtering)**。

它通过设置一个或多个“搜索条件”（Search Condition），逐一检查 `FROM` 子句产生的结果集中的每一行。只有**满足**（即计算结果为 `TRUE`）这些条件的行才会被保留下来，进入查询的下一个阶段（如 `GROUP BY`, `SELECT` 或 `ORDER BY`）。不满足条件的行将被丢弃。



**`WHERE` 子句的语法和位置**

`WHERE` 子句位于 `FROM` 子句（包括所有的 `JOIN`）之后，但在 `GROUP BY` 和 `ORDER BY` 子句之前。

```sql
SELECT select_list
FROM table_source
[JOIN ...]
WHERE search_condition  -- <--- 在这里
[GROUP BY ...]
[HAVING ...]
[ORDER BY ...]
```



**`search_condition` (搜索条件) 详解**

`WHERE` 子句后面的 `search_condition`（搜索条件）必须是一个 **布尔表达式（Boolean Expression）**。这意味着这个表达式的最终计算结果必须是 `TRUE`、`FALSE` 或 `UNKNOWN`（`NULL` 值参与比较时产生）。

只有结果为 `TRUE` 的行才会被选中。

构建这个条件，你需要使用各种 **操作符（Operators）**：



#### 比较操作符

这是最基本的条件，用于比较两个值。

- `=`：等于
- `!=` 或 `<>`：不等于
- `>`：大于
- `<`：小于
- `>=`：大于等于
- `<=`：小于等于



**查找 'Sales' 部门的所有员工**

```sql
SELECT * FROM employees WHERE department = 'Sales';
```



**查找薪水超过 50000 的员工**

```sql
SELECT * FROM employees WHERE salary > 50000;
```





#### 逻辑操作符

用于组合多个比较条件。

- `AND`：**与**。必须同时满足 `AND` 两边的所有条件。
- `OR`：**或**。只需满足 `OR` 两边的任意一个条件即可。
- `NOT`：**非**。对紧随其后的条件取反。



**查找 'Sales' 部门中薪水超过 50000 的员工**

```sql
SELECT * FROM employees WHERE department = 'Sales' AND salary > 50000;
```



**查找 'Sales' 部门或 'Marketing' 部门的员工**

```sql
SELECT * FROM employees WHERE department = 'Sales' OR department = 'Marketing';
```



**查找所有不在 'Sales' 部门的员工**

```sql
SELECT * FROM employees WHERE NOT department = 'Sales';
```



**当 `AND` 和 `OR` 混合使用时，`AND` 的优先级高于 `OR`。为了清晰和避免错误，强烈建议使用 括号 `()` 来明确指定运算顺序。**

```sql
WHERE (department = 'Sales' AND salary > 50000) OR is_manager = TRUE;
```



#### 范围和列表操作符

`BETWEEN ... AND ...`：**在两者之间**（包含边界值）。

**查找薪水在 50000 到 80000 之间的员工**

```sql
WHERE salary BETWEEN 50000 AND 80000;
```

等同于: `WHERE salary >= 50000 AND salary <= 80000;`



`IN (...)`：**在列表中**。匹配列表中的任何一个值。

**查找 'Sales' 或 'Marketing' 部门的员工 (比 OR 更简洁)**

```sql
WHERE department IN ('Sales', 'Marketing');
```



`NOT IN (...)`：**不在列表中**。

**查找所有不在 'Sales' 或 'Marketing' 部门的员工**

```
WHERE department NOT IN ('Sales', 'Marketing');
```



#### 模式匹配操作符

`LIKE`：**模糊匹配**。用于字符串搜索，通常配合通配符使用。

- `%` (百分号)：匹配任意零个或多个字符。
- `_` (下划线)：匹配任意**一个**字符。



**查找所有姓 'Smith' 的人**

```sql
WHERE last_name LIKE 'Smith';
```



**查找所有名字以 'J' 开头的人**

```sql
WHERE first_name LIKE 'J%';
```



**查找所有名字中包含 'an' 的人**

```sql
WHERE first_name LIKE '%an%';
```



**查找所有名字为4个字母且以 'J' 开头以 'n' 结尾的人**

```sql
WHERE first_name LIKE 'J__n';
```



#### `NULL` 值处理操作符

- `IS NULL`：**检查是否为 `NULL`**。
- `IS NOT NULL`：**检查是否不为 `NULL`**。



**重要**：`NULL` 代表“未知”或“缺失”，它不能用 `=` 来比较。你 **不能** 写 `WHERE manager_id = NULL`，这永远不会返回 `TRUE`。必须使用 `IS NULL`。



**查找所有没有经理的员工**

```sql
SELECT * FROM employees WHERE manager_id IS NULL;
```



### GROUP BY 子句

`GROUP BY` 是 SQL 中一个非常强大且常用的功能，它的核心作用是**将结果集中的数据行根据一个或多个列的值进行分组，以便对每个组执行聚合函数（如计算总数、平均值、最大值等）**。



如果没有 `GROUP BY`，聚合函数（如 `SUM()`, `COUNT()`）会作用于整个表的所有行，并只返回一个结果。

而 `GROUP BY` 的作用就是改变聚合函数的计算范围。它会告诉数据库：“不要对所有数据进行计算，而是先把数据按照指定的列分成若干个‘桶’（组），然后对每个‘桶’（组）分别进行计算。”



假设有一个 `sales` (销售) 表，结构如下：

**`sales` 表:**

| id   | product_category | city | amount | sale_date  |
| :--- | :--------------- | :--- | :----- | :--------- |
| 1    | 电子产品         | 北京 | 1200   | 2023-10-01 |
| 2    | 服装             | 上海 | 300    | 2023-10-01 |
| 3    | 电子产品         | 上海 | 1500   | 2023-10-02 |
| 4    | 图书             | 北京 | 90     | 2023-10-02 |
| 5    | 服装             | 北京 | 450    | 2023-10-03 |
| 6    | 电子产品         | 北京 | 800    | 2023-10-04 |
| 7    | 图书             | 上海 | 120    | 2023-10-04 |

```sql
MariaDB [test]> CREATE TABLE sales (
    ->     id INT PRIMARY KEY AUTO_INCREMENT,
    ->     product_category VARCHAR(255) NOT NULL,
    ->     city VARCHAR(255) NOT NULL,
    ->     amount DECIMAL(10, 2) NOT NULL,
    ->     sale_date DATE
    -> );
Query OK, 0 rows affected (0.014 sec)

MariaDB [test]> 
MariaDB [test]> 
MariaDB [test]> 
MariaDB [test]> INSERT INTO sales (id, product_category, city, amount, sale_date) VALUES
    -> (1, '电子产品', '北京', 1200.00, '2023-10-01'),
    -> (2, '服装', '上海', 300.00, '2023-10-01'),
    -> (3, '电子产品', '上海', 1500.00, '2023-10-02'),
    -> (4, '图书', '北京', 90.00, '2023-10-02'),
    -> (5, '服装', '北京', 450.00, '2023-10-03'),
    -> (6, '电子产品', '北京', 800.00, '2023-10-04'),
    -> (7, '图书', '上海', 120.00, '2023-10-04');
Query OK, 7 rows affected (0.004 sec)
Records: 7  Duplicates: 0  Warnings: 0

MariaDB [test]> select * from sales ; 
+----+------------------+--------+---------+------------+
| id | product_category | city   | amount  | sale_date  |
+----+------------------+--------+---------+------------+
|  1 | 电子产品         | 北京   | 1200.00 | 2023-10-01 |
|  2 | 服装             | 上海   |  300.00 | 2023-10-01 |
|  3 | 电子产品         | 上海   | 1500.00 | 2023-10-02 |
|  4 | 图书             | 北京   |   90.00 | 2023-10-02 |
|  5 | 服装             | 北京   |  450.00 | 2023-10-03 |
|  6 | 电子产品         | 北京   |  800.00 | 2023-10-04 |
|  7 | 图书             | 上海   |  120.00 | 2023-10-04 |
+----+------------------+--------+---------+------------+
7 rows in set (0.001 sec)
```





**示例 1：计算每个商品分类的销售总额**

我们需要按 `product_category` 分组，然后对每个组的 `amount` 求和。

```sql
SELECT
    product_category,
    SUM(amount) AS total_sales
FROM
    sales
GROUP BY
    product_category;
```

**执行过程：**

1. 数据库找到所有 `product_category` 的唯一值：“电子产品”、“服装”、“图书”。
2. 创建三个组（三个桶）。
3. 将所有“电子产品”的行放入第一个组，将“服装”的行放入第二个组，以此类推。
4. 对第一个组（电子产品）的所有行的 `amount` (1200, 1500, 800) 执行 `SUM()`，得到 3500。
5. 对第二个组（服装）的所有行的 `amount` (300, 450) 执行 `SUM()`，得到 750。
6. 对第三个组（图书）的所有行的 `amount` (90, 120) 执行 `SUM()`，得到 210。

**结果：**

| product_category | total_sales |
| :--------------- | :---------- |
| 电子产品         | 3500        |
| 服装             | 750         |
| 图书             | 210         |

```
MariaDB [test]> select product_category , sum(amount) AS total_sales from sales group by product_category ; 
+------------------+-------------+
| product_category | total_sales |
+------------------+-------------+
| 图书             |      210.00 |
| 服装             |      750.00 |
| 电子产品         |     3500.00 |
+------------------+-------------+
3 rows in set (0.013 sec)

```



**示例 2：计算每个城市的订单数量和平均订单金额**

按 `city` 分组，然后用 `COUNT()` 计算行数，用 `AVG()` 计算平均值。

```
SELECT
    city,
    COUNT(id) AS order_count,
    AVG(amount) AS average_amount
FROM
    sales
GROUP BY
    city;
```

**结果：**

| city | order_count | average_amount |
| :--- | :---------- | :------------- |
| 北京 | 4           | 635.0000       |
| 上海 | 3           | 640.0000       |

```sql
MariaDB [test]> select city , count(id) as order_count , avg(amount) as average_amount from sales group by city ; 
+--------+-------------+----------------+
| city   | order_count | average_amount |
+--------+-------------+----------------+
| 上海   |           3 |     640.000000 |
| 北京   |           4 |     635.000000 |
+--------+-------------+----------------+
2 rows in set (0.011 sec)
```



**示例 3：多列分组**

计算每个城市、每个商品分类的销售总额是多少，需要同时按 `city` 和 `product_category` 进行分组。

```sql
SELECT
    city,
    product_category,
    SUM(amount) AS total_sales
FROM
    sales
GROUP BY
    city, product_category
ORDER BY
    city, product_category;
```

**结果：**

| city | product_category | total_sales |
| ---- | ---------------- | ----------- |
| 北京 | 电子产品         | 2000        |
| 北京 | 图书             | 90          |
| 北京 | 服装             | 450         |
| 上海 | 电子产品         | 1500        |
| 上海 | 图书             | 120         |
| 上海 | 服装             | 300         |

```sql
MariaDB [test]> select city , product_category , sum(amount) as total_sales from sales group by city , product_category order by city , product_category ;
+--------+------------------+-------------+
| city   | product_category | total_sales |
+--------+------------------+-------------+
| 上海   | 图书             |      120.00 |
| 上海   | 服装             |      300.00 |
| 上海   | 电子产品         |     1500.00 |
| 北京   | 图书             |       90.00 |
| 北京   | 服装             |      450.00 |
| 北京   | 电子产品         |     2000.00 |
+--------+------------------+-------------+
6 rows in set (0.011 sec)
```



在 `GROUP BY` 子句中指定了某些列，它的主要作用就是**将这些列中具有相同值的行合并成一行**。

如果你使用了 `GROUP BY`，那么 `SELECT` 子句中只能包含：

1. **`GROUP BY` 子句中出现的列**。
2. **聚合函数**（如 `COUNT()`, `SUM()`, `AVG()` 等）。
3. 对分组列或聚合函数进行计算的表达式。

**如果你 `SELECT` 了一个没有出现在 `GROUP BY` 子句中，也不是聚合函数的列，MySQL 将会直接报错。**



**`sales` 表:**

| id   | product_category | city | amount |
| :--- | :--------------- | :--- | :----- |
| 1    | 电子产品         | 北京 | 1200   |
| 3    | 电子产品         | 上海 | 1500   |
| 6    | 电子产品         | 北京 | 800    |



假设我们执行以下 SQL：

```sql
-- 这是一个错误的查询 (在 ONLY_FULL_GROUP_BY 模式下)

SELECT product_category, city

FROM sales

GROUP BY product_category;
```

1. `GROUP BY product_category` 会把所有 "电子产品" 的行（id 为 1, 3, 6 的行）合并成一个组，准备输出为一行。
2. 对于 `product_category` 列，输出 "电子产品" 是没有歧义的。
3. 但是对于 `city` 列，数据库不能确定合并后的 "电子产品" 行对应的 `city` 应该是 "北京" 还是 "上海"。

由于存在这种不确定性（非确定性），为了保证数据的一致性和准确性，数据库会拒绝执行这个查询，并抛出错误。



如果手动修改了 `sql_mode`，关闭了 `ONLY_FULL_GROUP_BY` 模式，MySQL 的行为会变得“宽松”，但结果可能出乎意料。

在这种情况下，MySQL **不会报错**。对于那个有歧义的列（上例中的 `city`），MySQL 会**从每个分组中随机选择一个值**来显示。



在之前的例子中，`GROUP BY product_category` 导致 "电子产品" 分组中出现了 "北京" 和 "上海" 两个不同的 `city` 值，数据库不知道该选哪个，所以报错。

现在假设所有 `product_category` 为 "电子产品" 的行，其 `city` **全部都是 "北京"**。

当 `product_category` 的值确定为 "电子产品" 时，`city` 的值也**唯一确定**为 "北京"。不存在任何 ambiguity (歧义)。



旧版本 MySQL (5.7.5 之前)在实现 `ONLY_FULL_GROUP_BY` 时，它的检查规则很简单，`SELECT` 子句中的任何非聚合列，都**必须**在 `GROUP BY` 子句中明确出现。

即便是你假设的场景（所有 city 都是 "北京"），旧版本的 MySQL 依然会报错，因为它只看语法，不看数据。



从 5.7.5 版本开始，MySQL 对 `ONLY_FULL_GROUP_BY` 的检测变得更加智能。



### HAVING 子句

`HAVING` 子句是 SQL 中一个专门用来**对分组后的结果进行条件筛选**的工具。

`WHERE` 子句可以用来过滤数据行。但 `WHERE` 有一个巨大的限制：**它无法与聚合函数（如 `SUM()`, `COUNT()` 等）一起使用**。

`WHERE` 在数据分组 (`GROUP BY`) **之前**执行，它操作的是表中的原始的、一行一行的数据。 而聚合函数是作用在**一组**数据上的，只有在 `GROUP BY` 完成分组之后，聚合计算的结果才会产生。



**基础语法**

`HAVING` 子句必须跟在 `GROUP BY` 子句之后，`ORDER BY` 子句之前。

```sql
SELECT
    column_name1,
    aggregate_function(column_name2)
FROM
    table_name
WHERE
    row_condition        -- 步骤2：过滤行
GROUP BY
    column_name1         -- 步骤3：分组
HAVING
    aggregate_condition  -- 步骤4：过滤组
ORDER BY
    column_name3;        -- 步骤5：排序
```



**继续使用之前的 `sales` 表进行示例。**



**示例 1：找出总销售额超过 1000 元的商品分类**

按 `product_category` 分组，计算每个组的 `SUM(amount)`，使用 `HAVING` 筛选出 `SUM(amount) > 1000` 的组。

```sql
SELECT
    product_category,
    SUM(amount) AS total_sales
FROM
    sales
GROUP BY
    product_category
HAVING
    SUM(amount) > 1000;
```

*这里的 `HAVING total_sales > 1000;` 也是合法的，因为 MySQL 支持在 `HAVING` 中使用 `SELECT` 的别名。*

**结果：**

| product_category | total_sales |
| :--------------- | :---------- |
| 电子产品         | 3500.00     |



**示例 2：找出订单数量超过 2 笔的城市**

按 `city` 分组，计算每个组的订单数 `COUNT(*)`，使用 `HAVING` 筛选出 `COUNT(*) > 2` 的组。

```sql
SELECT
    city,
    COUNT(*) AS order_count
FROM
    sales
GROUP BY
    city
HAVING
    COUNT(*) > 2;
```

**结果：**

| city | order_count |
| :--- | :---------- |
| 北京 | 4           |
| 上海 | 3           |



示例 3：同时使用 `WHERE` 和 `HAVING`

筛选在**北京**地区总销售额超过 500 元的商品分类。

1. **先用 `WHERE`**：从原始数据中只选出 `city = '北京'` 的行。
2. **再用 `GROUP BY`**：对筛选出的北京地区的数据，按 `product_category` 分组。
3. **最后用 `HAVING`**：在这些分组中，筛选出 `SUM(amount) > 500` 的组。

```sql
SELECT
    product_category,
    SUM(amount) AS total_sales
FROM
    sales
WHERE
    city = '北京'
GROUP BY
    product_category
HAVING
    SUM(amount) > 500;
```

**最终结果：**

| product_category | total_sales |
| :--------------- | :---------- |
| 电子产品         | 2000.00     |



### order by 子句

数据库中的数据存储和检索，其默认顺序通常是不确定的。它可能基于数据插入的顺序、索引的物理布局或其他内部优化机制。如果你不明确指定排序规则，你每次执行相同的查询，理论上得到的行顺序都可能不同。

`ORDER BY` 的作用就是**消除这种不确定性**，确保你每次都能得到一个按可预测顺序排列的结果集。这对于生成报表、在用户界面上展示数据以及数据分析都至关重要。



`ORDER BY` 子句通常是 `SELECT` 语句的最后一个子句。

```sql
SELECT
    column1, column2, ...
FROM
    table_name
WHERE
    condition
ORDER BY
    column_to_sort [ASC | DESC];
```

- **`column_to_sort`**: 你希望根据哪个列的值来进行排序。
- **`ASC` | `DESC`**: 指定排序的方向。



**排序方向：ASC 与 DESC**

**`ASC` (Ascending)**：**升序**。这是**默认**的排序方式。

- 对于数值类型，从小到大排序 (1, 2, 3, ...)。
- 对于日期/时间类型，从早到晚排序。
- 对于字符串类型，按字母顺序排序 (A, B, C, ...)。

**`DESC` (Descending)**：**降序**。与升序完全相反。

- 对于数值类型，从大到小排序 (..., 3, 2, 1)。
- 对于日期/时间类型，从晚到早排序。
- 对于字符串类型，按字母逆序排序 (..., C, B, A)。



**示例 1：按金额升序和降序排序**

**按销售金额从小到大排序 (升序)**

```sql
-- ASC 是默认值，所以可以省略

SELECT product_category, city, amount

FROM sales

ORDER BY amount ASC;



-- 等同于

SELECT product_category, city, amount

FROM sales

ORDER BY amount;
```

**结果：**

| product_category | city | amount  |
| :--------------- | :--- | :------ |
| 图书             | 北京 | 90.00   |
| 图书             | 上海 | 120.00  |
| 服装             | 上海 | 300.00  |
| 服装             | 北京 | 450.00  |
| 电子产品         | 北京 | 800.00  |
| 电子产品         | 北京 | 1200.00 |
| 电子产品         | 上海 | 1500.00 |



### LIMIT 子句

`LIMIT` 子句用于限制 `SELECT` 语句返回的行数。 它可以接受一个或两个非负整数参数。



**语法**

**`LIMIT row_count`**: 这种形式只接受一个参数，表示从结果集的开头返回指定数量的行。

```sql
SELECT column1, column2, ...
FROM table_name
[WHERE conditions]
[ORDER BY column_name(s)]
LIMIT row_count;
```



**`LIMIT offset, row_count`**: 这种形式接受两个参数，`offset` 指定从哪一行开始（偏移量），`row_count` 指定要返回的行数。第一行的偏移量是 0。

```sql
SELECT column1, column2, ...
FROM table_name
[WHERE conditions]
[ORDER BY column_name(s)]
LIMIT offset, row_count;
```



**OFFSET 关键字**

除了逗号分隔的语法，MySQL 还支持使用 `OFFSET` 关键字，这使得语法更具可读性，并且与其他一些数据库系统（如 PostgreSQL）兼容。

**`LIMIT row_count OFFSET offset`**: 这种形式与 `LIMIT offset, row_count` 的功能完全相同。

```sql
SELECT column1, column2, ...
FROM table_name
[WHERE conditions]
[ORDER BY column_name(s)]
LIMIT row_count OFFSET offset;
```

**参数说明:**

- `row_count`: 必须是一个非负整数，指定要返回的最大行数。
- `offset`: 必须是一个非负整数，指定开始返回数据之前要跳过的行数。第一行的偏移量为 0。



## Install

### RHEL 10

#### 安装

RHEL 10 提供了 MySQL 8.4 作为应用程序流的初始版本，其可作为 RPM 软件包轻松地安装。



安装 MySQL 服务器软件包：

```
dnf -y install mysql-server
```



系统启用了 systemd，应使用标准的 **systemctl** 命令，例如 **stop**、**start**、**status** 和 **restart** 来管理 MySQL 服务器服务。默认情况下，`mysqld` 服务已启用，并且会在系统重启时启动。



启用并启动 mysqld 服务：

```
systemctl enable --now mysqld.service
```



安装后提高安全性：

```
mysql_secure_installation
```

此命令启动一个完全交互的脚本，该脚本会提示过程中的每一步。该脚本可让您通过以下方法提高安全性：

- 为 root 帐户设置密码
- 删除匿名用户
- 禁止远程 root 登录（在本地主机之外）



注：在执行此脚本前确保 mysql 服务已经正常运行，可多次执行此脚本修改设置。如果已经设置 MySQL 数据库 root 密码，则第二次执行此脚本时需要输入 root 密码。



如果你在执行 `mysql_secure_installation` 时遇到 `Error: Can't connect to local MySQL server through socket '/var/lib/mysql/mysql.sock' (2)` 错误，这意味着 MySQL 服务器守护程序 (Unix) 或服务 (Windows) 未运行。



执行 mysql_secure_installation 典型示例。

```vim
mysql_secure_installation 

Securing the MySQL server deployment.

Connecting to MySQL using a blank password.

VALIDATE PASSWORD COMPONENT can be used to test passwords
and improve security. It checks the strength of password
and allows the users to set only those passwords which are
secure enough. Would you like to setup VALIDATE PASSWORD component?

Press y|Y for Yes, any other key for No:  # Enter
Please set the password for root here.

New password: # Pass-1234

Re-enter new password: # Pass-1234 
By default, a MySQL installation has an anonymous user,
allowing anyone to log into MySQL without having to have
a user account created for them. This is intended only for
testing, and to make the installation go a bit smoother.
You should remove them before moving into a production
environment.

Remove anonymous users? (Press y|Y for Yes, any other key for No) : # y
Success.


Normally, root should only be allowed to connect from
'localhost'. This ensures that someone cannot guess at
the root password from the network.

Disallow root login remotely? (Press y|Y for Yes, any other key for No) : # n

 ... skipping.
By default, MySQL comes with a database named 'test' that
anyone can access. This is also intended only for testing,
and should be removed before moving into a production
environment.


Remove test database and access to it? (Press y|Y for Yes, any other key for No) : # y
 - Dropping test database...
Success.

 - Removing privileges on test database...
Success.

Reloading the privilege tables will ensure that all changes
made so far will take effect immediately.

Reload privilege tables now? (Press y|Y for Yes, any other key for No) : # y
Success.

All done! 
```



执行 mysql_secure_installation 典型示例（中文翻译）。

```
mysql_secure_installation

保护 MySQL 服务器部署。

使用空白密码连接到 MySQL。

“验证密码组件”可用于测试密码
并提高安全性。它会检查密码强度，
并允许用户仅设置足够安全的密码。
是否要设置“验证密码组件”？

按 y|Y 表示“是”，按任何其他键表示“否”：# Enter
请在此处设置 root 用户的密码。

新密码：# Pass-1234

重新输入新密码：# Pass-1234
默认情况下，MySQL 安装会有一个匿名用户，
允许任何人登录 MySQL，而无需为其创建用户帐户。
这仅用于测试，并使安装过程更顺畅。
在进入生产环境之前，您应该删除它们。

删除匿名用户？ （按 y|Y 表示是，按任何其他键表示否）：# y
成功。

通常，root 只应被允许从
“localhost”连接。这确保了其他人无法从网络猜测到
root 密码。

是否禁止远程 root 登录？（按 y|Y 表示是，按任何其他键表示否）：# n

……跳过。
默认情况下，MySQL 自带一个名为“test”的数据库，
任何人都可以访问。该数据库也仅用于测试，
在迁移到生产环境之前应将其删除。

是否删除测试数据库及其访问权限？（按 y|Y 表示是，按任何其他键表示否）：# y
- 正在删除测试数据库……
成功。

- 正在删除测试数据库的权限……
成功。

重新加载权限表将确保迄今为止所做的所有更改
立即生效。

现在重新加载权限表吗？ （按 y|Y 表示“是”，按任何其他键表示“否”）：# y
成功。

全部完成！
```



#### 配置对 MySQL 的网络访问



## 教程

### 连接和断开服务器

要连接到服务器，您通常需要在调用 **mysql** 时提供一个 MySQL 用户名，并且很有可能还需要提供密码。

如果服务器运行在您登录的机器之外，您还必须指定主机名。



**本地连接**

连接在本机上运行的 mysql 数据库

```
mysql -u root -p
Enter password: ********
```

*`user`* 代表运行 MySQL 帐户的用户名，`********` 代表您的密码，当 mysql 显示 Enter password: 提示符时输入它。



**不安全的登录方式**

可以直接在 -p 参数后面**（此处无空格）**输入密码

```
mysql -u root -pPass-1234
```

**这非常不安全，在生产环境下请不要使用这种方法。此处仅介绍存在该功能。**



**连接其他主机上的 mysql 数据库**

```
mysql -h host -P port -u user -p
Enter password: ********
```

*`host`* 和 *`port`* 代表运行 MySQL 服务器的主机名（ IP 地址）和端口号。

如果你不指定主机名则通过 uninx socket 连接到本地 MySQL 服务器。

仅指定主机名时才允许指定端口，如果你不指定端口号，默认为 3306。



如果这有效，您应该会看到一些介绍性信息，然后是一个 `mysql>` 提示符

```
$> mysql -h 127.0.0.1 -P 3306 -u root -p
Enter password: ********
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 25338 to server version: 8.4.0-standard

Type 'help;' or '\h' for help. Type '\c' to clear the buffer.

mysql>
```



**匿名连接**

某些 MySQL 安装允许用户以匿名（未命名）用户身份连接到运行在本地主机上的服务器。能够直接使用 `mysql` 而不使用任何选项来连接到该服务器。

```
$> mysql
```



成功连接后，您可以随时通过在 `mysql>` 提示符下键入 `QUIT`（或 `\q`）来断开连接

```
mysql> QUIT
Bye
```

在 Unix 上，您也可以通过按下 Control+D 来断开连接。



如果您在尝试登录时收到错误消息，例如 `Error: Can't connect to local MySQL server through socket '/var/lib/mysql/mysql.sock' (2)`，这意味着 MySQL 服务器守护程序 (Unix) 或服务 (Windows) 未运行。



### 输入查询

#### 简单查询

以下是一个简单的查询，它要求服务器告诉您其版本号和当前日期。

```
mysql> SELECT VERSION(), CURRENT_DATE;
+-----------+--------------+
| VERSION() | CURRENT_DATE |
+-----------+--------------+
| 8.4.0-tr  | 2024-01-25   |
+-----------+--------------+
1 row in set (0.00 sec)

mysql>
```

此查询说明了有关 mysql 的几件事

- 查询通常由一个 SQL 语句和一个分号组成。（在某些情况下，可以省略分号。QUIT，前面提到过，就是其中之一。我们稍后会讨论其他情况。）

- 当您发出查询时，**mysql** 会将其发送到服务器执行并显示结果，然后打印另一个 **mysql>** 提示符，表示它已准备好进行另一个查询。

- **mysql** 以表格形式（行和列）显示查询输出。第一行包含列的标签。后面的行是查询结果。通常，列标签是您从数据库表中获取的列的名称。如果您要检索表达式的值而不是表列（如刚才的示例所示），**mysql** 会使用表达式本身标记该列。
- **mysql** 显示返回了多少行以及查询执行了多长时间，这使您可以粗略了解服务器性能。这些值并不精确，因为它们表示的是挂钟时间（而不是 CPU 或机器时间），并且它们会受到服务器负载和网络延迟等因素的影响。



#### 大小写不敏感

关键字可以用任何大小写输入。以下查询是等效的

```
mysql> SELECT VERSION(), CURRENT_DATE;
mysql> select version(), current_date;
mysql> SeLeCt vErSiOn(), current_DATE;
```



目前为止显示的查询都是相对较短的单行语句。您甚至可以在一行中输入多个语句。只需在每个语句后面加上一个分号

```
mysql> SELECT VERSION(); SELECT NOW();
+-----------+
| VERSION() |
+-----------+
| 8.4.0-tr  |
+-----------+
1 row in set (0.00 sec)

+---------------------+
| NOW()               |
+---------------------+
| 2024-01-25 18:33:04 |
+---------------------+
1 row in set (0.00 sec)
```



查询不必全部在一行中给出，因此需要多行的冗长查询也不是问题。

**mysql** 通过查找终止分号来确定语句的结束位置，而不是通过查找输入行的结尾。

以下是一个简单的多行语句：

```
mysql> SELECT
    -> USER()
    -> ,
    -> CURRENT_DATE;
+---------------+--------------+
| USER()        | CURRENT_DATE |
+---------------+--------------+
| jon@localhost | 2018-08-24   |
+---------------+--------------+
```



#### 多行语句

在此示例中，请注意在您输入多行查询的第一行后，提示符如何从 `mysql>` 更改为 `->`。

这就是 **mysql** 指示它尚未看到完整语句并正在等待其余部分的方式。

提示符提供了有价值的反馈。如果您使用该反馈，您始终可以知道 mysql 正在等待什么。

```
mysql> SELECT
    -> USER()
    -> \c
mysql>
```

在这里，还要注意提示符。在您键入 \c 后，它会切换回 mysql>，提供反馈以指示 **mysql** 已准备好进行新的查询。



#### 多行提示符

下表显示了您可能会看到的每个提示符，并总结了它们对 **mysql** 所处状态的含义。

| 提示符   | 含义                                            |
| -------- | ----------------------------------------------- |
| `mysql>` | 准备好进行新的查询                              |
| `->`     | 等待多行查询的下一行                            |
| `'>`     | 等待下一行，等待以单引号 (`'`) 开头的字符串完成 |
| `">`     | 等待下一行，等待以双引号 (`"`) 开头的字符串完成 |
| ``>`     | 等待下一行，等待以反引号 (```) 开头的标识符完成 |
| `/*>`    | 等待下一行，等待以 `/*` 开头的注释完成          |



#### `->` 提示符

当您打算在一行中发出查询但忘记了终止分号时，通常会意外出现多行语句。在这种情况下，**mysql** 会等待更多输入

```
mysql> SELECT USER()
    ->
```



如果这种情况发生在您身上（您认为您已经输入了一个语句，但唯一的响应是 -> 提示符），很可能是 **mysql** 正在等待分号。

如果您没有注意到提示符告诉您什么，您可能会在那里坐一会儿，然后才意识到您需要做什么。输入一个分号来完成语句，然后 **mysql** 将执行它：

```
mysql> SELECT USER()
    -> ;
+---------------+
| USER()        |
+---------------+
| jon@localhost |
+---------------+
```



#### `'>` 提示符

`'>` 和 `">` 提示符出现在字符串收集期间（另一种说法是 MySQL 正在等待字符串完成）。在 MySQL 中，您可以编写用 `'` 或 `"` 字符包围的字符串（例如，`'hello'` 或 `"goodbye"`）。

**mysql 允许您输入跨越多行的字符串**。当您看到 '> 或 "> 提示符时，表示您输入了一行包含以 ' 或 " 引号字符开头的字符串，但尚未输入终止该字符串的匹配引号。这通常表示您**无意中遗漏了一个引号字符**。例如

```
mysql> SELECT * FROM my_table WHERE name = 'Smith AND age < 30;
    '>
```



如果您输入此 **SELECT** 语句，然后按 Enter 键并等待结果，则什么也不会发生。与其想知道为什么此查询需要这么长时间，不如注意 '> 提示符提供的线索。

它告诉您 **mysql** 期望看到**未终止字符串的其余部分**。（您在语句中看到错误了吗？字符串 'Smith 缺少第二个单引号。）

发生这种情况，最简单的方法是取消查询。但是，在这种情况下，您不能只键入 `\c`，因为 mysql 会将其解释为正在收集的字符串的一部分。

应该输入结束引号字符（以便 **mysql** 知道您已经完成了字符串），然后键入 `\c`

```
mysql> SELECT * FROM my_table WHERE name = 'Smith AND age < 30;
    '> '\c
mysql>
```

提示符将更改回 mysql>，表示 **mysql** 已准备好进行新的查询。



``>` 提示符与 `'>` 和 `">` 提示符类似，但表示您已开始但尚未完成反引号括起来的标识符。

了解 `'>`、`">` 和 ``>` 提示符的含义非常重要，因为如果您错误地输入了未终止的字符串，您键入的任何后续行似乎都会被 **mysql** 忽略，包括包含 `QUIT` 的行。这可能会造成很大困扰，尤其是在您不知道需要先提供终止引号才能取消当前查询的情况下。



### 数据库

#### 查询和切换

**查询数据库列表**

使用 **SHOW** 语句找出当前服务器上存在哪些数据库

```
mysql> SHOW DATABASES;
+----------+
| Database |
+----------+
| mysql    |
| test     |
| tmp      |
+----------+
```

`mysql` 数据库描述用户访问权限。 `test` 数据库通常可用作用户试用事物的空间。

语句显示的数据库列表可能在你的机器上有所不同；如果你没有 SHOW DATABASES 权限，则 SHOW DATABASES 不会显示你没有权限访问的数据库。



**切换数据库**

使用 USE 语句可以切换数据库，尝试切换到 `test` 数据库

```
mysql> USE test
Database changed
```

`USE`，就像 `QUIT` 一样，不需要分号。（如果你愿意，可以使用分号来终止这些语句；不会造成任何危害。）`USE` 语句必须放在单行中。



你可以使用 `test` 数据库（如果你有权访问它）来进行以下示例，但任何你在该数据库中创建的内容都可以被任何其他有权访问该数据库的人删除。因此，你最好向 MySQL 管理员请求使用你自己的数据库的权限。假设你想把数据库命名为 `menagerie`。管理员需要执行类似于以下的语句

```
mysql> GRANT ALL ON menagerie.* TO 'your_mysql_name'@'your_client_host';
```

其中 `your_mysql_name` 是分配给你的 MySQL 用户名，`your_client_host` 是你连接到服务器的主机。



#### 创建数据库

创建数据库并命名为 menagerie

```
mysql> CREATE DATABASE menagerie;
```



在 Unix 下，数据库名称区分大小写（与 SQL 关键字不同），因此您必须始终将数据库称为 `menagerie`，而不是 `Menagerie`、`MENAGERIE` 或其他变体。表名也是如此。

在 Windows 下，此限制不适用，但您必须在给定查询中使用相同的字母大小写来引用数据库和表。但是，出于各种原因，建议的最佳做法始终是使用与创建数据库时相同的字母大小写。



创建数据库不会自动切换过去；您必须明确执行此操作。

```
mysql> USE menagerie
Database changed
```



您的数据库只需要创建一次，但每次开始 mysq 会话时都必须手动切换过去。

您可以在调用 mysql 时在命令行上选择数据库。只需在您可能需要提供的任何连接参数之后指定其名称即可。例如

```
$> mysql -h host -u user -p menagerie
Enter password: ********
```



#### 查看当前数据库

您可以随时使用 `SELECT DATABASE()` 查看当前选择了哪个数据库。

```
mysql> SELECT DATABASE();
+------------+
| DATABASE() 
+------------+
| mysql      |
+------------+
```



#### 创建表

在设计一个宠物数据库表时，核心思想是存储稳定、基础的信息而非动态变化的数据。这个名为 `pet` 的表应包含宠物的 `name`（名称）、`owner`（主人）、`species`（物种）和 `sex`（性别）。关键在于，不应直接存储 `age`（年龄），因为它会随时间变化而需要频繁更新。更优的方案是存储固定的 `birth`（出生日期），然后通过数据库的日期计算功能随时得出当前年龄。这种方法不仅简化了维护，还能轻松实现更多功能，例如，结合当前日期生成生日提醒，或是在有 `death`（死亡日期）记录的情况下计算宠物离世时的年龄。



使用 `CREATE TABLE` 语句来创建表。

```mysql
mysql> CREATE TABLE pet (name VARCHAR(20), owner VARCHAR(20),
       species VARCHAR(20), sex CHAR(1), birth DATE, death DATE);
```



VARCHAR 是 name、owner 和 species 列的良好选择，因为列值长度不同。这些列定义中的长度不必全部相同，也不必是 20。通常，您可以从 1 到 65535 中选择任何长度。如果您做出了错误的选择，并且后来发现您需要更长的字段，可以使用 `ALTER TABLE` 语句。

可以选择几种类型的值来表示动物记录中的性别，例如 `'m'` 和 `'f'`，或者可能是 `'male'` 和 `'female'`。使用单个字符 `'m'` 和 `'f'` 最简单。

使用 `DATE` 数据类型表示 **birth** 和 **death** 列是一个相当明显的选择。



####  查看表

创建表后，SHOW TABLES 应该产生一些输出

```
mysql> SHOW TABLES;
+---------------------+
| Tables in menagerie |
+---------------------+
| pet                 |
+---------------------+
```



#### 查看表结构

若要验证您的表是否按预期方式创建，请使用 DESCRIBE 语句

```
mysql> DESCRIBE pet;
+---------+-------------+------+-----+---------+-------+
| Field   | Type        | Null | Key | Default | Extra |
+---------+-------------+------+-----+---------+-------+
| name    | varchar(20) | YES  |     | NULL    |       |
| owner   | varchar(20) | YES  |     | NULL    |       |
| species | varchar(20) | YES  |     | NULL    |       |
| sex     | char(1)     | YES  |     | NULL    |       |
| birth   | date        | YES  |     | NULL    |       |
| death   | date        | YES  |     | NULL    |       |
+---------+-------------+------+-----+---------+-------+
```



#### 将数据加载到表中

创建表后，您需要填充它。可以使用 `LOAD DATA` 和 `INSERT` 语句。

假设您的宠物记录可以描述如下。

| 姓名     | 主人   | 物种 | 性别 | 出生日期   | 死亡日期   |
| -------- | ------ | ---- | ---- | ---------- | ---------- |
| Fluffy   | Harold | 猫   | 雌性 | 1993-02-04 |            |
| Claws    | Gwen   | 猫   | 雄性 | 1994-03-17 |            |
| Buffy    | Harold | 狗   | 雌性 | 1989-05-13 |            |
| Fang     | Benny  | 狗   | 雄性 | 1990-08-27 |            |
| Bowser   | Diane  | 狗   | 雄性 | 1979-08-31 | 1995-07-29 |
| Chirpy   | Gwen   | 鸟   | 雌性 | 1998-09-11 |            |
| Whistler | Gwen   | 鸟   |      | 1997-12-09 |            |
| Slim     | Benny  | 蛇   | 雄性 | 1996-04-29 |            |



因为您是从一个空表开始，所以填充它的一个简单方法是创建一个文本文件，其中包含每只动物的一行记录，然后使用一条语句将文件的内容加载到表中。

您可以创建一个文本文件 `pet.txt`，其中每行包含一条记录，值之间用制表符分隔，并按照 `CREATE TABLE`语句中列出的顺序给出。对于缺失值（例如未知性别或仍然存活的动物的死亡日期），您可以使用 `NULL` 值。要在文本文件中表示 NULL，请使用 `\N`（反斜杠，大写 N）。

例如，Whistler 这只鸟的记录如下所示（其中值之间的空白是一个制表符）

```
Whistler        Gwen    bird    \N      1997-12-09      \N
```



要将文本文件 `pet.txt` 加载到 `pet` 表中，请使用以下语句

```
mysql> LOAD DATA LOCAL INFILE '/path/pet.txt' INTO TABLE pet;
```



如果您在 Windows 上使用以 `\r\n` 作为行终止符的编辑器创建了该文件，则应改用以下语句

```
mysql> LOAD DATA LOCAL INFILE '/path/pet.txt' INTO TABLE pet
       LINES TERMINATED BY '\r\n';
```

（在运行 macOS 的 Apple 机器上，您可能希望使用 `LINES TERMINATED BY '\r'`。）

如果您愿意，可以在 `LOAD DATA` 语句中明确指定列值分隔符和行尾标记，但默认值为制表符和换行符。这些足以使语句正确读取文件 pet.txt。

如果语句失败，则可能是您的 MySQL 安装默认情况下未启用本地文件功能。



当您想一次添加一条新记录时，`INSERT` 语句很有用。在最简单的形式中，您需要为每个列提供值，顺序与 `CREATE TABLE` 语句中列出的顺序相同。

假设 Diane 得到了一只名为 “Puffball” 的新仓鼠。您可以使用如下所示的 `INSERT` 语句添加新记录

```
mysql> INSERT INTO pet
       VALUES ('Puffball','Diane','hamster','f','1999-03-30',NULL);
```

字符串和日期值在此处指定为带引号的字符串。此外，使用 `INSERT`，您可以直接插入 **NULL** 来表示缺失值。您不需要像使用 `LOAD DATA` 那样使用 \N。



#### 从表中检索信息

`SELECT` 语句用于从表中提取信息。该语句的一般形式为

```
SELECT what_to_select
FROM which_table
WHERE conditions_to_satisfy;
```

*`what_to_select`* 指示您要查看的内容。这可以是列列表，也可以是 `*`，表示“所有列”。*`which_table`* 指示您要从中检索数据的表。`WHERE` 子句是可选的。如果存在，*`conditions_to_satisfy`* 指定行必须满足的一个或多个条件才能被检索。



#### 检索所有数据

最简单的形式 SELECT 从表中检索所有内容：

```
mysql> SELECT * FROM pet;
+----------+--------+---------+------+------------+------------+
| name     | owner  | species | sex  | birth      | death      |
+----------+--------+---------+------+------------+------------+
| Fluffy   | Harold | cat     | f    | 1993-02-04 | NULL       |
| Claws    | Gwen   | cat     | m    | 1994-03-17 | NULL       |
| Buffy    | Harold | dog     | f    | 1989-05-13 | NULL       |
| Fang     | Benny  | dog     | m    | 1990-08-27 | NULL       |
| Bowser   | Diane  | dog     | m    | 1979-08-31 | 1995-07-29 |
| Chirpy   | Gwen   | bird    | f    | 1998-09-11 | NULL       |
| Whistler | Gwen   | bird    | NULL | 1997-12-09 | NULL       |
| Slim     | Benny  | snake   | m    | 1996-04-29 | NULL       |
| Puffball | Diane  | hamster | f    | 1999-03-30 | NULL       |
+----------+--------+---------+------+------------+------------+
```

这种形式的 **SELECT** 使用 `*`，它是 “选择所有列” 的简写。如果您想查看整个表，例如，在您刚用初始数据集加载完表后，这将很有用。

**`SELECT *` 选择所有列的原则有一个例外。如果表包含不可见的列，`*` 不包含它们。**



假设，您可能会认为 Bowser 的出生日期似乎不太正确。查阅您的原始家谱文件后，您发现正确的出生年份应该是 1989 年，而不是 1979 年。

编辑文件 pet.txt 以更正错误，然后使用 `DELETE` 和 `LOAD DATA` 清空表并重新加载它：

```
mysql> DELETE FROM pet;
mysql> LOAD DATA LOCAL INFILE 'pet.txt' INTO TABLE pet;
```



仅使用 `UPDATE` 语句更正错误的记录

```
mysql> UPDATE pet SET birth = '1989-08-31' WHERE name = 'Bowser';
```

该 `UPDATE` 仅更改相关记录，而不必重新加载表。



#### 检索特定行

您可以只从表中选择特定的行。例如，如果您想验证您对 Bowser 出生日期所做的更改，请像这样选择 Bowser 的记录：

```
mysql> SELECT * FROM pet WHERE name = 'Bowser';
+--------+-------+---------+------+------------+------------+
| name   | owner | species | sex  | birth      | death      |
+--------+-------+---------+------+------------+------------+
| Bowser | Diane | dog     | m    | 1989-08-31 | 1995-07-29 |
+--------+-------+---------+------+------------+------------+
```

输出确认年份正确记录为 1989 年，而不是 1979 年。

字符串比较通常不区分大小写，因此您可以将名称指定为 `'bowser'`、`'BOWSER'` 等。查询结果是相同的。



您可以在任何列上指定条件，而不仅仅是 `name` 列。

例如，如果您想知道哪些动物出生于 1998 年或之后，请测试 `birth` 列

```
mysql> SELECT * FROM pet WHERE birth >= '1998-1-1';
+----------+-------+---------+------+------------+-------+
| name     | owner | species | sex  | birth      | death |
+----------+-------+---------+------+------------+-------+
| Chirpy   | Gwen  | bird    | f    | 1998-09-11 | NULL  |
| Puffball | Diane | hamster | f    | 1999-03-30 | NULL  |
+----------+-------+---------+------+------------+-------+
```



您可以组合条件，例如，找到雌性犬

```
mysql> SELECT * FROM pet WHERE species = 'dog' AND sex = 'f';
+-------+--------+---------+------+------------+-------+
| name  | owner  | species | sex  | birth      | death |
+-------+--------+---------+------+------------+-------+
| Buffy | Harold | dog     | f    | 1989-05-13 | NULL  |
+-------+--------+---------+------+------------+-------+
```



前面的查询使用了 `AND` 逻辑运算符。还有一个 `OR` 运算符

```
mysql> SELECT * FROM pet WHERE species = 'snake' OR species = 'bird';
+----------+-------+---------+------+------------+-------+
| name     | owner | species | sex  | birth      | death |
+----------+-------+---------+------+------------+-------+
| Chirpy   | Gwen  | bird    | f    | 1998-09-11 | NULL  |
| Whistler | Gwen  | bird    | NULL | 1997-12-09 | NULL  |
| Slim     | Benny | snake   | m    | 1996-04-29 | NULL  |
+----------+-------+---------+------+------------+-------+
```



`AND` 和 `OR` 可以混合使用，尽管 `AND` 的优先级高于 `OR`。

如果同时使用这两个运算符，最好使用括号明确指示条件应该如何分组

```
mysql> SELECT * FROM pet WHERE (species = 'cat' AND sex = 'm')
    -> OR (species = 'dog' AND sex = 'f');
+-------+--------+---------+------+------------+-------+
| name  | owner  | species | sex  | birth      | death |
+-------+--------+---------+------+------------+-------+
| Claws | Gwen   | cat     | m    | 1994-03-17 | NULL  |
| Buffy | Harold | dog     | f    | 1989-05-13 | NULL  |
+-------+--------+---------+------+------------+-------+
```



#### 检索特定列

如果您不想查看来自表的整行，只需列出您感兴趣的列，用逗号分隔。

例如，如果您想知道您的动物何时出生，请选择 `name` 和 `birth` 列

```
mysql> SELECT name, birth FROM pet;
+----------+------------+
| name     | birth      |
+----------+------------+
| Fluffy   | 1993-02-04 |
| Claws    | 1994-03-17 |
| Buffy    | 1989-05-13 |
| Fang     | 1990-08-27 |
| Bowser   | 1989-08-31 |
| Chirpy   | 1998-09-11 |
| Whistler | 1997-12-09 |
| Slim     | 1996-04-29 |
| Puffball | 1999-03-30 |
+----------+------------+
```



要找出谁拥有宠物，请使用此查询

```
mysql> SELECT owner FROM pet;
+--------+
| owner  |
+--------+
| Harold |
| Gwen   |
| Harold |
| Benny  |
| Diane  |
| Gwen   |
| Gwen   |
| Benny  |
| Diane  |
+--------+
```



请注意，该查询只是从每条记录中检索 `owner` 列，其中一些列出现不止一次。

为了最小化输出，通过添加关键字 `DISTINCT` 仅检索每个唯一的输出记录一次

```
mysql> SELECT DISTINCT owner FROM pet;
+--------+
| owner  |
+--------+
| Benny  |
| Diane  |
| Gwen   |
| Harold |
+--------+
```



您可以使用 `WHERE` 子句将行选择与列选择结合起来。

例如，要获取仅限于狗和猫的出生日期，请使用此查询

```
mysql> SELECT name, species, birth FROM pet
    -> WHERE species = 'dog' OR species = 'cat';
+--------+---------+------------+
| name   | species | birth      |
+--------+---------+------------+
| Fluffy | cat     | 1993-02-04 |
| Claws  | cat     | 1994-03-17 |
| Buffy  | dog     | 1989-05-13 |
| Fang   | dog     | 1990-08-27 |
| Bowser | dog     | 1989-08-31 |
+--------+---------+------------+
```



#### 对行排序

`ORDER BY` 子句用于让行按某种有意义的方式排序。

以下是按日期排序的动物生日

```mysql
mysql> SELECT name, birth FROM pet ORDER BY birth;
+----------+------------+
| name     | birth      |
+----------+------------+
| Buffy    | 1989-05-13 |
| Bowser   | 1989-08-31 |
| Fang     | 1990-08-27 |
| Fluffy   | 1993-02-04 |
| Claws    | 1994-03-17 |
| Slim     | 1996-04-29 |
| Whistler | 1997-12-09 |
| Chirpy   | 1998-09-11 |
| Puffball | 1999-03-30 |
+----------+------------+
```

在字符类型列上，排序（像所有其他比较操作一样）通常以不区分大小写的方式执行。

这意味着对于除大小写外完全相同的列，顺序是不定义的。您可以通过像这样使用 `BINARY` 来强制对列进行区分大小写的排序：`ORDER BY BINARY col_name`。



默认排序顺序是升序，最小的值排在最前面。要在相反（降序）顺序中排序，请将 `DESC` 关键字添加到要排序的列的名称中：

```sql
mysql> SELECT name, birth FROM pet ORDER BY birth DESC;
+----------+------------+
| name     | birth      |
+----------+------------+
| Puffball | 1999-03-30 |
| Chirpy   | 1998-09-11 |
| Whistler | 1997-12-09 |
| Slim     | 1996-04-29 |
| Claws    | 1994-03-17 |
| Fluffy   | 1993-02-04 |
| Fang     | 1990-08-27 |
| Bowser   | 1989-08-31 |
| Buffy    | 1989-05-13 |
+----------+------------+
```



#### 日期计算

MySQL 提供了多个函数，您可以使用这些函数对日期执行计算，例如，计算年龄或提取日期的各个部分。

要确定您的每只宠物的年龄，请使用 `TIMESTAMPDIFF()` 函数。它的参数是您希望结果以其表达的单位以及要计算差值的两个日期。以下查询显示了每个宠物的出生日期、当前日期和年龄（以年为单位）。使用了 *别名* (`age`) 使最终输出列标签更有意义。

```
mysql> SELECT name, birth, CURDATE(),
       TIMESTAMPDIFF(YEAR,birth,CURDATE()) AS age
       FROM pet;
+----------+------------+------------+------+
| name     | birth      | CURDATE()  | age  |
+----------+------------+------------+------+
| Fluffy   | 1993-02-04 | 2003-08-19 |   10 |
| Claws    | 1994-03-17 | 2003-08-19 |    9 |
| Buffy    | 1989-05-13 | 2003-08-19 |   14 |
| Fang     | 1990-08-27 | 2003-08-19 |   12 |
| Bowser   | 1989-08-31 | 2003-08-19 |   13 |
| Chirpy   | 1998-09-11 | 2003-08-19 |    4 |
| Whistler | 1997-12-09 | 2003-08-19 |    5 |
| Slim     | 1996-04-29 | 2003-08-19 |    7 |
| Puffball | 1999-03-30 | 2003-08-19 |    4 |
+----------+------------+------------+------+
```



此查询可以正常工作，但如果以某种顺序显示行，则结果将更容易理解。

要按 `age` 排序输出。

```sql
mysql> SELECT name, birth, CURDATE(),
       TIMESTAMPDIFF(YEAR,birth,CURDATE()) AS age
       FROM pet ORDER BY age;
+----------+------------+------------+------+
| name     | birth      | CURDATE()  | age  |
+----------+------------+------------+------+
| Chirpy   | 1998-09-11 | 2003-08-19 |    4 |
| Puffball | 1999-03-30 | 2003-08-19 |    4 |
| Whistler | 1997-12-09 | 2003-08-19 |    5 |
| Slim     | 1996-04-29 | 2003-08-19 |    7 |
| Claws    | 1994-03-17 | 2003-08-19 |    9 |
| Fluffy   | 1993-02-04 | 2003-08-19 |   10 |
| Fang     | 1990-08-27 | 2003-08-19 |   12 |
| Bowser   | 1989-08-31 | 2003-08-19 |   13 |
| Buffy    | 1989-05-13 | 2003-08-19 |   14 |
+----------+------------+------------+------+
```



类似的查询可用于确定已死亡动物的死亡年龄。

您可以通过检查 `death` 值是否为 `NULL` 来确定哪些动物已死亡。然后，对于那些具有非 `NULL` 值的动物，计算 `death` 和 `birth` 值之间的差值。

```sql
mysql> SELECT name, birth, death,
       TIMESTAMPDIFF(YEAR,birth,death) AS age
       FROM pet WHERE death IS NOT NULL ORDER BY age;
+--------+------------+------------+------+
| name   | birth      | death      | age  |
+--------+------------+------------+------+
| Bowser | 1989-08-31 | 1995-07-29 |    5 |
+--------+------------+------------+------+
```

此查询使用 `death IS NOT NULL` 而不是 `death <> NULL`，因为 `NULL` 是一个特殊值，不能使用常规比较运算符进行比较。



计算哪些动物将在下个月过生日。对于这种类型的计算，年和日无关紧要；您只需要提取 `birth` 列的月份部分。

MySQL 提供了多个函数用于提取日期的各个部分，例如 `YEAR()`、`MONTH()` 和 `DAYOFMONTH()`。在这里，`MONTH()` 是合适的函数。

```sql
mysql> SELECT name, birth, MONTH(birth) FROM pet;
+----------+------------+--------------+
| name     | birth      | MONTH(birth) |
+----------+------------+--------------+
| Fluffy   | 1993-02-04 |            2 |
| Claws    | 1994-03-17 |            3 |
| Buffy    | 1989-05-13 |            5 |
| Fang     | 1990-08-27 |            8 |
| Bowser   | 1989-08-31 |            8 |
| Chirpy   | 1998-09-11 |            9 |
| Whistler | 1997-12-09 |           12 |
| Slim     | 1996-04-29 |            4 |
| Puffball | 1999-03-30 |            3 |
+----------+------------+--------------+
```



查找在下个月过生日的动物也很简单。假设当前月份为 4 月。然后月份值为 `4`，您可以查找出生于 5 月（月份 `5`）的动物，如下所示。

```sql
mysql> SELECT name, birth FROM pet WHERE MONTH(birth) = 5;
+-------+------------+
| name  | birth      |
+-------+------------+
| Buffy | 1989-05-13 |
+-------+------------+
```



如果当前月份为 12 月，则会出现一个小问题。您不能简单地将月份数 (`12`) 加 1，然后查找出生于月份 `13` 的动物，因为不存在这样的月份。相反，您需要查找出生于 1 月（月份 `1`）的动物。

您可以编写查询，使其无论当前月份是什么都能正常工作，因此您不必使用特定月份的数字。 `DATE_ADD()` 使您能够将时间间隔添加到给定日期。如果您将一个月添加到 `CURDATE()` 的值中，然后使用 `MONTH()` 提取月份部分，结果将生成要查找生日的月份。

```sql
mysql> SELECT name, birth FROM pet
       WHERE MONTH(birth) = MONTH(DATE_ADD(CURDATE(),INTERVAL 1 MONTH));
```



完成相同任务的另一种方法是在使用模运算符 (`MOD`) 将月份值包装到 `0`（如果当前为 `12`）后，加 1 以获得当前月份后的下一个月份。

```sql
mysql> SELECT name, birth FROM pet
       WHERE MONTH(birth) = MOD(MONTH(CURDATE()), 12) + 1;
```



 `MONTH()` 返回 1 到 12 之间的数字。而 `MOD(something,12)` 返回 0 到 11 之间的数字。因此，加法必须在 `MOD()` 之后，否则我们将从 11 月 (11) 变为 1 月 (1)。

如果计算使用无效日期，则计算将失败并产生警告。

```sql
mysql> SELECT '2018-10-31' + INTERVAL 1 DAY;
+-------------------------------+
| '2018-10-31' + INTERVAL 1 DAY |
+-------------------------------+
| 2018-11-01                    |
+-------------------------------+

mysql> SELECT '2018-10-32' + INTERVAL 1 DAY;
+-------------------------------+
| '2018-10-32' + INTERVAL 1 DAY |
+-------------------------------+
| NULL                          |
+-------------------------------+

mysql> SHOW WARNINGS
+---------+------+----------------------------------------+
| Level   | Code | Message                                |
+---------+------+----------------------------------------+
| Warning | 1292 | Incorrect datetime value: '2018-10-32' |
+---------+------+----------------------------------------+
```



#### 处理 NULL 值

从概念上讲，`NULL` 表示 “缺少的未知值”，并且它的处理方式与其他值略有不同。

要测试 `NULL`，请使用 `IS NULL` 和 `IS NOT NULL` 运算符，如下所示：

```
mysql> SELECT 1 IS NULL, 1 IS NOT NULL;
+-----------+---------------+
| 1 IS NULL | 1 IS NOT NULL |
+-----------+---------------+
|         0 |             1 |
+-----------+---------------+
```



与 NULL 进行算术比较的结果均为 NULL，不要使用 `=`、`<` 或 `<>` 等算术比较运算符来测试 NULL 值。

```
mysql> SELECT 1 = NULL, 1 <> NULL, 1 < NULL, 1 > NULL;
+----------+-----------+----------+----------+
| 1 = NULL | 1 <> NULL | 1 < NULL | 1 > NULL |
+----------+-----------+----------+----------+
|     NULL |      NULL |     NULL |     NULL |
+----------+-----------+----------+----------+
```



在 MySQL 中，`0` 或 `NULL` 表示 false，而其他任何值都表示 true。布尔运算的默认真值为 `1`。

`NULL` 的这种特殊处理方式解释了为什么在上一节中，需要使用 `death IS NOT NULL` 而不是 `death <> NULL` 来确定哪些动物不再存活。

在 `GROUP BY` 中，两个 `NULL` 值被视为相等。

执行 `ORDER BY` 时，如果执行 `ORDER BY ... ASC`，则 `NULL` 值将首先显示；如果执行 `ORDER BY ... DESC`，则 `NULL` 值将最后显示。



使用 **NULL** 时，一个常见的错误是**误认为空值或空字符串 ('') 与 NULL 相同**。然而事实并非如此。**NULL** 在 SQL 中表示**“没有值”或“缺少值”**，而空字符串 ('') 是一个**实际的值**。

您可以使用 **IS NULL** 或 **IS NOT NULL** 轻松地区分它们，如下所示：

```sql
mysql> SELECT 0 IS NULL, 0 IS NOT NULL, '' IS NULL, '' IS NOT NULL;
+-------------+---------------+------------+----------------+
| 0 IS NULL   | 0 IS NOT NULL | '' IS NULL | '' IS NOT NULL |
+-------------+---------------+------------+----------------+
|           0 |             1 |          0 |              1 |
+-------------+---------------+------------+----------------+
```

**空值（NULL）或空字符串（''）都可以插入到被定义为 NOT NULL 的列中。**



