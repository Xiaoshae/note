# Sed

`sed` 是 Linux/Unix 系统中一个非常强大且必备的文本处理工具。

`sed` 的全称是 **Stream Editor**（流编辑器）。它的核心思想是：**一次读取一行，处理一行，输出一行**。

它会从输入流（文件、管道等）中读取文本，将每一行放入一个称为“**模式空间**”（Pattern Space）的内存缓冲区。然后，`sed` 会在“模式空间”上执行你提供的脚本命令（比如替换、删除、插入）。处理完成后，默认情况下它会将“模式空间”的内容打印到标准输出，然后清空“模式空间”，接着读取下一行，重复这个过程。

除非你使用 `-i` 选项，否则 `sed` **不会修改原始文件**，它只是将处理结果输出到标准输出。



## 脚本

### 指定多个脚本

当你使用多个 `-e` 或 `-f` 选项时，`sed` 会在**开始处理任何输入之前**，按照你在**命令行上提供的顺序**，把所有这些脚本“拼接”起来，形成一个单一的、逻辑上的“大脚本”。



第一个脚本（非文件，使用 `-e` 参数指定）：`s/a/b/g`

第二个脚本（一个脚本文件 `script.sed`），内容为：

```
s/b/c/g
s/c/d/g
```

第三个脚本（非文件，使用 `-e` 参数指定）：`s/d/e/g`



如果你这样执行命令： `sed -e 's/a/b/g' -f script.sed -e 's/d/e/g' input.txt`

`sed` 在内存中构建的“合并后脚本”看起来就是这样的：

```
#--- 来自第一个 -e ---
s/a/b/g
#--- 来自 -f script.sed 的内容 (按文件顺序) ---
s/b/c/g
s/c/d/g
#--- 来自第二个 -e ---
s/d/e/g
```



### 多条语句的执行流程 

`sed` 的**核心工作循环**，这个流程会**对输入的每一行**都完整地跑一遍：

1. **读入（Read）：** `sed` 从输入源（文件或管道）读取**一行**，并将其放入一个叫做**“模式空间” (Pattern Space)** 的内部缓冲区。
2. **执行（Execute）：** `sed` 开始执行它那个“合并后的大脚本”。
3. - `sed` 会从“大脚本”的**第一条语句**开始。
   - 它用第一条语句的**[地址部分]**去匹配“模式空间”中的内容。
   - 如果匹配成功（或者没有地址，= 默认匹配），`sed` 就在“模式空间”上**执行该语句的[命令部分]**。
   - **关键：** 此时，“模式空间”的内容**可能已经被修改了**。
   - 然后，`sed` **立刻**拿起“大脚本”的**第二条语句**。
   - 它用第二条语句的**[地址部分]**去匹配“模式空间”**当前（可能已被修改）**的内容。
   - 如果匹配，就执行命令...
   - `sed` 会**依次、顺序地**用脚本中的**每一条**语句，去操作**同一个**“模式空间”。
4. **打印（Print）：** 当“大脚本”中的**所有语句**都针对这一行执行完毕后，`sed` 默认会打印“模式空间”中**最终**的内容到标准输出。（除非你用了 `-n` 选项）。
5. **清空（Clear）：** `sed` 丢弃“模式空间”中的内容。
6. **重复（Repeat）：** `sed` 回到步骤 1，去读取输入的**下一行**，直到所有行都处理完毕。



### 脚本结构

一个 `sed` 脚本（无论是写在 `-e '...'` 里还是 `-f script.sed` 文件里）在 `sed` 眼里的结构如下面所示。



#### **级别 1：脚本 (Script)**

一个脚本由一个或多个**语句 (Statement)** 组成。

- `语句_1`
- `语句_2`
- `语句_3`



#### **级别 2：分隔符 (Separator)**

分隔符 (Separator) 是 `sed` 用于在脚本中区分**上一条“语句”的结束**和**下一条“语句”的开始**。



**换行符 (`\n`)**： 这是最主要的分隔符。在 `-f script.sed` 文件中，每一行通常就是一个完整的语句。

```
/ERROR/d
/WARN/d
```



**分号 (`;`)**： 当你想在**一行内**编写多个语句时使用。

```
/ERROR/d ; /WARN/d
```

**注意：** 有些命令（如 `a`, `i`, `c`, `r`, `#`）会“吃掉”直到行尾的所有内容，它们后面不能跟分号。



#### **级别 3：语句 (Statement)**

这是最核心的颗粒度。**每一个“语句”**都由 **`[地址部分]`** 和 **`[命令部分]`** 组成。

```
[地址部分][命令部分]
```



#### **级别 4a：[地址部分] 的最小颗粒度**

[地址部分] 是可选的，但如果存在，它可以是以下几种形态：



**1. 空地址 (Zero Address)**：

- 就是**什么都不写**。
- 含义：应用于所有行。



**2. 单地址 (One Address)**：

**`行号`**：一个数字。例如 `10`。

**`最终行`**：一个美元符号 `$`。

**`正则表达式`**：

- **`分隔符_1`** (通常是 `/`)
- **`正则内容`** (例如 `^ERROR`)
- **`分隔符_2`** (必须和 `_1` 相同)



**分隔符**不一定必须为 `/` ，只是在 sed 命令中，通常是将 `/` 符号作为分隔符。



在以下示例中，将 `/` 符号作为分隔符：

```
# cat test
aaa bbb ccc 111 222 333

# cat test | sed 's/111/999/'
aaa bbb ccc 999 222 333
```



你可以将任意字符（除换行符）作为分隔符，例如在以下示例中，将字符 `5` 作为换行符。

```
# cat test
aaa bbb ccc 111 222 333

# cat test | sed 's511159995'
aaa bbb ccc 999 222 333
```



如果你要在**两个换行符的中间**使用**换行符**，则需要在该字符前添加反斜杠 `\` 字符

```
# cat test
aaa bbb ccc 111 222 333

# cat test | sed 's1\1\1\119991'
aaa bbb ccc 999 222 333
```

使用下划线标记的字符 `1` 为分隔符：**'s<u>1</u>\1\1\1<u>1</u>999<u>1</u>'**



如果你使用**反斜杠作为分隔符**，则在两个分隔符之间**不能使用反斜杠作为字符**。



**3. 地址范围 (Two Addresses)**：

**`单地址_1`** (见上)

**`逗号分隔符 ,`**

**`单地址_2`** (见上)

**GNU 特殊范围：** `0,addr2` | `addr1,+N` | `addr1,~N`



**4. 地址取反 (Negation)**：

`地址`（可以是单地址或范围）

**`感叹号 !`**

这个 `!` 会跟在整个 `[地址部分]` 的最后（但在 `[命令部分]` 之前）。



#### 级别 4b：[命令部分] 的最小颗粒度

`[命令部分]` **没有统一的语法**。**每种命令都有自己的“子语法”**。你不能把 `s` 命令的语法（带标志）套用到 `d` 命令（无参数）上。



**1. 简单命令 (无参数)**

**`命令字符`**：就是一个字符。

例如：`d`, `p` (打印), `n` (下一行), `q` (退出), `g` (Get), `G` (Append Get), `h` (Hold), `H` (Append Hold), `x` (Exchange), `l` (List), `P` (Print First Line), `D` (Delete First Line), `N` (Append Next), `=` (Print Line Number)。

简单命令直接没有参数，直接在地址部分后面，示例：

```
cat file | sed '1d'
```



**2. 替换命令 (S - 它拥有最复杂的“子语法”)**

**`命令字符`**：`s`

**`分隔符_1`** (任意非换行符，例如 `/`)

**`参数1: 正则表达式`**

**`分隔符_2`** (同 `_1`)

**`参数2: 替换字符串`** (它**自己**还有子语法，如 `&` 代表匹配项, `\1` 代表捕获组, `\L` `\U` 做大小写转换)

**`分隔符_3`** (同 `_1`)

**`参数3: 标志字符串`** (这才是你问的“标志”)

- 这个字符串可以是 `g` (全局), `i` (忽略大小写), `p` (打印), `N` (数字，只替换第 N 个)
- **最特殊的标志：`w filename`**
  - `w` 标志**自己还带一个参数**（文件名）。



**3. 命令块 (Grouping)**

- `{` 和 `}` 它们本身在技术上也是“命令”。
- `{` 后面必须跟一个**分隔符**（换行或 `;`）。
- `}` 前面必须有一个**分隔符**（换行或 `;`）。
- 它们允许你对**同一个地址**应用**多条语句**。



## 地址部分语法

`sed` 命令可以根据地址的有无，分为三种执行模式：

1. **无地址：** 如果没有提供地址，那么指定的命令将对所有输入的行执行。
2. **单地址：** 如果提供一个地址，命令将只对匹配该地址的输入行执行。
3. **双地址 (地址范围)：** 如果提供**两个单地址**（`addr1,addr2`），命令将对这个“包容性”范围内的所有行执行。
   - 范围从匹配 `addr1` 的行开始。
   - 范围到匹配 `addr2` 的行结束。



### 地址类型

`sed` 支持以下几种类型的地址：



#### `number` (行号)

这是最直接的地址类型。你提供一个具体的数字，`sed` 就会匹配输入流中的那一行。



**示例 1：** 删除第 3 行。

```
sed '3d' filename.txt
```

`3` 是地址。

`d` 是命令（delete）。



**示例 2：** 在第 5 行前插入文本 "--- HEADER ---"。

```
sed '5i \--- HEADER ---' filename.txt
```

`5` 是地址。

`i` 是命令（insert）。



#### `$` (最后一行)

`$` 符号是一个特殊的地址，它总是匹配输入流的**最后一行**。这在你不知道文件总共有多少行，但又想对最后一行进行操作时非常有用。



**示例 1：** 仅打印最后一行（`-n` 会抑制自动打印，`p` 只打印匹配到的行）。

```
sed -n '$p' filename.txt
```



**示例 2：** 在文件的最后一行（`$`）之后追加（`a`）一行新文本。

```
sed '$a \This is the very end.' filename.txt
```



**示例 3（地址范围）：** 打印从第 10 行到最后一行的所有内容。

```
sed -n '10,$p' filename.txt
```



#### `/regexp/` (正则表达式)

这是 `sed` 中最强大、最常用的一种地址类型。它会匹配**任何内容符合指定正则表达式 (`regexp`) 的行**。

**分隔符：** 默认情况下，正则表达式必须用一对斜杠 `/` 包围。



**示例 1：** 删除所有包含 "error" 字符串的行。

```
sed '/error/d' logfile.txt
```



**示例 2：** 打印所有以 "Warning:" 开头的行（`^` 是正则表达式中表示“行首”的锚点）。

```
sed -n '/^Warning:/p' logfile.txt
```



**示例 3（地址范围）：** 打印从第一个匹配 "START" 的行开始，到第一个匹配 "END" 的行结束的所有行。

```
sed -n '/START/,/END/p' filename.txt
```



#### `\cregexpc` (自定义分隔符)

当你的正则表达式**本身就包含斜杠 `/`** 时，使用 `/regexp/` 语法会变得非常麻烦，因为你需要对每一个 `/` 进行转义（写成 `\/`）。

这种形式功能上与 `/regexp/` 完全相同，但它允许你使用**自定义的分隔符**。

**语法：** 以反斜杠 `\` 开头，后面跟一个字符 `c`，这个 `c` 就是你的新分隔符。然后是正则表达式 `regexp`，最后再以 `c` 结尾。



**对比示例：** 假设你要匹配包含路径 `/usr/bin` 的行。

**使用 `/` 作为分隔符 (可读性差)：**

```
sed '/\/usr\/bin/d' filename.txt
```



**使用 `\` 和 `c` (可读性高)：** 我们可以选择一个路径中没有的字符，比如 `#` 或 `|`。

```
sed '\#/usr/bin#d' filename.txt
# 或者
sed '\|/usr/bin|d' filename.txt
```

(这样，正则表达式 `/usr/bin` 就不再需要任何转义，更易读写。)



#### `first~step` (GNU 扩展)

这是一种 GNU `sed` 特有的地址类型（在标准的 POSIX `sed` 或 macOS/BSD 上的 `sed` 可能不支持），用于匹配**周期性的行**。

- **`first`：** 你希望开始匹配的第一行行号。
- **`~`：** 固定分隔符。
- **`step`：** 匹配的间隔（步长）。



它会匹配第 `first` 行，然后匹配第 `first + step` 行，接着匹配第 `first + 2*step` 行，以此类推。



**示例 1：`1~2` (所有奇数行)**

`first=1`, `step=2`

匹配：

- 第 1 行
- 第 `1 + 2 = 3` 行
- 第 `3 + 2 = 5` 行
- ... 以此类推 (1, 3, 5, 7...)



打印所有奇数行

```
sed -n '1~2p' filename.txt`
```



**示例 2：`2~2` (所有偶数行)**

`first=2`, `step=2`

匹配：

- 第 2 行
- 第 `2 + 2 = 4` 行
- 第 `4 + 2 = 6` 行
- ... 以此类推 (2, 4, 6, 8...)



删除所有偶数行

```
sed '2~2d' filename.txt
```



**示例 3：`2~5` (从第 2 行开始，每 5 行匹配一次)**

`first=2`, `step=5`

匹配：

- 第 2 行
- 第 `2 + 5 = 7` 行
- 第 `7 + 5 = 12` 行
- ... 以此类推 (2, 7, 12, 17...)



**示例 4： `0~step`：**

- 如 man page 所述，`0~step` 被视为等同于 `step~step`。
- 例如，`0~3` 和 `3~3` 效果相同，都会匹配第 3、6、9、12... 行（即所有 3 的倍数行）。



### 地址范围 (addr1,addr2)

**语法：** 两个地址使用逗号分隔，即 `addr1,addr2`。

**匹配规则：**

- 匹配 `addr1` 的那一行总是会被接受并执行命令。
- 即使 `addr2` 匹配了比 `addr1` 更靠前的行，范围也会在 `addr1` 匹配时立即开始。
- 如果 `addr2` 是一个正则表达式，`sed` 不会用它去测试 `addr1` 匹配的那一行。



为了清晰地展示这些特性，我们将使用一个名为 `data.txt` 的示例文件：

```
1: apple
2: banana
3: START_BLOCK
4: grape
5: orange
6: END_BLOCK
7: pear
8: plum
9: START_BLOCK
10: kiwi
11: mango
12: END_BLOCK
```

下面的示例中，我们将主要使用 p (print) 命令，并配合 -n (quiet) 选项。-n 会抑制 sed 的默认输出（即不打印任何行），而 p 命令则会强制 sed 打印出匹配地址的行。



**示例 1：使用行号**

匹配第 2 行到第 5 行。

**命令：**

```
sed -n '2,5p' data.txt
```

**输出：**

```
2: banana
3: START_BLOCK
4: grape
5: orange
```

**解释：** `addr1` 是 `2`，`addr2` 是 `5`。`sed` 打印 2、3、4、5 行。



**示例 2：使用正则表达式**

匹配从包含 "START_BLOCK" 的行开始，到包含 "END_BLOCK" 的行结束的所有行。

**命令：**

```
sed -n '/START_BLOCK/,/END_BLOCK/p' data.txt
```

**输出：**

```
3: START_BLOCK
4: grape
5: orange
6: END_BLOCK
9: START_BLOCK
10: kiwi
11: mango
12: END_BLOCK
```

`sed` 在第 3 行匹配到 `addr1` (`/START_BLOCK/`)，开始打印。它继续打印后续的 4、5 行，直到在第 6 行匹配到 `addr2` (`/END_BLOCK/`)。打印第 6 行后，范围结束。`sed` 继续向下查找，在第 9 行再次匹配到 `addr1`，于是重复上述过程，直到第 12 行。



**示例 3：演示 `addr2` 不会测试 `addr1` 匹配的行**

这个特性比较微妙。如果 `addr1` 和 `addr2` 匹配了同一行，范围会如何表现？

让我们使用一个新文件 `data2.txt`：

```
1: apple
2: START_AND_END
3: banana
4: END_BLOCK
```

**命令：**

```
sed -n '/START/,/END/p' data2.txt
```

**输出：**

```
2: START_AND_END
3: banana
4: END_BLOCK
```

**解释：**

1. `sed` 在第 2 行匹配到 `addr1` (`/START/`)。根据规则“`addr1` 匹配的那一行总是会被接受”，第 2 行被打印。
2. 根据规则“如果 `addr2` 是一个正则表达式，sed 不会用它去测试 `addr1` 匹配的那一行”，`sed` **不会**在第 2 行检查 `addr2` (`/END/`)。此时范围已经*打开*。
3. `sed` 处理第 3 行，它仍在范围内，所以打印第 3 行。
4. `sed` 处理第 4 行，它匹配了 `addr2` (`/END_BLOCK/`)。打印第 4 行，范围*关闭*。

注：





#### 特殊的双地址形式 (GNU 扩展)

GNU `sed` 还支持几种特殊的地址范围形式：

- `0,addr2` 此形式只在 `addr2` 是正则表达式时有效。它使 `sed` 从一开始就处于“已匹配第一个地址”的状态，直到匹配到 `addr2` 为止。
  - 这与 `1,addr2` 类似，但区别在于：如果 `addr2` 匹配了输入的第一行，`0,addr2` 范围会在第一行结束；而 `1,addr2` 范围则是在第一行才刚开始。
- `addr1,+N` 匹配 `addr1` 行以及**随后的 N 行**。
- `addr1,~N` 匹配 `addr1` 行以及随后的行，直到（并包含）下一个**行号是 N 的倍数**的行。



**示例 1：`0,addr2` (0到正则表达式)**

演示 `0,addr2` 和 `1,addr2` 在 `addr2` 匹配第一行时的关键区别。



使用一个新文件 `data3.txt`：

```
1: END_BLOCK
2: apple
3: END_BLOCK
```



**命令 1 (标准形式)：**

```
sed -n '1,/END_BLOCK/p' data3.txt
```

**输出 1：**

```
1: END_BLOCK
2: apple
3: END_BLOCK
```

**解释 1：** `addr1` 是 `1`。`sed` 在第 1 行匹配 `addr1`，范围打开，打印第 1 行。根据标准规则，`sed` 不会在第 1 行检查 `addr2` (`/END_BLOCK/`)。它继续到第 2 行（在范围内，打印）。它继续到第 3 行，匹配 `addr2`，打印第 3 行，范围关闭。



**命令 2 (GNU `0,addr2` 形式)：**

```
sed -n '0,/END_BLOCK/p' data3.txt
```

**输出 2：**

```
1: END_BLOCK
```

`sed` 以“已匹配”状态开始。它**立即**在第 1 行测试 `addr2` (`/END_BLOCK/`)。测试成功，`sed` 打印第 1 行，然后**立即关闭**范围。因此，第 2 行和第 3 行不在范围内。



**示例 2：`addr1,+N` (地址 + N 行)**

匹配 `addr1` 行以及其后的 `N` 行。

**命令（注意：此处使用的是第一个 data.txt 文件）：**

```
sed -n '/START_BLOCK/,+2p' data.txt
```

**输出：**

```
3: START_BLOCK
4: grape
5: orange
9: START_BLOCK
10: kiwi
11: mango
```

**解释：**

1. `sed` 在第 3 行匹配 `addr1` (`/START_BLOCK/`)，打印第 3 行。
2. 它接着打印随后的 `N=2` 行（即第 4 行和第 5 行）。
3. 范围结束。`sed` 继续搜索，在第 9 行再次匹配 `addr1`。
4. 打印第 9 行，以及随后的 2 行（第 10 行和第 11 行）。



**示例 2：`addr1,~N` (地址到 N 的倍数行)**

匹配 `addr1` 行，以及之后的所有行，直到（并包含）下一个行号是 `N` 的倍数的行。

**命令：** (我们想从 "grape" 开始，一直打印到下一个行号是 3 的倍数的行)

```
sed -n '/grape/,~3p' data.txt
```

**输出：**

```
4: grape
5: orange
6: END_BLOCK
```

**解释：**

1. `sed` 在第 4 行匹配 `addr1` (`/grape/`)，范围打开，打印第 4 行。
2. `sed` 检查第 5 行。5 不是 3 的倍数。打印第 5 行。
3. `sed` 检查第 6 行。6 是 3 的倍数。打印第 6 行，范围关闭。





### 地址反转 (Invert Match)

可以在地址（或地址范围）和命令之间插入一个感叹号 `!`。

- **作用：** 这会反转匹配逻辑，使得命令**仅**在地址（或地址范围）**不**匹配时才执行。



使用一个新文件 `data4.txt`：

```
1: aaa
2: bbb
3: ccc
4: ddd
5: eee
6: fff
```



**示例 1 ：打印 1 - 3 行（不使用地址反转）**

**命令：**

```
sed -n '1,3p' dat4.txt
```

**输出：**

```
4: ddd
5: eee
6: fff
```



**示例 2：打印不是 1 - 3 行**

**命令：**

```
sed -n '1,3!p' dat4.txt
```

**输出：**

```
4: ddd
5: eee
6: fff
```



## 命令部分语法





## 典型示例

打印 1 - 3 行

```
sed -n '1,3p' file
```

```
sed '1,3!d' file
```



删除 1 - 3 行

```
sed '1,3d' file
```



替换指定内容

示例文件：

```
[baseos]
name=Rocky Linux $releasever - BaseOS
#mirrorlist=https://mirrors.rockylinux.org/mirrorlist?arch=$basearch&repo=BaseOS-$releasever$rltype
baseurl=http://mirrors.cloud.aliyuncs.com/rockylinux/$releasever/BaseOS/$basearch/os/
gpgcheck=1
enabled=1
countme=1
metadata_expire=6h
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-Rocky-10
 
[baseos-debuginfo]
name=Rocky Linux $releasever - BaseOS - Debug
#mirrorlist=https://mirrors.rockylinux.org/mirrorlist?arch=$basearch&repo=BaseOS-$releasever-debug$rltype
baseurl=http://mirrors.cloud.aliyuncs.com/rockylinux/$releasever/BaseOS/$basearch/debug/tree/
gpgcheck=1
enabled=0
metadata_expire=6h
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-Rocky-10
```



将 mirrors.cloud.aliyuncs.com 替换为 test.cn

```
sed 's/mirrors\.cloud\.aliyuncs\.com/test.cn/' file
```



将 `http://aaa/bbb` 或 `https://aaa/bbb` 中的  aaa 替换为 ccc

```
sed 's/\(\(http\|https\):\/\/\)[^\/]\+/\1aaa/'
```



不匹配被注释（以 # 开头）的行

```
sed '/^#/! s/\(\(http\|https\):\/\/\)[^\/]\+/\1aaa/' file
```



即使 # 不在改行的开头，有前导空白字符，以下语法也能正常匹配：

```
sed '/^\s*#/! s/\(\(http\|https\):\/\/\)[^\/]\+/\1aaa/' file
```

