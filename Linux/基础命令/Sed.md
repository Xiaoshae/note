# Sed

`sed` 是 Linux/Unix 系统中一个非常强大且必备的文本处理工具。

`sed` 的全称是 **Stream Editor**（流编辑器）。它的核心思想是：**一次读取一行，处理一行，输出一行**。

它会从输入流（文件、管道等）中读取文本，将每一行放入一个称为“**模式空间**”（Pattern Space）的内存缓冲区。然后，`sed` 会在“模式空间”上执行你提供的脚本命令（比如替换、删除、插入）。处理完成后，默认情况下它会将“模式空间”的内容打印到标准输出，然后清空“模式空间”，接着读取下一行，重复这个过程。

除非你使用 `-i` 选项，否则 `sed` **不会修改原始文件**，它只是将处理结果输出到标准输出。



## 脚本

### 指定多个脚本

当你使用多个 `-e` 或 `-f` 选项时，`sed` 会在**开始处理任何输入之前**，按照你在**命令行上提供的顺序**，把所有这些脚本“拼接”起来，形成一个单一的、逻辑上的“大脚本”。



第一个脚本（非文件，使用 `-e` 参数指定）：`s/a/b/g`

第二个脚本（一个脚本文件 `script.sed`），内容为：

```
s/b/c/g
s/c/d/g
```

第三个脚本（非文件，使用 `-e` 参数指定）：`s/d/e/g`



如果你这样执行命令： `sed -e 's/a/b/g' -f script.sed -e 's/d/e/g' input.txt`

`sed` 在内存中构建的“合并后脚本”看起来就是这样的：

```
#--- 来自第一个 -e ---
s/a/b/g
#--- 来自 -f script.sed 的内容 (按文件顺序) ---
s/b/c/g
s/c/d/g
#--- 来自第二个 -e ---
s/d/e/g
```



### 多条语句的执行流程 

`sed` 的**核心工作循环**，这个流程会**对输入的每一行**都完整地跑一遍：

1. **读入（Read）：** `sed` 从输入源（文件或管道）读取**一行**，并将其放入一个叫做**“模式空间” (Pattern Space)** 的内部缓冲区。
2. **执行（Execute）：** `sed` 开始执行它那个“合并后的大脚本”。
3. - `sed` 会从“大脚本”的**第一条语句**开始。
   - 它用第一条语句的**[地址部分]**去匹配“模式空间”中的内容。
   - 如果匹配成功（或者没有地址，= 默认匹配），`sed` 就在“模式空间”上**执行该语句的[命令部分]**。
   - **关键：** 此时，“模式空间”的内容**可能已经被修改了**。
   - 然后，`sed` **立刻**拿起“大脚本”的**第二条语句**。
   - 它用第二条语句的**[地址部分]**去匹配“模式空间”**当前（可能已被修改）**的内容。
   - 如果匹配，就执行命令...
   - `sed` 会**依次、顺序地**用脚本中的**每一条**语句，去操作**同一个**“模式空间”。
4. **打印（Print）：** 当“大脚本”中的**所有语句**都针对这一行执行完毕后，`sed` 默认会打印“模式空间”中**最终**的内容到标准输出。（除非你用了 `-n` 选项）。
5. **清空（Clear）：** `sed` 丢弃“模式空间”中的内容。
6. **重复（Repeat）：** `sed` 回到步骤 1，去读取输入的**下一行**，直到所有行都处理完毕。



### 脚本结构

一个 `sed` 脚本（无论是写在 `-e '...'` 里还是 `-f script.sed` 文件里）在 `sed` 眼里的结构如下面所示。

#### **级别 1：脚本 (Script)**

一个脚本由一个或多个**语句 (Statement)** 组成。

- `语句_1`
- `语句_2`
- `语句_3`



#### **级别 2：分隔符 (Separator)**

分隔符 (Separator) 是 `sed` 用于在脚本中区分**上一条“语句”的结束**和**下一条“语句”的开始**。



**换行符 (`\n`)**： 这是最主要的分隔符。在 `-f script.sed` 文件中，每一行通常就是一个完整的语句。

```
/ERROR/d
/WARN/d
```



**分号 (`;`)**： 当你想在**一行内**编写多个语句时使用。

```
/ERROR/d ; /WARN/d
```

**注意：** 有些命令（如 `a`, `i`, `c`, `r`, `#`）会“吃掉”直到行尾的所有内容，它们后面不能跟分号。



#### **级别 3：语句 (Statement)**

这是最核心的颗粒度。**每一个“语句”**都由 **`[地址部分]`** 和 **`[命令部分]`** 组成。

```
[地址部分][可选的空格][命令部分]
```



#### **级别 4a：[地址部分] 的最小颗粒度**

[地址部分] 是可选的，但如果存在，它可以是以下几种形态：



**1. 空地址 (Zero Address)**：

- 就是**什么都不写**。
- 含义：应用于所有行。



**2. 单地址 (One Address)**：

**`行号`**：一个数字。例如 `10`。

**`最终行`**：一个美元符号 `$`。

**`正则表达式`**：

- **`分隔符_1`** (通常是 `/`)
- **`正则内容`** (例如 `^ERROR`)
- **`分隔符_2`** (必须和 `_1` 相同)



**分隔符**不一定必须为 `/` ，只是在 sed 命令中，通常是将 `/` 符号作为分隔符。



在以下示例中，将 `/` 符号作为分隔符：

```
# cat test
aaa bbb ccc 111 222 333

# cat test | sed 's/111/999/'
aaa bbb ccc 999 222 333
```



你可以将任意字符（除换行符）作为分隔符，例如在以下示例中，将字符 `5` 作为换行符。

```
# cat test
aaa bbb ccc 111 222 333

# cat test | sed 's511159995'
aaa bbb ccc 999 222 333
```



如果你要在**两个换行符的中间**使用**换行符**，则需要在该字符前添加反斜杠 `\` 字符

```
# cat test
aaa bbb ccc 111 222 333

# cat test | sed 's1\1\1\119991'
aaa bbb ccc 999 222 333
```

使用下划线标记的字符 `1` 为分隔符：**'s<u>1</u>\1\1\1<u>1</u>999<u>1</u>'**



如果你使用**反斜杠作为分隔符**，则在两个分隔符之间**不能使用反斜杠作为字符**。



**3. 地址范围 (Two Addresses)**：

**`单地址_1`** (见上)

**`逗号分隔符 ,`**

**`单地址_2`** (见上)

**GNU 特殊范围：** `0,addr2` | `addr1,+N` | `addr1,~N`



**4. 地址取反 (Negation)**：

`地址`（可以是单地址或范围）

**`感叹号 !`**

这个 `!` 会跟在整个 `[地址部分]` 的最后（但在 `[命令部分]` 之前）。



#### 级别 4b：[命令部分] 的最小颗粒度

`[命令部分]` **没有统一的语法**。**每种命令都有自己的“子语法”**。你不能把 `s` 命令的语法（带标志）套用到 `d` 命令（无参数）上。



**1. 简单命令 (无参数)**

**`命令字符`**：就是一个字符。

例如：`d`, `p` (打印), `n` (下一行), `q` (退出), `g` (Get), `G` (Append Get), `h` (Hold), `H` (Append Hold), `x` (Exchange), `l` (List), `P` (Print First Line), `D` (Delete First Line), `N` (Append Next), `=` (Print Line Number)。

简单命令直接没有参数，直接在地址部分后面，示例：

```
cat file | sed '1d'
```



**2. 替换命令 (S - 它拥有最复杂的“子语法”)**

**`命令字符`**：`s`

**`分隔符_1`** (任意非换行符，例如 `/`)

**`参数1: 正则表达式`**

**`分隔符_2`** (同 `_1`)

**`参数2: 替换字符串`** (它**自己**还有子语法，如 `&` 代表匹配项, `\1` 代表捕获组, `\L` `\U` 做大小写转换)

**`分隔符_3`** (同 `_1`)

**`参数3: 标志字符串`** (这才是你问的“标志”)

- 这个字符串可以是 `g` (全局), `i` (忽略大小写), `p` (打印), `N` (数字，只替换第 N 个)
- **最特殊的标志：`w filename`**
  - `w` 标志**自己还带一个参数**（文件名）。



**3. 命令块 (Grouping)**

- `{` 和 `}` 它们本身在技术上也是“命令”。
- `{` 后面必须跟一个**分隔符**（换行或 `;`）。
- `}` 前面必须有一个**分隔符**（换行或 `;`）。
- 它们允许你对**同一个地址**应用**多条语句**。



## 地址部分语法





## 命令部分语法





## 基本语法

`sed` 的基本命令格式有两种



从文件中读取内容：

```
sed [选项] '脚本命令' [输入文件...]
```

```
sed -n 's/hello/world/p' file.txt
```



从管道中读取内容：

```
command | sed [选项] '脚本命令'
```

```
cat file.txt | sed 's/hello/world/g'
```



### 脚本

`sed` 脚本是它所有功能的关键，其基本结构是：

```
[地址范围] [命令] [参数]
```



#### 地址

地址（Address） - 决定“对哪些行”操作

“地址”用于指定 `sed` 命令要作用于哪些行。如果省略地址，命令将作用于所有行。

| **地址类型**       | **示例**           | **含义**                                                     |
| ------------------ | ------------------ | ------------------------------------------------------------ |
| **行号**           | `3d`               | 仅删除第 3 行。                                              |
| **行范围**         | `5,10s/a/b/`       | 对第 5 行到第 10 行（包含 5 和 10）执行替换。                |
| **最后一行**       | `$`                | `$` 代表最后一行。例如 `$=` 会打印总行数。                   |
| **正则表达式**     | `/pattern/d`       | 删除所有 *包含* "pattern" 的行。                             |
| **正则范围**       | `'/start/,/end/p'` | 打印从匹配到 "start" 的行开始，到匹配到 "end" 的行结束的所有行。 |
| **步进** (GNU扩展) | `1~2p`             | 打印所有奇数行（从第 1 行开始，每隔 2 行）。                 |
| **取反**           | `!d`               | `!` 表示“非”。`5!d` 表示删除 *除了* 第 5 行之外的所有行。    |