# mmap munmap

`mmap` 和 `munmap` 是 Linux 系统调用，用于将文件或设备映射到内存中，或者从内存中取消这种映射。



## mmap

### 用法

```c
#include <sys/mman.h>

void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
```



### 描述

`mmap()` 函数在调用进程的虚拟地址空间中创建一个新的映射。新映射的起始地址由 `addr` 参数指定。`length` 参数指定了映射的长度（必须大于 0）。

- 如果 `addr` 是 `NULL`，那么内核会选择一个（页面对齐的）地址来创建映射；这是最可移植的方法。
- 如果 `addr` 不是 `NULL`，那么内核将其视为放置映射位置的提示；在 Linux 中，内核会选择一个接近提示的页面边界（但总是高于或等于 `/proc/sys/vm/mmap_min_addr` 的值），并尝试在此处创建映射。如果另一个映射已经存在，则内核可能会选择一个新的地址，该地址可能依赖于提示也可能不依赖。



映射的内容（相对于匿名映射而言，参见 `MAP_ANONYMOUS` 下面的描述）使用 `fd` 引用的文件或其他对象中的 `offset` 开始的 `length` 字节进行初始化。`offset` 必须是 `sysconf(_SC_PAGE_SIZE)` 返回的页面大小的倍数。



匿名映射（Anonymous Mapping）是通过 `mmap()` 系统调用创建的一种内存映射，它不与任何文件关联。换句话说，这种映射不是基于文件的内容来初始化的，而是直接由操作系统分配，并且其内容通常会被初始化为零。

在使用 `mmap()` 创建匿名映射时，需要在 `flags` 参数中包含 `MAP_ANONYMOUS` 标志。此时，`fd` 参数被忽略，但为了保证可移植性，应用程序应该将 `fd` 设置为 `-1`，并且 `offset` 参数也应该设置为 `0`。从 Linux 2.4 版本开始，`MAP_ANONYMOUS` 可以与 `MAP_SHARED` 结合使用，这意味着多个进程可以共享同一匿名映射，对映射的修改会反映给所有共享它的进程。



在 `mmap()` 调用返回后，可以立即关闭文件描述符 `fd`，这不会使映射无效。



### 参数

`prot`：描述映射所需的内存保护（不得与文件的打开模式冲突）。它可以是 `PROT_NONE` 或者是一个或多个以下标志的按位或：

- `PROT_EXEC`：页面可以执行。
- `PROT_READ`：页面可以读取。
- `PROT_WRITE`：页面可以写入。
- `PROT_NONE`：页面不可访问。



`flags`：确定更新是否对其他映射同一区域的进程可见，以及更新是否会被写入底层文件。此行为通过在 `flags` 中包含以下之一来决定：

- `MAP_SHARED`：共享此映射。对映射的更新对其他映射同一区域的进程可见，并且（对于文件支持的映射）会写入底层文件。（要精确控制何时更新被写入底层文件需要使用 `msync(2)`。）
- `MAP_SHARED_VALIDATE`（自 Linux 4.15 起）：提供与 `MAP_SHARED` 相同的行为，但当使用 `MAP_SHARED_VALIDATE` 创建映射时，内核会验证所有传递的标志是否已知，并在遇到未知标志时返回错误 `EOPNOTSUPP`。
- `MAP_PRIVATE`：创建私有的复制写入映射。对映射的更新对其他映射同一文件的进程不可见，也不会写入底层文件。文件在 `mmap()` 调用之后所做的更改是否在映射区域中可见是未定义的。



此外，可以在 `flags` 中按位或零个或多个以下标志：

- `MAP_32BIT`（自 Linux 2.4.20, 2.6 起）：将映射放入进程地址空间的前 2GB。此标志仅在 x86-64 架构上为 64 位程序所支持。
- `MAP_ANONYMOUS`：映射不由任何文件支持；其内容初始化为零。`fd` 参数被忽略，但某些实现要求 `fd` 为 `-1`，可移植的应用程序应确保这一点。`offset` 参数应该为零。Linux 2.4 版本开始支持 `MAP_ANONYMOUS` 与 `MAP_SHARED` 结合使用。
- `MAP_FIXED`：不要将 `addr` 视为提示：将映射放置在确切的该地址。`addr` 必须适当对齐：对于大多数架构，页面大小的倍数就足够了；然而，一些架构可能有额外的限制。如果指定的地址不能使用，`mmap()` 将失败。
- `MAP_FIXED_NOREPLACE`（自 Linux 4.17 起）：提供类似于 `MAP_FIXED` 的行为，但在 `addr` 和 `length` 范围与现有映射冲突时，不会覆盖现有的映射。如果请求的范围会发生冲突，该调用将以 `EEXIST` 错误失败。因此，可以使用此标志以原子方式（相对于其他线程）尝试映射地址范围。
- `MAP_GROWSDOWN`：用于栈。指示内核虚拟内存系统该映射应在内存中向下扩展。
- `MAP_HUGETLB`（自 Linux 2.6.32 起）：使用“大页”分配映射。
- `MAP_LOCKED`（自 Linux 2.5.37 起）：标记映射区域以锁定，如同 `mlock(2)`。
- `MAP_NONBLOCK`（自 Linux 2.5.46 起）：仅与 `MAP_POPULATE` 一起有意义。不要执行预读：只为已经在 RAM 中的页面创建页表条目。
- `MAP_NORESERVE`：不为此映射预留交换空间。
- `MAP_POPULATE`（自 Linux 2.5.46 起）：填充（预故障）映射的页表。对于文件映射，这会导致文件上的预读。
- `MAP_STACK`（自 Linux 2.6.27 起）：在适合进程或线程栈的地址分配映射。
- `MAP_SYNC`（自 Linux 4.15 起）：仅与 `MAP_SHARED_VALIDATE` 映射类型一起可用；`MAP_SHARED` 类型的映射会忽略此标志。
- `MAP_UNINITIALIZED`（自 Linux 2.6.33 起）：不清除匿名页面。此标志仅在内核配置了 `CONFIG_MMAP_ALLOW_UNINITIALIZED` 选项时有效。



#### 返回值

成功时，`mmap()` 返回指向映射区域的指针。出错时，返回 `MAP_FAILED`（即 `(void *)-1`），并设置 `errno` 以指示错误。



## munmap

### 用法

```C
#include <sys/mman.h>

int munmap(void *addr, size_t length);
```



## 描述

`munmap()` 系统调用删除指定地址范围的映射，并导致对该范围内地址的后续引用生成无效的内存引用。该区域也会在进程终止时自动取消映射。另一方面，关闭文件描述符并不会取消映射。

`addr` 必须是页面大小的倍数（但 `length` 不必是）。包含指定范围部分的所有页面都会被取消映射，对这些页面的后续引用将生成 `SIGSEGV`。即使指定的范围不包含任何已映射的页面，也不是错误。



### 返回值

成功时，`munmap()` 返回 0。出错时，返回 -1，并设置 `errno` 以指示错误（可能是 `EINVAL`）。



### 注意事项

- 内存映射由 `mmap()` 保留跨 `fork(2)`，具有相同的属性。
- 文件是以页面大小的倍数映射的。对于不是页面大小倍数的文件，剩余字节在映射时被清零，对这部分区域的修改不会写入文件。文件大小变化对其映射的影响是未定义的。
- 使用 `mincore(2)` 可以确定哪些页面当前存在于缓冲区/页面缓存中。
- `MAP_FIXED` 的安全使用仅限于先前通过其他映射保留的地址范围；否则，`MAP_FIXED` 的使用是有风险的，因为它强制移除预先存在的映射，容易使多线程进程破坏自己的地址空间。
- 对于使用大页面的映射，`mmap()` 的 `offset` 必须是底层大页面大小的倍数，系统会自动将 `length` 对齐为底层大页面大小的倍数。对于 `munmap()`，`addr` 和 `length` 都必须是底层大页面大小的倍数。



**mmap 不是放置在 heap 中。**

![img](./images/mmap.assets/program_virtual_address_memory_space.png)