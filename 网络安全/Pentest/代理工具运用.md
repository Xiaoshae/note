# 渗透测试工具



## proxychains-ng

ProxyChains 是一款 UNIX 程序，通过**预加载动态链接库**（利用 dlsym() 和 LD_PRELOAD 机制）动态劫持网络相关的 libc 函数，将动态链接程序的网络连接重定向至 SOCKS4a/5 或 HTTP 代理服务器。**当前仅支持 TCP 协议（不支持 UDP/ICMP 等）**。

其实现原理本质上是取巧的非正统方案，因此可能无法兼容部分程序——尤其是脚本类应用、会产生大量子进程的后台守护程序，或是通过 dlopen() 动态加载模块的程序（glibc 动态链接器的缺陷）。但对于简单的 C/C++ 编译型动态链接程序通常能够正常工作。

若您的应用无法通过 proxychains 代理，建议改用基于 iptables 的解决方案，其稳定性更为可靠。



### 配置项

#### 代理链模式

proxychains-ng 工具支持四种代理链模式。

- 严格链：按列表顺序使用**所有代理节点**（构建代理链），所有节点必须在线才能建立连接。
- 动态链：按列表顺序使用**在线代理节点**（构建代理链），自动跳过离线节点，至少一个节点在线即可工作。
- 轮询链：按 chain_len 定义的长度**循环使用代理**，自动跳过离线节点，每次从上次结束位置开始选代理节点。
- 随机链：从列表中**随机顺序选择代理节点**（构建代理链），自动跳过离线节点，chain_len 定义代理链的长度。



严格链、动态链、轮询链和随机链分别使用 **strict_chain、dynamic_chain、round_robin_chain 和 random_chain** 表示，配置文件中**只能选择一种模式**。**chain_len 仅对 random_chain 和 round_robin_chain 有效**。

```
#dynamic_chain
strict_chain
#round_robin_chain
#random_chain

#chain_len = 2
```



#### 静默模式

quiet_mode 选项将 proxychains-ng 设置为静默模式，不显示库输出。

```
#quiet_mode
```



#### 代理 DNS 请求

proxychains-ng 支持三种模式的 DNS 代理。

**proxy_dns（线程池模式）**

通过创建独立线程池拦截 DNS 请求，将查询封装为 SOCKS5 协议流量，经由代理链转发至远程 DNS 服务器。返回伪造的保留 IP 地址（如 224.x.x.x），实际连接时再将伪 IP 映射回真实地址。



**proxy_dns_old（外部脚本模式）**

调用 `/usr/bin/proxyresolv` 外部脚本，通过 `dig +tcp` 命令强制使用 TCP 协议执行 DNS 查询，查询过程完全通过代理链完成并返回真实 IP。



**proxy_dns_daemon（守护进程模式）**

由独立守护进程监听 1053 端口处理 DNS 请求，所有应用通过本地回环地址与守护进程通信。采用连接复用和预解析技术提升效率。

```
proxy_dns
#proxy_dns_old
#proxy_dns_daemon 127.0.0.1:1053
```



#### 虚拟网段

remote_dns_subnet 参数用于定义代理内部 DNS 映射的虚拟子网地址段，默认使用保留的 224.x.x.x 地址段。

- 当被代理应用进行 DNS 查询时，DNS 查询结果为该段的 IP 地址（部分文章中称为：**Fake IP**）。
- 如果某些应用会检查返回的 IP 地址并拒绝连接，可改用 10.x.x.x 或 127.x.x.x 等子网。
- 确保被代理应用无需实际访问该子网 ，注意不要与 localnet 段使用相同子网。

```
#remote_dns_subnet 127
#remote_dns_subnet 10
remote_dns_subnet 224
```



#### 网段排除

将网段设为**“本地网络范围”**，目**标地址为本地网络范围**的连接将不使用代理 。

注意：仅当应用传递纯 IP 地址，或通过 /etc/hosts 解析，或 proxy_dns 禁用/使用 proxy_dns_old 时生效

```
## 排除 192.168.1.0/24 网段的 80 端口
# localnet 192.168.1.0:80/255.255.255.0

## 排除整个 192.168.100.0/24 网段
# localnet 192.168.100.0/255.255.255.0

## 排除所有地址的 80 端口
# localnet 0.0.0.0:80/0.0.0.0
# localnet [::]:80/0

## RFC6890 回环地址范围
## 启用此项需确保 remote_dns_subnet 不是 127 段
## 如需代理连接本地端口的应用需要启用
# localnet 127.0.0.0/255.0.0.0
# localnet ::1/128

## RFC1918 私有地址范围
# localnet 10.0.0.0/255.0.0.0
# localnet 172.16.0.0/255.240.0.0
# localnet 192.168.0.0/255.255.0.0
```



#### 超时设置

```
# 超时设置（单位：毫秒）
tcp_read_time_out 15000
tcp_connect_time_out 8000
```



#### DNAT

对目标地址进行 DNAT 转换后代理

格式：原始地址:端口 -> 目标地址:端口

```
## 连接 1.1.1.1:1234 时实际连接到 1.1.1.2:443
# dnat 1.1.1.1:1234  1.1.1.2:443

## 连接 1.1.1.1:443 时实际连接到 1.1.1.2:443（端口可省略）
# dnat 1.1.1.2:443  1.1.1.2

## 无论连接 1.1.1.1 的哪个端口，都转到 1.1.1.2:443
# dnat 1.1.1.1  1.1.1.2:443

## 所有对 1.1.1.1 的连接都转到 1.1.1.2
# dnat 1.1.1.1  1.1.1.2
```



#### 代理列表

代理列表格式：`类型  IP  端口 [用户名 密码]`（使用制表符或空格分隔）

代理类型：http, socks4, socks5, raw（原始转发，流量不经修改直接转发 ）

认证类型支持：`"basic"-http  "user/pass"-socks`

示例：

```
[ProxyList]
socks5	192.168.67.78	1080	lamer	secret
http	192.168.89.3	8080	justu	hidden
socks4	192.168.1.49	1080
http	192.168.39.93	8080	
```



### 示例

proxychains-ng 配置文件

```
# 严格链
strict_chain

# 不输出信息
quiet_mode

# DNS
proxy_dns
remote_dns_subnet 224

# 超时设置
tcp_read_time_out 15000
tcp_connect_time_out 8000

# 代理列表
[ProxyList]
socks5 	172.16.153.47 1080
socks5 	172.17.251.182 1080
```



proxychains-ng 配合 nmap 进行 TCP connect端口扫描

```
proxychains4 nmap -sT -Pn -p- -r --min-rate 10000 172.18.100.100
[proxychains] config file found: /root/soft/proxychains-ng/etc/proxychains.conf
[proxychains] preloading /root/soft/proxychains-ng/lib/libproxychains4.so
[proxychains] DLL init: proxychains-ng 4.17
Starting Nmap 7.95 ( https://nmap.org ) at 2025-02-19 12:06 CST
Nmap scan report for 10.12.0.201
Host is up (0.00049s latency).
Not shown: 65533 closed tcp ports (conn-refused)
PORT     STATE SERVICE
22/tcp   open  ssh
1080/tcp open  socks

Nmap done: 1 IP address (1 host up) scanned in 52.40 seconds
```



## cproxy

cproxy 是一款基于 Rust 开发的轻量级透明代理工具，能够无感知地重定向应用程序的 TCP/UDP 流量至代理服务器。

它通过 cgroup 技术实现进程级流量管控，支持动态代理运行中程序、兼容静态编译的 Go 二进制文件，并提供类 proxychains 的简易操作方式。



> 代理工具**需为透明代理端口**，使用 ip2socks-go、gost 等工具可快速转换透明代理端口为 socks5 / http 代理



**基础用法：类 `proxychains` 模式**

启动新程序（仅 TCP 代理）：

```
sudo cproxy --port <目标本地端口> -- <您的程序> --参数1 --参数2 ...
```



若系统支持 `tproxy`，可通过 `--mode tproxy` 启用（代理 TCP 和 UDP）：

```
sudo cproxy --port <目标本地端口> --mode tproxy -- <您的程序> --参数1 --参数2 ...

# 或代理运行中的进程

sudo cproxy --port <目标本地端口> --mode tproxy --pid <现有进程PID>
```



使用 gost 将透明代理转为 socks5

```
gost -L red://:1080?tproxy=true -L redu://:1080?ttl=120s -F socks5://172.18.200.200:1080

cproxy --mode tproxy --port 1080 curl http://172.20.200.200
```



局限性：

1. 仅支持 IPv4 的 TCP 或 UDP
2. 由于**透明代理应用程序**处理流量的流程，cproxy 无法和 nmap 等（这类依赖底层协议响应的工具）搭配使用。



无法和 namp 搭配使用，**根据DeepSeek-ai的解释，**这是透明代理工具的典型特性：

**TPROXY（Transparent Proxy）** 是将流量透明重定向到本地应用程序，**应用程序**收到 TCP 请求后的工作流程。

1. 收到一个 TCP 透明流量 SYN 请求，立即完成 TCP 握手（SYN-ACK），表现为「瞬时连接成功」
2. 通过代理协议（如SOCKS5）异步建立真实连接
3. 若代理无法连接目标，则发送RST包终止本地连接 



实际测试中发现：用telnet连接未开放端口时，会先显示连接成功再立即断开：

```
root@localhost:~# time cproxy --mode tproxy --port 1080 telnet 172.18.223.53 2222 
Trying 10.12.0.201...
Connected to 10.12.0.201.
Escape character is '^]'.
Connection closed by foreign host.

real	0m0.754s
user	0m0.004s
sys		0m0.065s
```

注：**仅 telnet 的 real 实际大约为 0m0.005s**，上面测量程序执行所需的时间，包括了 cproxy 和 telnet 两者。



使用nmap扫描时则会误判所有端口开放：

```
root@localhost:~# cproxy --mode tproxy --port 1080 nmap -sT -Pn -p 1,2,3,4,5,60000-60010 172.18.223.53
Starting Nmap 7.95 ( https://nmap.org ) at 2025-02-19 13:02 CST
Nmap scan report for 10.12.0.201
Host is up (0.00031s latency).

PORT      STATE SERVICE
1/tcp     open  tcpmux
2/tcp     open  compressnet
3/tcp     open  compressnet
4/tcp     open  unknown
5/tcp     open  rje
60000/tcp open  unknown
60001/tcp open  unknown
60002/tcp open  unknown
60003/tcp open  unknown
60004/tcp open  unknown
60005/tcp open  unknown
60006/tcp open  unknown
60007/tcp open  unknown
60008/tcp open  unknown
60009/tcp open  unknown
60010/tcp open  unknown

Nmap done: 1 IP address (1 host up) scanned in 0.02 seconds
```



## gost



## WireGuard

WireGuard 是一种开源的现代 VPN 协议， 通过 UDP 安全封装 IP 数据包，可以承载 **所有基于 IP 协议的流量**（IPv4/IPv6），其核心特点有**简洁高效**（**代码量仅约4000行**，更易审计漏洞和维护）、**高性能**（Linux内核实现）、**强加密**（基于现代密码学 Curve25519椭圆曲线、ChaCha20加密、BLAKE2哈希）、**跨平台**（Linux、Windows、macOS、iOS、Android 等）。

**相较于传统 VPN（如 OpenVPN/IPsec）**，其代码规模仅为 OpenVPN 的 **1/50**（4000行 vs 20万+行），服务端配置从 IPsec 的 **500+行** 缩减至 **单文件6 - 20行**，且密钥轮换、隧道维护等操作均可通过修改 **3-4个参数** 实时生效。



### 示例

以下是**两台 Linux 搭建 VPN 隧道**的示例：

| 主机   | 物理IP                     | VPN IP   |
| ------ | -------------------------- | -------- |
| Linux1 | 10.12.0.201                | 10.0.0.1 |
| Linux2 | 10.12.0.202<br>10.13.0.201 | 10.0.0.2 |
| Linux3 | 10.13.0.202                | NULL     |

Linux1 与 Linux2 可直接通信，Linux2 与 Linux3 也可互通，但 **Linux1 无法直连 Linux3**。为此在 **Linux1 和 Linux2 之间建立 WireGuard 加密隧道**，将 Linux1 访问 Linux3 的流量定向至该隧道传输至 Linux2，再由 Linux2 通过 **NAT 地址转换**将流量转发至 Linux3。

![img](./images/%E4%BB%A3%E7%90%86%E5%B7%A5%E5%85%B7%E8%BF%90%E7%94%A8.assets/image.svg)



自 Linux 5.6 起，内核已原生**集成 WireGuard 协议栈**，可通过标准 `ip link` 命令直接创建 WireGuard 虚拟接口；对于 5.6 之前的内核版本，需通过用户空间实现工具 `wireguard-go` 创建兼容接口。

配置WireGuard接口需使用wg工具，较新系统可通过包管理器直接安装wireguard-tools，而老旧系统可以通过源码编译安装。

- [【wireguard-go】](https://github.com/WireGuard/wireguard-go)：WireGuard 的用户空间实现，适用于内核未原生支持 WireGuard 的环境（**仅源代码**）。
- [【wireguard-go-builder】](https://github.com/P3TERX/wireguard-go-builder)：提供不同平台（如 ARM、MIPS 等）构建静态链接的 `wireguard-go` **二进制文件**。
- [【wireguard-tools】](https://github.com/WireGuard/wireguard-tools)：WireGuard 命令行工具集，包含 `wg` 和 `wg-quick`等工具（**仅源代码**）。



#### 通用准备（在所有节点执行）

```
# 生成密钥对（所有节点执行）
# [N]为节点编号占位符（例：linux1/linux2），需替换为实际数字
wg genkey | tee private_key_linux[N] | wg pubkey > public_key_linux[N]

# 创建WireGuard接口（根据内核版本选择）
# Linux 5.6+ 内核原生支持
ip link add dev wg0 type wireguard

# 旧版内核（<5.6）需要wireguard-go
wireguard-go wg0
```



#### Linux 1

配置虚拟接口

```
ip addr add 10.0.0.1/24 dev wg0
ip link set wg0 up
```



创建配置文件 /etc/wireguard/wg0.conf

```
[Interface]
ListenPort = 51820
PrivateKey = ULgCzX94OpIxbuSfqw57YfoTd+55lkwAEX6BC1PKfWw=

[Peer]
PublicKey = MbS80tQ9RiHPfTocgAoHFEeaZqVT25ws9ZF+zGueS3g=
AllowedIPs = 10.0.0.2/32
```

- **PrivateKey：Linux 1 私钥文件内容**
- **PublicKey：Linux 2 公钥文件内容**



应用配置文件

```
wg setconf wg0 wg0.conf
```



#### Linux 2

```
ip addr add 10.0.0.2/24 dev wg0
ip link set wg0 up
```



创建配置文件 /etc/wireguard/wg0.conf

```
[Interface]
ListenPort = 51820
PrivateKey = ENv2cywBG2rEVPyucbcGwJVvWms9GeCfhEcQi9SkSEE=

[Peer]
PublicKey = jG+QjJAyc3SfG8b8Mbg60FmN0mgONqsdDzUHjNg7vg4=
AllowedIPs = 10.0.0.1/32
Endpoint = 10.12.0.201:51820
PersistentKeepalive = 25
```

- **PrivateKey：Linux 2 私钥文件内容**
- **PublicKey：Linux 1 公钥文件内容**



应用配置文件

```
wg setconf wg0 wg0.conf
```



#### 查看状态

```bash
[root@linux1 ~]# wg 
interface: wg0
  public key: jG+QjJAyc3SfG8b8Mbg60FmN0mgONqsdDzUHjNg7vg4=
  private key: (hidden)
  listening port: 51820

peer: MbS80tQ9RiHPfTocgAoHFEeaZqVT25ws9ZF+zGueS3g=
  endpoint: 10.12.0.202:51820
  allowed ips: 10.0.0.2/32
  latest handshake: 1 minute, 1 second ago
  transfer: 4.97 KiB received, 1.98 KiB sent

[root@linux2 ~]# wg 
interface: wg0
  public key: MbS80tQ9RiHPfTocgAoHFEeaZqVT25ws9ZF+zGueS3g=
  private key: (hidden)
  listening port: 51820

peer: jG+QjJAyc3SfG8b8Mbg60FmN0mgONqsdDzUHjNg7vg4=
  endpoint: 10.12.0.201:51820
  allowed ips: 10.0.0.1/32
  latest handshake: 1 minute, 10 seconds ago
  transfer: 9.91 KiB received, 32.68 KiB sent
  persistent keepalive: every 25 seconds
```



#### WireGuard 隧道连通性测试

```
[root@linux2 ~]# ping 10.0.0.2 -c 4
PING 10.0.0.2 (10.0.0.2) 56(84) bytes of data.
64 bytes from 10.0.0.2: icmp_seq=1 ttl=64 time=0.014 ms
64 bytes from 10.0.0.2: icmp_seq=2 ttl=64 time=0.032 ms
64 bytes from 10.0.0.2: icmp_seq=3 ttl=64 time=0.028 ms
64 bytes from 10.0.0.2: icmp_seq=4 ttl=64 time=0.029 ms

--- 10.0.0.2 ping statistics ---
4 packets transmitted, 4 received, 0% packet loss, time 3111ms
rtt min/avg/max/mdev = 0.014/0.025/0.032/0.009 ms


[root@linux1 ~]# ssh root@10.0.0.2 
root@10.0.0.2's password: 
Last login: Sat Feb 15 03:44:29 2025 from 10.0.0.1
[root@linux2 ~]# 
```



#### 配置 NAT 转发

**Linux 2** 启用 **net.ipv4.ip_forward（永久生效）**

```
# 编辑配置文件
vim /etc/sysctl.conf

# 添加或取消注释以下行（IPv4）
net.ipv4.ip_forward = 1

# 加载配置使其生效
sysctl -p
```



**Linux 2** 配置 **VPN网关流量转发与NAT规则（重启后失效）** 

```
# NAT地址伪装：将来自10.0.0.0/16网段的流量通过ens224接口做源地址转换（内网访问外网）
iptables -t nat -A POSTROUTING -s 10.0.0.0/16 -o ens224 -j MASQUERADE

# 转发规则：允许从VPN接口(wg0)到外网接口(ens224)的流量（出站方向）
iptables -A FORWARD -i wg0 -o ens224 -j ACCEPT

# 转发规则：仅允许外网接口(ens224)到VPN的回程流量（已建立连接和相关连接）
iptables -A FORWARD -i ens224 -o wg0 -m state --state RELATED,ESTABLISHED -j ACCEPT
```



**Linux 1** 添加**路由表（重启后失效）**

```
# 添加静态路由：将10.13.0.0/16网段流量通过VPN网关10.0.0.2路由
ip route add 10.13.0.0/16 via 10.0.0.2 dev wg0
```



#### Linux 1 和 3 连通性测试

```
[root@linux1 ~]# ping 10.13.0.202 -c 4 
PING 10.13.0.202 (10.13.0.202) 56(84) bytes of data.
64 bytes from 10.13.0.202: icmp_seq=1 ttl=63 time=2.15 ms
64 bytes from 10.13.0.202: icmp_seq=2 ttl=63 time=0.892 ms
64 bytes from 10.13.0.202: icmp_seq=3 ttl=63 time=1.49 ms
64 bytes from 10.13.0.202: icmp_seq=4 ttl=63 time=0.996 ms

--- 10.13.0.202 ping statistics ---
4 packets transmitted, 4 received, 0% packet loss, time 3019ms
rtt min/avg/max/mdev = 0.892/1.381/2.151/0.497 ms


[root@linux1 ~]# ssh root@10.13.0.202 
root@10.13.0.202's password: 
Last login: Sat Feb 15 22:40:33 2025 from 10.13.0.1
[root@linux3 ~]# 
```



使用 **nmap** 扫描 **10.13.0.0/16** 网段

```
[root@linux1 ~]# nmap -sn -PE  10.13.0.0/16
Starting Nmap 7.70 ( https://nmap.org ) at 2025-02-15 22:53 CST
Nmap scan report for 10.13.0.1
Host is up (0.012s latency).
Nmap scan report for 10.13.0.162
Host is up (0.0030s latency).
Nmap scan report for 10.13.0.201
Host is up (0.00094s latency).
Nmap scan report for 10.13.0.202
Host is up (0.0030s latency).
Nmap done: 256 IP addresses (4 hosts up) scanned in 3.72 seconds
```



### 配置文件

配置文件格式基于 *INI* 文件。其中包含两个顶级部分——*Interface*（接口）和 *Peer*（对等体）。可以指定多个 *Peer* 部分，但只能有一个 *Interface* 部分。



*Interface* 部分可能包含以下字段：

- ***Address*** — 要分配给接口的逗号分隔的 IP（v4 或 v6）地址列表（可选带 CIDR 掩码）。可以多次指定。
- ***DNS*** — 要设置为接口的 DNS 服务器的逗号分隔的 IP（v4 或 v6）地址列表，或要设置为接口的 DNS 搜索域的非 IP 主机名。可以多次指定。
- ***MTU*** — 如果未指定，MTU 将从端点地址或系统默认路由自动确定，这通常是一个明智的选择。然而，要手动指定一个 MTU 以覆盖这种自动发现，可以显式指定此值。
- ***Table*** — 控制向其添加路由的路由表。有两个特殊值：`off` 完全禁用路由的创建，`auto`（默认值）将路由添加到默认表并启用默认路由的特殊处理。
- ***PreUp, PostUp, PreDown, PostDown*** — 在设置/拆除接口之前/之后由 **bash** 执行的脚本片段，最常用于配置自定义 DNS 选项或防火墙规则。特殊字符串 `%i' 会被扩展为 *INTERFACE*。每个键可以多次指定，在这种情况下，命令按顺序执行。
- ***SaveConfig*** — 如果设置为 `true'，则在关闭时从接口的当前状态保存配置。因此，在删除接口之前对配置文件所做的任何更改都将被覆盖。

- **PrivateKey** — 由 *wg genkey* 生成的 base64 编码私钥。必填。
- **ListenPort** — 用于监听的 16 位端口号。可选；如果未指定，则随机选择。
- **FwMark** — 用于标记传出数据包的 32 位防火墙标记（fwmark）。如果设置为 0 或 "off"，则此选项被禁用。可以通过添加前缀 "0x" 来以十六进制形式指定。可选。

*Peer* 部分可能包含以下字段：

- **PublicKey** — 通过 *wg pubkey* 根据私钥计算出的 base64 编码公钥，通常通过带外方式传输给配置文件的作者。必填。
- **PresharedKey** — 由 *wg genpsk* 生成的 base64 编码预共享密钥。可选，也可以省略。该选项增加了一层额外的对称密钥加密，与现有的公钥加密结合使用，以提供抗量子计算的能力。
- **AllowedIPs** — 使用 CIDR 掩码表示的 IP 地址（IPv4 或 IPv6）列表，用逗号分隔。用于指定允许来自该对等体的入站流量来源，以及出站流量的目标地址。可以使用通配符 *0.0.0.0/0* 匹配所有 IPv4 地址，或使用 *::/0* 匹配所有 IPv6 地址。此字段可以多次指定。
- **Endpoint** — 一个 IP 地址或主机名，后面跟一个冒号和端口号。该端点会根据从对等体接收到的正确验证的数据包的最新源 IP 地址和端口自动更新。可选。
- **PersistentKeepalive** — 指定发送经过认证的空数据包到对等体的时间间隔（秒），范围为 1 到 65535（含）。其目的是持续保持状态防火墙或 NAT 映射的有效性。例如，如果接口很少发送流量，但可能会随时接收来自对等体的流量，并且位于 NAT 后面，则设置 25 秒的持久化保活间隔可能是有益的。如果设置为 0 或 "off"，此选项将被禁用。默认情况下或未指定时，此选项关闭。大多数用户不需要此功能。可选。







## wstunnel

Wstunnel 使用与 http 兼容的 websocket 协议来绕过防火墙和代理。Wstunnel 允许你传输任何你想要的流量，并访问任何你需要的资源/网站。

### 命令行

#### Server

```
SERVER
Usage: wstunnel server [OPTIONS] <ws[s]://0.0.0.0[:port]>

参数:
  <ws[s]://0.0.0.0[:port]>
          绑定 wstunnel 服务器的地址
          示例: 使用 TLS wss://0.0.0.0:8080 或者不带 ws://[::]:8080
          
          服务器能够自行检测请求是 websocket 还是 http2。因此你不需要指定它。

选项:
      --socket-so-mark <INT>
          （仅限 linux）使用 SO_MARK sockoption 标记网络数据包，并指定值。
          使用此选项时，你需要使用 {root, sudo, capabilities} 来运行 wstunnel

      --websocket-ping-frequency-sec <seconds>
          服务器向客户端发送 websocket ping 的频率。

      --no-color <NO_COLOR>
          禁用日志中的彩色输出
          
          [env: NO_COLOR=]

      --websocket-mask-frame
          启用 websocket 帧的掩码。默认为 false
              只有在使用非安全（非 TLS）websocket 服务器并看到一些问题时才启用此选项。否则，这只是开销。

      --nb-worker-threads <INT>
          *警告* 该标志无效，你需要设置环境变量 *警告*
          控制将使用的线程数量。
          默认情况下，它等于 CPU 数量
          
          [env: TOKIO_WORKER_THREADS=]

      --restrict-to <DEST:PORT>
          服务器将只接受来自指定隧道信息的连接。
          可以多次指定
          示例: --restrict-to "google.com:443" --restrict-to "localhost:22"

      --dns-resolver <DNS_RESOLVER>
          使用的 DNS 解析器来查找域名的 IP
          如果你使用透明代理，此选项将不起作用
          可以多次指定
          示例:
           dns://1.1.1.1 用于使用 udp
           dns+https://1.1.1.1?sni=loudflare-dns.com 用于使用 DNS over HTTPS
           dns+tls://8.8.8.8?sni=dns.google 用于使用 DNS over TLS
          要使用 libc 解析器，请使用
          system://0.0.0.0

      --log-lvl <LOG_LEVEL>
          控制日志详细程度。例如: TRACE, DEBUG, INFO, WARN, ERROR, OFF
          更多详情: https://docs.rs/tracing-subscriber/latest/tracing_subscriber/filter/struct.EnvFilter.html#example-syntax
          
          [env: RUST_LOG=]
          [默认值: INFO]

  -r, --restrict-http-upgrade-path-prefix <RESTRICT_HTTP_UPGRADE_PATH_PREFIX>
          服务器将只接受在此特定路径前缀下使用 websocket 升级的连接。
          如果你在客户端指定了自定义路径前缀，并且希望服务器只允许这个前缀，则很有用。
          路径前缀充当认证客户端的秘密
          默认禁用。接受所有路径前缀。可以多次指定
          
          [env: WSTUNNEL_RESTRICT_HTTP_UPGRADE_PATH_PREFIX=]

      --restrict-config <RESTRICT_CONFIG>
          限制 yaml 配置文件的位置路径。
          如果配置文件发生变化，限制文件将自动重新加载

      --tls-certificate <FILE_PATH>
          [可选] 使用自定义证书（pem）代替默认嵌入的自签名证书。
          如果证书更改，证书将自动重新加载

      --tls-private-key <FILE_PATH>
          [可选] 服务器将使用的自定义 tls 密钥（pem, ec, rsa）代替默认嵌入的密钥
          如果私钥更改，私钥将自动重新加载

      --tls-client-ca-certs <FILE_PATH>
          [可选] 启用 mTLS（客户端使用证书进行身份验证）。参数必须是包含一个或多个 CA 证书的 PEM 文件，
          客户端证书需要由这些 CA 签署。
          如果 CA 发生变化，CA 将自动重新加载
          
    -p, --http-proxy <USER:PASS@HOST:PORT>
          如果设置，将使用此 http 代理连接到客户端

          [env: HTTP_PROXY=]

      --http-proxy-login <LOGIN>
          如果设置，将使用此登录名连接到 http 代理。覆盖 --http-proxy 中的登录名

          [env: WSTUNNEL_HTTP_PROXY_LOGIN=]

      --http-proxy-password <PASSWORD>
          如果设置，将使用此密码连接到 http 代理。覆盖 --http-proxy 中的密码

          [env: WSTUNNEL_HTTP_PROXY_PASSWORD=]
```



#### Client

```
Usage: wstunnel client [OPTIONS] <ws[s]|http[s]://wstunnel.server.com[:port]>

参数:
  <ws[s]|http[s]://wstunnel.server.com[:port]>
          wstunnel 服务器地址
          你可以使用 websocket 或 http2 作为传输协议。如果不确定，请使用 websocket。
          示例: 对于带 TLS 的 websocket wss://wstunnel.example.com 或者不带 ws://wstunnel.example.com
                   对于带 TLS 的 http2 https://wstunnel.example.com 或者不带 http://wstunnel.example.com
          
          *警告* HTTP2 作为传输协议更难使其工作，因为：
            - 如果你在 (反向) 代理/CDN 后面，它们会在将整个请求转发给服务器之前缓冲整个请求
              显然，这对于隧道流量不起作用
            - 如果你有 wstunnel 在反向代理后面，大部分（例如：nginx）会将 http2 请求转换为 http1
              这不会起作用，因为 http1 不自然地支持流式传输
          让 http2 工作的唯一方法是让 wstunnel 直接暴露在互联网上，而没有任何反向代理在前面

选项:
  -L, --local-to-remote <{tcp,udp,socks5,stdio,unix}://[BIND:]PORT:HOST:PORT>
          本地监听并将远程流量转发。可以多次指定
          示例:
          'tcp://1212:google.com:443'      =>       在本地 tcp 端口 1212 上监听并转发到 google.com 的 443 端口
          'tcp://2:n.lan:4?proxy_protocol' =>       在本地 tcp 端口 2 上监听并转发到 n.lan 的 4 端口
                                                    当建立与 n.lan 的连接时发送代理协议头 v2
          
          'udp://1212:1.1.1.1:53'          =>       在本地 udp 端口 1212 上监听并转发到 cloudflare dns 1.1.1.1 的 53 端口
          'udp://1212:1.1.1.1:53?timeout_sec=10'    timeout_sec 强制关闭隧道后 10 秒。将其设置为 0 以禁用超时 [默认值: 30]
          
          'socks5://[::1]:1212'            =>       在本地 socks5 端口 1212 上监听并动态转发请求的隧道
          'socks5://[::1]:1212?login=admin&password=admin' => 在本地 socks5 端口 1212 上监听并且仅接受登录=admin 和密码=admin 的连接
          
          'http://[::1]:1212'              =>       在端口 1212 上启动 http 代理并动态转发请求的隧道
          'http://[::1]:1212?login=admin&password=admin' => 在端口 1212 上启动 http 代理并且仅接受登录=admin 和密码=admin 的连接

          'tproxy+tcp://[::1]:1212'        =>       在本地 tcp 端口 1212 上监听作为 *透明代理* 并动态转发请求的隧道
          'tproxy+udp://[::1]:1212?timeout_sec=10'  在本地 udp 端口 1212 上监听作为 *透明代理* 并动态转发请求的隧道
                                                    仅限 linux 并需要 sudo/CAP_NET_ADMIN
          
          'stdio://google.com:443'         =>       监听来自 stdio 的数据，主要用于 `ssh -o ProxyCommand="wstunnel client --log-lvl=off -L stdio://%h:%p ws://localhost:8080" my-server`
          
          'unix:///tmp/wstunnel.sock:g.com:443' =>  从路径 /tmp/wstunnel.sock 的 unix socket 监听数据并转发到 g.com:443

  -R, --remote-to-local <{tcp,udp,socks5,unix}://[BIND:]PORT:HOST:PORT>
          在远程监听并从本地转发流量。可以多次指定。仅支持 tcp
          示例:
          'tcp://1212:google.com:443'      =>     在服务器上监听传入的 tcp 连接在端口 1212 并从本地机器转发到 google.com 的 443 端口
          'udp://1212:1.1.1.1:53'          =>     在服务器上监听传入的 udp 流量在端口 1212 并从本地机器转发到 cloudflare dns 1.1.1.1 的 53 端口
          'socks5://[::1]:1212'            =>     在服务器上监听传入的 socks5 请求在端口 1212 并从本地机器动态转发请求
          'http://[::1]:1212'              =>     在服务器上监听传入的 http 代理请求在端口 1212 并从本地机器动态转发请求（支持登录/密码）
          'unix://wstunnel.sock:g.com:443' =>     在服务器上监听来自路径 wstunnel.sock 的 unix socket 的传入数据并从本地机器转发到 g.com:443

      --no-color <NO_COLOR>
          禁用日志中的彩色输出
          
          [env: NO_COLOR=]

      --socket-so-mark <INT>
          （仅限 linux）使用 SO_MARK sockoption 标记网络数据包，并指定值。
          使用此选项时，你需要使用 {root, sudo, capabilities} 来运行 wstunnel

  -c, --connection-min-idle <INT>
          客户端将保持一个到服务器的开放连接池，以加快连接过程。
          此选项设置将保持打开的最大连接数。
          如果你计划创建/销毁大量隧道（即使用 socks5 浏览浏览器），这很有用。
          它将避免与服务器进行 tcp + tls 握手的延迟
          
          [默认值: 0]

      --nb-worker-threads <INT>
          *警告* 该标志无效，你需要设置环境变量 *警告*
          控制将使用的线程数量。
          默认情况下，它等于 CPU 数量
          
          [env: TOKIO_WORKER_THREADS=]

      --log-lvl <LOG_LEVEL>
          控制日志详细程度。例如: TRACE, DEBUG, INFO, WARN, ERROR, OFF
          更多详情: https://docs.rs/tracing-subscriber/latest/tracing_subscriber/filter/struct.EnvFilter.html#example-syntax
          
          [env: RUST_LOG=]
          [默认值: INFO]

      --tls-sni-override <DOMAIN_NAME>
          在 TLS 握手期间将用作 SNI 的域名
          警告: 如果你在 CDN（如 Cloudflare）后面，你也必须在 http HOST 头中设置此域名。
                否则会被标记为可疑并拒绝你的请求

      --tls-sni-disable
          禁用在 TLS 握手期间发送 SNI
          警告: 大多数反向代理依赖于此

      --tls-verify-certificate
          启用 TLS 证书验证。
          默认禁用。客户端将愉快地连接到具有自签名证书的任何服务器。

  -p, --http-proxy <USER:PASS@HOST:PORT>
          如果设置，将使用此 http 代理连接到服务器
          
          [env: HTTP_PROXY=]

      --http-proxy-login <LOGIN>
          如果设置，将使用此登录名连接到 http 代理。覆盖 --http-proxy 中的登录名
          
          [env: WSTUNNEL_HTTP_PROXY_LOGIN=]

      --http-proxy-password <PASSWORD>
          如果设置，将使用此密码连接到 http 代理。覆盖 --http-proxy 中的密码
          
          [env: WSTUNNEL_HTTP_PROXY_PASSWORD=]

  -P, --http-upgrade-path-prefix <HTTP_UPGRADE_PATH_PREFIX>
          使用特定前缀，在升级请求期间显示在 http 路径中。
          如果你需要在服务器端路由请求但没有 vhosts，则很有用
          
          [env: WSTUNNEL_HTTP_UPGRADE_PATH_PREFIX=]
          [默认值: v1]

      --http-upgrade-credentials <USER[:PASS]>
          在升级请求期间传递带有基本认证凭据的授权头。
          如果你需要更多定制，可以使用 http_headers 选项。

      --websocket-ping-frequency-sec <seconds>
          客户端向服务器发送 websocket ping 的频率。
          
          [默认值: 30]

      --websocket-mask-frame
          启用 websocket 帧的掩码。默认为 false
          只有在使用非安全（非 TLS）websocket 服务器并看到一些问题时才启用此选项。否则，这只是开销。

  -H, --http-headers <HEADER_NAME: HEADER_VALUE>
          在升级请求中发送自定义头
          可以多次指定

      --http-headers-file <FILE_PATH>
          从文件中读取并在升级请求中发送自定义头。
          它会覆盖从命令行指定的 http_headers。
          文件每次都会被读取，文件格式必须包含 `HEADER_NAME: HEADER_VALUE` 的行

      --tls-certificate <FILE_PATH>
          [可选] 连接通过 TLS（HTTPS）时呈现给服务器的证书（pem）。
          当服务器要求客户端使用证书进行身份验证时使用（即 mTLS）。
          如果证书更改，证书将自动重新加载

      --tls-private-key <FILE_PATH>
          [可选] 用于 mTLS 的相应证书的私钥。
          如果证书更改，证书将自动重新加载

      --dns-resolver <DNS_RESOLVER>
          使用的 DNS 解析器来查找域名的 IP。可以多次指定
          示例:
           dns://1.1.1.1 用于使用 udp
           dns+https://1.1.1.1?sni=cloudflare-dns.com 用于使用 DNS over HTTPS
           dns+tls://8.8.8.8?sni=dns.google 用于使用 DNS over TLS
          对于 Dns over HTTPS/TLS，如果配置了 HTTP 代理，也将使用它
          要使用 libc 解析器，请使用
          system://0.0.0.0

          **警告** 在 Windows 上，你可能希望明确指定 DNS 解析器以避免过多的 DNS 查询
```



### 示例

#### 最简单的示例

在你的远程主机上，通过在终端输入以下命令启动 wstunnel 的服务器

```
wstunnel server wss://[::]:8080
```



这将在任何接口上创建一个 websocket 服务器，监听 8080 端口。

在客户端使用以下命令通过 websocket 隧道转发流量。

```
wstunnel client -L socks5://127.0.0.1:8888 --connection-min-idle 5 wss://myRemoteHost:8080
```



此命令将创建一个 socks5 服务器，监听环回接口的 8888 端口，并动态转发流量。 `connection-min-idle 10` 是一种优化，创建一个连接到服务器的 10 个连接池，以加速新隧道的建立。

使用 firefox 可以通过在网络首选项中设置 127.0.0.1:8888 并选择 socks5 代理来设置使用此隧道的代理。 确保检查选项 `Proxy DNS when using SOCKS v5` 让服务器解析 DNS 名称而不是本地机器。

```
curl -x socks5h://127.0.0.1:8888 http://google.com/
#请注意 h 在 5 之后，是为了避免 curl 在本地解析 DNS 名称
```



#### 作为 SSH 的代理命令

如果希望使用 wstunnel 作为 ssh 代理命令的一部分，可以在客户端侧指定 `stdio` 作为源端口

```
ssh -o ProxyCommand="wstunnel client --log-lvl=off -L stdio://%h:%p ws://myRemoteHost:8080" my-server
```



#### 在公司代理后面

另一个有用的示例是当你想绕过 http 代理（例如公司代理）时。

最可靠的方法是按如下方式使用 wstunnel。



启动 wstunnel 服务器并激活 tls。

```
wstunnel server wss://[::]:443 --restrict-to 127.0.0.1:22
```

- 服务器将在任何接口上监听 443 端口（https）并将流量**限制为仅转发到 ssh 守护进程**。
- **请注意，服务器将使用弱加密算法的自签名证书。 这样做是为了在仍然符合 tls 的同时添加最少的可能开销。**

- **不要依赖 wstunnel 来保护你的隐私，如果你对此有顾虑，你应该只转发设计上已经安全的流量（即：https 或 vpn 流量）**



现在在客户端启动客户端。

```
wstunnel client -L tcp://9999:127.0.0.1:22 -p http://mycorporateproxy:8080 wss://myRemoteHost:443
```

这将在 9999 端口上启动一个 tcp 服务器，联系公司代理，与远程主机协商 tls 连接，并将流量转发到远程主机上的 ssh 守护进程。



你现在可以通过以下方式在本地机器上访问你的服务器。

```
ssh -p 9999 login@127.0.0.1
```



#### Wireguard 和 wstunnel

你有一个名为 `wg0.conf` 的有效 wireguard 客户端配置。比如

```
[Interface]
Address = 10.200.0.2/32, fd00:cafe::2/128
PrivateKey = xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx=

[Peer]
PublicKey = 9iicV7Stdl/U0RH1BNf3VvlVjaa4Eus6QPEfEz6cR0c=
AllowedIPs = 0.0.0.0/0, ::/0
Endpoint = my.server.com:51820
```



在 my.server.com 上启动 wstunnel 服务器如下。

```
wstunnel server --restrict-to localhost:51820 wss://[::]:443
```



在本地机器上启动客户端如下。

```
wstunnel client -L 'udp://51820:localhost:51820?timeout_sec=0' wss://my.server.com:443
```



更改你的 wireguard 客户端配置为

```
[Interface]
Address = 10.200.0.2/32, fd00:cafe::2/128
PrivateKey = xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx=
# 替换为你的服务器可以访问的 dns
dns = 8.8.8.8
# https://github.com/nitred/nr-wg-mtu-finder 找到最适合你的 mtu
MTU = 1400 

[Peer]
PublicKey = 9iicV7Stdl/U0RH1BNf3VvlVjaa4Eus6QPEfEz6cR0c=
AllowedIPs = 0.0.0.0/0, ::/0
# 应该目标 wstunnel 客户端监听的端口
Endpoint = localhost:51820
# 如果启用了 wstunnel 客户端 websocket ping，应该是不必要的
PersistentKeepalive = 20
```



为你的服务器添加一条默认路由，因为你的 AllowedIps 是捕获所有，这是为了避免流量循环。

```
sudo ip route add ip.of.my.server.com dev eth0 via 192.168.0.1
# 替换 eth0（接口）和 192.168.0.1（路由器网关）为 `ip route get ip.of.my.server.com` 提供的
```



启动你的 wireguard，它应该可以工作

```
sudo wg-quick up wg0
ping 10.200.0.1 # ping 你的 vpn 网络中的另一个 ip
```



#### 透明代理（仅限 linux）

透明代理允许轻松代理任何程序。



启动 wstunnel

```
sudo wstunnel client -L 'tproxy+tcp://1080' -L 'tproxy+udp://1080' wss://my.server.com:443
```



使用这个项目无缝路由流量 https://github.com/NOBLES5E/cproxy。它适用于任何程序

```
cproxy --port 1080 --mode tproxy -- curl https://google.com
```



你甚至可以启动一个新的 shell，在那里所有的命令都将被代理

```
cproxy --port 1080 --mode tproxy -- bash
```



#### 反向隧道

启动 wstunnel

```
sudo wstunnel client -R 'tcp://[::]:8000:localhost:8000' wss://my.server.com:443
```



在另一个终端，启动一个简单的本地 web 服务器

```
python3 -m http.server
```



从你的 my.server.com 机器/网络，你现在可以执行

```
curl http://localhost:8000
```



#### 多参数示例

服务端

```
wstunnel server --websocket-ping-frequency-sec 5 --restrict-to 127.0.0.1:51220 --restrict-http-upgrade-path-prefix 8935e24d-dfa8-41fd-bdf3-8c517ea2fa84 --tls-certificate cert.crt --tls-private-key cert.key --log-lvl DEBUG wss://0.0.0.0:8443
```



客户端

```
wstunnel client wss://47.242.138.179:8443 -L udp://51220:127.0.0.1:51220?timeout_sec=0 --tls-sni-override net.xiaoshae.cn --tls-verify-certificate --http-upgrade-path-prefix 8935e24d-dfa8-41fd-bdf3-8c517ea2fa84 --websocket-ping-frequency-sec 5
```

