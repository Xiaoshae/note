# x86_64 Assembly



# 调用约定

 **调用约定是一个协议，规定了如何调用以及如何从过程返回**。

给定一组 calling convention rules，程序员无需查看子函数的定义就可以确定如何将参数传给它，高级语言编译器只要遵循这些 rules，就可以使得汇编函数和高级语言函数互相调用。

Calling conventions 有多种。我们这里介绍使用最广泛的一种：**C 语言调用约定**（C Language Calling Convention）。遵循这个约定，可以使汇编代码安全地被 C/C++ 调用 ，也可以从汇编代码调用 C 函数库。



C 调用约定:

- 强烈依赖**硬件栈**的支持 (hardwared-supported stack)
- 基于 `push`, `pop`, `call`, `ret` 指令
- 子过程**参数通过栈传递**: 寄存器保存在栈上，子过程用到的局部变量也放在栈上





## x86 调用约定

在 x86 中不论是 Windows 平台还是 Linux 平台，所有的参数传递均通过**栈传递**。

在 **Windows** 平台中有 `stdcall` 和 `cdecl` 两种调用约定。

- 大多数C/C++编译器默认使用 `cdecl` 调用约定。
- Windows API函数 默认使用`stdcall` 调用约定。

在 **Linux** 平台中默认使用 `cdecl` 调用，为了兼容性和特定需求，其他调用约定（如 `stdcall` ）也可以通过编译器选项来支持。



**参数传递**

- 在`stdcall`调用约定中，参数从**右向左压入栈**中。
- 在`cdecl`调用约定中，同样是从**右向左压入栈**中，但是**调用者负责清理栈中的参数**，而不是被调用者。

**寄存器：**

- 参数总是通过栈传递，而非寄存器。

- EAX, ECX, EDX 是易失寄存器（caller-saved），**调用者负责保存**这些寄存器的内容。
- EBX, ESI, EDI, EBP 是非易失寄存器（callee-saved），**被调用者负责保存**这些寄存器的内容。

**栈管理：**

- 对于`stdcall`，**被调用者负责**清理栈上的参数。
- 对于`cdecl`，**调用者负责**清理栈上的参数。

**返回值传递：**

- **整型或指针**返回值通过 `eax` 寄存器返回。
- **浮点返回值**通常通过**浮点栈（FPU stack）**返回。

---

示例：

```assembly
0000118d <main>:
   0x0000118d <+0>:	lea    0x4(%esp),%ecx
   0x00001191 <+4>:	and    $0xfffffff0,%esp
   0x00001194 <+7>:	push   -0x4(%ecx)
   0x00001197 <+10>:	push   %ebp
   0x00001198 <+11>:	mov    %esp,%ebp
   0x0000119a <+13>:	push   %ecx
   0x0000119b <+14>:	sub    $0x14,%esp
   0x0000119e <+17>:	call   0x1232 <__x86.get_pc_thunk.ax>
   0x000011a3 <+22>:	add    $0x2e35,%eax
   0x000011a8 <+27>:	movl   $0x0,-0xc(%ebp)
   0x000011af <+34>:	push   $0x8
   0x000011b1 <+36>:	push   $0x7
   0x000011b3 <+38>:	push   $0x6
   0x000011b5 <+40>:	push   $0x5
   0x000011b7 <+42>:	push   $0x4
   0x000011b9 <+44>:	push   $0x3
   0x000011bb <+46>:	push   $0x2
   0x000011bd <+48>:	push   $0x1
   0x000011bf <+50>:	call   0x11d7 <sum>
   0x000011c4 <+55>:	add    $0x20,%esp
   0x000011c7 <+58>:	mov    %eax,-0xc(%ebp)
   0x000011ca <+61>:	mov    $0x0,%eax
   0x000011cf <+66>:	mov    -0x4(%ebp),%ecx
   0x000011d2 <+69>:	leave
   0x000011d3 <+70>:	lea    -0x4(%ecx),%esp
   0x000011d6 <+73>:	ret

000011d7 <sum>:
   0x000011d7 <+0>:	push   %ebp
   0x000011d8 <+1>:	mov    %esp,%ebp
   0x000011da <+3>:	push   %ebx
   0x000011db <+4>:	sub    $0x14,%esp
   0x000011de <+7>:	call   0x1232 <__x86.get_pc_thunk.ax>
   0x000011e3 <+12>:	add    $0x2df5,%eax
   0x000011e8 <+17>:	movl   $0x0,-0xc(%ebp)
   0x000011ef <+24>:	mov    0x8(%ebp),%ecx
   0x000011f2 <+27>:	mov    0xc(%ebp),%edx
   0x000011f5 <+30>:	add    %edx,%ecx
   0x000011f7 <+32>:	mov    0x10(%ebp),%edx
   0x000011fa <+35>:	add    %edx,%ecx
   0x000011fc <+37>:	mov    0x18(%ebp),%edx
   0x000011ff <+40>:	add    %edx,%ecx
   0x00001201 <+42>:	mov    0x1c(%ebp),%edx
   0x00001204 <+45>:	add    %edx,%ecx
   0x00001206 <+47>:	mov    0x20(%ebp),%edx
   0x00001209 <+50>:	add    %edx,%ecx
   0x0000120b <+52>:	mov    0x24(%ebp),%edx
   0x0000120e <+55>:	add    %ecx,%edx
   0x00001210 <+57>:	mov    %edx,-0xc(%ebp)
   0x00001213 <+60>:	sub    $0x8,%esp
   0x00001216 <+63>:	push   -0xc(%ebp)
   0x00001219 <+66>:	lea    -0x1fd0(%eax),%edx
   0x0000121f <+72>:	push   %edx
   0x00001220 <+73>:	mov    %eax,%ebx
   0x00001222 <+75>:	call   0x1040 <printf@plt>
   0x00001227 <+80>:	add    $0x10,%esp
   0x0000122a <+83>:	mov    -0xc(%ebp),%eax
   0x0000122d <+86>:	mov    -0x4(%ebp),%ebx
   0x00001230 <+89>:	leave
   0x00001231 <+90>:	ret
```



## x64 调用约定

### Windows

参数传递：

- **前四个整数**或**指针参数**使用寄存器传递：`RCX`, `RDX`, `R8`, `R9`。
- 其余的参数通过**栈传递**。
- **浮点参数**使用 **XMM0 到 XMM3** 寄存器传递，**超过四个浮点参数也通过栈传递**。

寄存器：

- `RCX`, `RDX`, `R8`, `R9` 用于传递前四个整数或指针参数。
- `XMM0` 到 `XMM3` 用于传递前四个浮点参数。
- `RAX`, `RCX`, `RDX`, `R8`, `R9`, `R10`, `R11` 是易失寄存器（caller-saved），**调用者负责保存**这些寄存器的内容。
- `RBX`, `RBP`, `RDI`, `RSI`, `R12` 到 `R15` 是非易失寄存器（callee-saved），**被调用者负责保存**这些寄存器的内容。



### Linux / Unix

参数传递：

- 前**六个整数**或**指针参数**使用寄存器传递：`RDI`, `RSI`, `RDX`, `RCX`, `R8`, `R9`。
- 其余的参数通过**栈传递**。
- **浮点参数使用 XMM0 到 XMM7 寄存器传递**，超过八个浮点参数也通过栈传递。

寄存器：

- `RDI`, `RSI`, `RDX`, `RCX`, `R8`, `R9` 用于传递前六个整数或指针参数。
- `XMM0` 到 `XMM7` 用于传递前八个浮点参数。
- `RAX`, `RCX`, `RDX`, `RSI`, `RDI`, `R8` 到 `R11` 是易失寄存器（caller-saved），**调用者负责保存**这些寄存器的内容。
- `RBX`, `RBP`, `R12` 到 `R15` 是非易失寄存器（callee-saved），**被调用者负责保存**这些寄存器的内容。



注意：虽然说**调用者/被调用者**有责任保存某些寄存器，但是如果**调用者不需要使用（或者能“忍受”值被修改）易失寄存器**，则可以不保存。同理，如果**被调用者不会修改非易失寄存器的值**，则也可以不保存。

---

栈管理：

- **调用者负责**分配足够的栈空间来存储所有**通过栈传递参数**。
- **被调用者负责**分配足够的栈空间来存储所有**通过寄存器传递的参数**。虽然前6个参数通过寄存器传递，但是被调用者不会直接使用寄存器中的函数，而是先将它们保存到栈上。
- **调用者负责**清理**栈传递的参数**。
- **被调用者负责**清理**寄存器传递的参数**

返回值传递：

- **整型或指针**返回值通过 rax 寄存器返回，而**浮点**返回值通过 xmm0 返回。



C++ 的调用约定类似。隐式第一个参数（`this` 指针）通过寄存器传递。接下来的三个参数通过剩余的寄存器传递，其余参数则通过栈传递。

---

示例：

```assembly
0000000000001149 <main>:
   0x0000000000001149 <+0>:	endbr64
   0x000000000000114d <+4>:	push   %rbp
   0x000000000000114e <+5>:	mov    %rsp,%rbp
   0x0000000000001151 <+8>:	sub    $0x10,%rsp
   0x0000000000001155 <+12>:	movl   $0x0,-0x4(%rbp)
   0x000000000000115c <+19>:	push   $0x8
   0x000000000000115e <+21>:	push   $0x7
   0x0000000000001160 <+23>:	mov    $0x6,%r9d
   0x0000000000001166 <+29>:	mov    $0x5,%r8d
   0x000000000000116c <+35>:	mov    $0x4,%ecx
   0x0000000000001171 <+40>:	mov    $0x3,%edx
   0x0000000000001176 <+45>:	mov    $0x2,%esi
   0x000000000000117b <+50>:	mov    $0x1,%edi
   0x0000000000001180 <+55>:	call   0x1193 <sum>
   0x0000000000001185 <+60>:	add    $0x10,%rsp
   0x0000000000001189 <+64>:	mov    %eax,-0x4(%rbp)
   0x000000000000118c <+67>:	mov    $0x0,%eax
   0x0000000000001191 <+72>:	leave
   0x0000000000001192 <+73>:	ret

0000000000001193 <sum>:
   0x0000000000001193 <+0>:	endbr64
   0x0000000000001197 <+4>:	push   %rbp
   0x0000000000001198 <+5>:	mov    %rsp,%rbp
   0x000000000000119b <+8>:	sub    $0x30,%rsp
   0x000000000000119f <+12>:	mov    %edi,-0x14(%rbp)
   0x00000000000011a2 <+15>:	mov    %esi,-0x18(%rbp)
   0x00000000000011a5 <+18>:	mov    %edx,-0x1c(%rbp)
   0x00000000000011a8 <+21>:	mov    %ecx,-0x20(%rbp)
   0x00000000000011ab <+24>:	mov    %r8d,-0x24(%rbp)
   0x00000000000011af <+28>:	mov    %r9d,-0x28(%rbp)
   0x00000000000011b3 <+32>:	movl   $0x0,-0x4(%rbp)
   0x00000000000011ba <+39>:	mov    -0x14(%rbp),%edx
   0x00000000000011bd <+42>:	mov    -0x18(%rbp),%eax
   0x00000000000011c0 <+45>:	add    %eax,%edx
   0x00000000000011c2 <+47>:	mov    -0x1c(%rbp),%eax
   0x00000000000011c5 <+50>:	add    %eax,%edx
   0x00000000000011c7 <+52>:	mov    -0x24(%rbp),%eax
   0x00000000000011ca <+55>:	add    %eax,%edx
   0x00000000000011cc <+57>:	mov    -0x28(%rbp),%eax
   0x00000000000011cf <+60>:	add    %eax,%edx
   0x00000000000011d1 <+62>:	mov    0x10(%rbp),%eax
   0x00000000000011d4 <+65>:	add    %eax,%edx
   0x00000000000011d6 <+67>:	mov    0x18(%rbp),%eax
   0x00000000000011d9 <+70>:	add    %edx,%eax
   0x00000000000011db <+72>:	mov    %eax,-0x4(%rbp)
   0x00000000000011de <+75>:	mov    -0x4(%rbp),%eax
   0x00000000000011e1 <+78>:	mov    %eax,%esi
   0x00000000000011e3 <+80>:	lea    0xe1a(%rip),%rax        # 0x2004
   0x00000000000011ea <+87>:	mov    %rax,%rdi
   0x00000000000011ed <+90>:	mov    $0x0,%eax
   0x00000000000011f2 <+95>:	call   0x1050 <printf@plt>
   0x00000000000011f7 <+100>:	mov    -0x4(%rbp),%eax
   0x00000000000011fa <+103>:	leave
   0x00000000000011fb <+104>:	ret
```







# 其他参考

## 常用指令集

### mov

`mov` 指令用于将数据从一个位置复制到另一个位置，但不会影响标志位。

它不执行任何算术或逻辑运算，只是简单地移动数据。它的语法形式如下：

- `mov reg, imm`：将立即数（常量）复制到寄存器。
- `mov reg, reg`：将一个寄存器的内容复制到另一个寄存器。
- `mov reg, mem`：将内存中的数据复制到寄存器。
- `mov mem, reg`：将寄存器中的数据复制到内存。



### lea

`lea` 指令（Load Effective Address）用于计算内存地址并将其存储在一个寄存器中。这个指令通常用于处理指针或数组索引等需要计算地址的情况。`lea` 不会访问内存，它只计算地址值。

```
lea eax, [ebx + ecx*4] ; 计算ebx加上ecx乘以4的结果，并将结果存储在eax中
```



### call

`call` 指令用于调用子程序（函数）。当遇到`call`指令时，处理器会保存当前的指令指针（IP），然后跳转到指定的目标地址开始执行。

```
call function         ; 调用名为function的子程序
```

相当于：

```
push ip
jmp function
```



### ret

`ret` 指令用于从子程序返回。当执行到`ret`指令时，处理器会恢复之前保存的指令指针（IP），从而让程序控制流返回到调用该子程序的地方继续执行。

```
ret                  ; 返回到调用者
```

相当于：

```
pop ip
```

`ret` 指令的工作原理是直接从栈中弹出返回地址并将指令指针设置为该地址，而不需要显式的 `jmp` 操作。



### leave

将 esp 恢复，在将 ebp 从栈中恢复。相当于：

```
mov esp,ebp
pop ebp
```

