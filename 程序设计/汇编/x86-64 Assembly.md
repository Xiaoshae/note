# x86_64 Assembly



# Registers

x86 处理器有 8 个 32 bit 寄存器

![image-20241125093600158](./images/x86-64%20Assembly.assets/image-20241125093600158.png)

---

x64 扩展了 x86 的 8 个通用寄存器至 64 位，并增加了 8 个新的 64 位寄存器。64 位寄存器的名称以“r”开头。例如，eax 的 64 位扩展被称为 rax。新增加的寄存器命名为 r8 至 r15。



每个寄存器的较低 32 位、16 位和 8 位可以直接在操作数中寻址。这包括像 esi 这样的寄存器，它们的最低 8 位以前是不可寻址的。

下表指定了 64 位寄存器较低部分的汇编语言名称：

| 64 位 | 低 32 位 | 低 16 位 | 低 8 位 |
| :---- | :------- | :------- | :------ |
| rbx   | ebx      | bx       | bl      |
| rax   | eax      | ax       | al      |
| rcx   | ecx      | cx       | cl      |
| rdx   | edx      | dx       | dl      |
| rsi   | esi      | si       | sil     |
| rdi   | edi      | di       | dil     |
| rbp   | ebp      | bp       | bpl     |
| rsp   | esp      | sp       | spl     |
| r8    | r8d      | r8w      | r8b     |
| r9    | r9d      | r9w      | r9b     |
| r10   | r10d     | r10w     | r10b    |
| r11   | r11d     | r11w     | r11b    |
| r12   | r12d     | r12w     | r12b    |
| r13   | r13d     | r13w     | r13b    |
| r14   | r14d     | r14w     | r14b    |
| r15   | r15d     | r15w     | r15b    |



## ABCD 通用寄存器

`AX`、`BX`、`CX`和`DX`是通用寄存器（General-Purpose Registers）

- **ax** (Accumulator Register): 这个寄存器经常被用作累加器，还经常用来存放函数的返回值。
- **bx** (Base Register): 一些约定中，它是“非保留”的，意味着调用者可以修改它而不必担心破坏调用链。
- **cx** (Count Register): 主要用于循环指令（如`loop`）中的计数器。
- **dx** (Data Register): 通常用于存放第二个操作数，它也可以用于其他类型的数据操作。

**注：寄存器名字是早期计算机历史上流传下来的。例如，EAX 表示 Accumulator，因为它用作算术运算的累加器，ECX 表示 Counter，用来存储循环变量（计数）。但是大部分寄存器的名字已经失去了原来的意义。**



### x64

`RAX`, `RBX`, `RCX`, `RDX` 四个寄存器，可以将 64bit 低 32bit 划分为 x86 寄存器`EAX`, `EBX`, `ECX`, `EDX` 。



### x86

`EAX`, `EBX`, `ECX`, `EDX` 四个寄存器，可以再将 32bit 划分成多个子寄存器， 每个子寄存器有专门的名字。

例如 `EAX` 的高 16bit 叫 `AX`（去掉 E, E 大概表示 **Extended**）,低 8bit 叫 `AL` (**Low**）, 8-16bit 叫 `AH` （**High**）。

在汇编语言中，这些寄存器的名字是**大小写无关**的，既可以用 `EAX`，也可以写 `eax`。



## SI DI 变址寄存器

通常用于字符串操作和数据块的复制等任务中。这些寄存器的主要用途如下：

- **RSI**: 通常用于指向源数据的起始地址。
- **RDI**: 通常用于指向目标数据的起始地址。

**注：在 x64 中命名为 RSI 和 RDI，在 x86 中命名为 ESI 和 EDI 。**



```
global  _start

section .data
    s dd "Hello World!",0x0a
    t dd 13 DUP(0)


section .text

_start:
    mov rsi, s
    mov rdi, t
    mov rcx, 13

    rep movsb

    mov rax, 1
    mov rdi, 1

    mov rsi, t
    mov rdx, 13

    syscall

    mov rax, 60
    mov rdi, 0
    
    syscall
```



`rep movsb` 是一条x86汇编语言指令，用于重复执行字符串操作。

**指令解释**：

- **rep**: 表示重复执行接下来的字符串操作指令，直到计数器（通常是`ecx`寄存器，在32位模式下；或`rcx`寄存器，在64位模式下）减至0为止。
- **movsb**: 是一个单字节移动指令，它从源地址（由`esi`寄存器指向）读取一个字节，并将其写入目标地址（由`edi`寄存器指向）。同时，它会自动更新`esi`和`edi`寄存器的值，使其指向下一个字节。



`rep movsb` 指令本身不会直接控制复制的方向（前向或后向），但它会根据方向标志（Direction Flag, DF）的状态来确定如何更新源和目标指针。

默认情况下，DF 清零（0）时，`movsb` 指令向前移动（递增）源和目标指针；当 DF 设置为 1 时，它向后移动（递减）这些指针。

- `cld`（Clear Direction Flag）指令将 DF 清零，使复制向前进行。
- `std`（Set Direction Flag）指令将 DF 设置为 1，使复制向后进行。



## SP BP

`rsp` 寄存器是堆栈指针（Stack Pointer），它总是指向当前堆栈顶部的位置。

`rbp` 寄存器是基址指针（Base Pointer），它指向当前函数调用帧的底部。

**注：在 x64 中命名为 RSP 和 RBP，在 x86 中命名为 ESP 和 EBP 。**



## IP 指令寄存器

RIP（Extended Instruction Pointer）是 x64 架构中的一个寄存器。

**注：在 x64 中命名为 RIP，在 x86 中命名为 EIP 。**



RIP 用于存储当前指令的地址，每当 CPU 执行完一条指令后，RIP 通常会自动递增到下一条指令的地址，从而控制程序的流程。

RIP寄存器不能使用 移动、加法、减法 等操作来更改，而是使用跳转操作来更改。



### jmp

jmp 将程序控制转移到指令流中的不同点，而不记录返回信息。

操作数指定要跳转到的指令的地址，此操作数可以是即时值、通用寄存器或内存位置。

```
global  _start

section .data
	adrs dq 0  ; 初始化为 0，稍后我们将把 skip 的地址存入这个位置

section .text
_start:
    mov rbx, 42
    mov rax, 1
    jmp skip
    
   ;jmp 0x00000000
   
   ;mov rcx,skip
   ;jmp rcx
   
   ;lea rcx, [skip]  ; 将 skip 标签的地址加载到 ecx 寄存器
   ;mov [adrs], ecx  ; 将 skip 的地址存入 adrs
   ;jmp [adrs]        ; 从 adrs 中读取地址，并跳转到该地址
   
    mov ebx, 13
skip:
    syscall
```



**扩展：条件转移指令参考 "EFLAG 标志寄存器" 部分**





##  RFLAG标志寄存器

注：标志寄存器的名称在不同位CPU中有区别，16位为**FLAG**，32位为**EFLAG**，64位为**RFLAG**。



RFLAG寄存器用途，灰色位保留。

![img](./images/x86-64%20Assembly.assets/f547c67fe9d872479f36f761f94b8a34.png)

**注：FLAG（16位）前16位与EFLAG一致；RFLAG（64位）前32位与EFLAG一致，后32位保留。**



### ZF

ZF是零标志位。它记录相关指令执行后，其结果是否为0。

- 如果计算结果为0，那么zf=1;
- 如果计算结果不为0，那么zf=0。



### PF

PF 是奇偶标志位。它记录相关指令执行后，其结果的所有 bit 位中 1的个数是否为偶数。

- 如果1的个数为偶数，pf=1；
- 如果1的个数为奇数，pf=0。



### SF

SF 是符号标志位。它记录相关指令执行后，其结果是否为负。

- 如果结果为负，sf=1;
- 如果结果非负，sf=0。



00000001B，可以看作为无符号数1，或有符号数+1;

10000001B，可以看作为无符号数129，也可以看作有符号数-127。



例1：

同一个二进制数据，计算机可以将它当作无符号数据来运算，也可以当作有符号数据来运算。比如:

```
mov al,10000001B
add al,1
```

结果：(al)=10000010B。

将 add 指令进行的运算当作**无符号数**的运算，那么 add 指令相当于计算 129+1,结果为 130(10000010B);

将 add 指令进行的运算当作**有符号数**的运算，那么 add 指令相当于计算-127+1，结果为-126(10000010B)。



例2：

```
mov al,10000001B
add al,01111111B
```

执行后，结果为 0，sf=0，表示：如果指令进行的是有符号数运算，那么结果为非负。



不管我们如何看待，CPU 在执行 add 等指令的时候，就已经包含了两种含义，也将得到用同一种信息来记录的两种结果。关键在于我们的程序需要哪一种结果。



### CF

CF 标志表示最近一次算术或逻辑操作是否产生了进位或借位。

- 当进行无符号加法时，如果最高有效位（MSB）产生了进位，则 CF 被置为 1；如果没有产生进位，则 CF 保持为 0。

    ```
    MOV RAX, 0xFFFFFFFF ; RAX = -1 (无符号为 4294967295)
    ADD RAX, 1          ; RAX + 1 = 0 (产生进位)
    ; 此时 CF = 1
    ```

- 当进行无符号减法时，如果 MSB 需要向更高位借位，则 CF 被置为 1；如果没有借位，则 CF 保持为 0。

    ```
    MOV RAX, 1
    SUB RAX, 2          ; RAX - 2 = -1 (无符号为 4294967295, 需要借位)
    ; 此时 CF = 1
    ```

    

### OF

OF 标志表示最近一次算术操作（通常是加法或减法）是否产生了带符号整数溢出。

- 当进行**带符号加法**时，如果正数加上正数的结果变成了负数，或者负数加上负数的结果变成了正数，则 OF 被置为 1；否则，OF 保持为 0。
- 当进行**带符号减法**时，如果正数减去负数的结果变成了负数，或者负数减去正数的结果变成了正数，则 OF 被置为 1；否则，OF 保持为 0。



### cmp

cmp 是比较指令，cmp的功能相当于减法指令，只是不保存结果。cmp指令执行后，将对标志寄存器产生影响。



### 条件转移指令

简化版本

| 指令 | 描述       | 有符号/无符号 | 检查的条件        |
| ---- | ---------- | ------------- | ----------------- |
| JE   | 当相等时   |               | ZF = 1            |
| JNE  | 当不等时   |               | ZF = 0            |
| JB   | 当小于     | 无符号        | CF = 1            |
| JNB  | 当大于等于 | 无符号        | CF = 0            |
| JA   | 当大于     | 无符号        | CF = 0 且 ZF = 0  |
| JNA  | 当小于等于 | 无符号        | CF = 1 或 ZF = 1  |
| JL   | 当小于     | 有符号        | SF ≠ OF           |
| JNL  | 当大于等于 | 有符号        | SF = OF           |
| JG   | 当大于     | 有符号        | ZF = 0 且 SF = OF |
| JNG  | 当小于等于 | 有符号        | ZF = 1 或 SF ≠ OF |



这些指令比较常用，它们都很好记忆，它们的第一个字母都是j，表示jump；后面的字母表示意义如下。

```
e:  表示 equal
ne: 表示 not equal
b:  表示 below
nb: 表示 not below
a:  表示 above
na: 表示 not above
l:  表示 less
nl: 表示 not less
g:  表示 greater
ng: 表示 not greater
```



完整版本

| 指令                 | 描述                                      | 有符号/无符号 | 检查的条件                   |
| -------------------- | ----------------------------------------- | ------------- | ---------------------------- |
| JO                   | 当发生溢出时跳转                          |               | OF = 1                       |
| JNO                  | 当没有发生溢出时跳转                      |               | OF = 0                       |
| JS                   | 当符号为负时跳转                          | 有符号        | SF = 1                       |
| JNS                  | 当符号为非负时跳转                        | 有符号        | SF = 0                       |
| JE / JZ              | 当相等时/当零时跳转                       |               | ZF = 1                       |
| JNE / JNZ            | 当不等时/当非零时跳转                     |               | ZF = 0                       |
| JP / JPE             | 当具有偶数位奇偶性时/当偶数位奇偶性时跳转 |               | PF = 1                       |
| JNP / JPO            | 当具有奇数位奇偶性时/当奇数位奇偶性时跳转 |               | PF = 0                       |
| JCXZ / JECXZ / JRCXZ | 当 CX/ECX/RCX 为零时跳转                  |               | CX = 0<br>ECX = 0<br>RCX = 0 |
| JB / JNAE / JC       | 当低于/当不大于或等于/当进位时跳转        | 无符号        | CF = 1                       |
| JNB / JAE / JNC      | 当不低于/当大于或等于/当没有进位时跳转    | 无符号        | CF = 0                       |
| JBE / JNA            | 当低于或等于/当不大于时跳转               | 无符号        | CF = 1 或 ZF = 1             |
| JA / JNBE            | 当高于/当不小于或等于时跳转               | 无符号        | CF = 0 且 ZF = 0             |
| JL / JNGE            | 当小于/当不大于或等于时跳转               | 有符号        | SF ≠ OF                      |
| JGE / JNL            | 当大于或等于/当不小于时跳转               | 有符号        | SF = OF                      |
| JLE / JNG            | 当小于或等于/当不大于时跳转               | 有符号        | ZF = 1 或 SF ≠ OF            |
| JG / JNLE            | 当大于/当不小于或等于时跳转               | 有符号        | ZF = 0 且 SF = OF            |



## R8 - R15

这 8 个寄存器是 x86-64 架构新增的寄存器，主要用于作为通用寄存器使用。

- **易失性寄存器**：在函数调用期间可能被编译器重写，如 `rax`, `rcx`, `rdx`, `r8`-`r11`。
- **非易失性寄存器**：在函数调用期间必须由函数调用者保存和恢复，如 `rbx`, `rbp`, `rsi`, `rdi`, `r12`-`r15`。



## 浮点寄存器

x64 处理器还提供了几组浮点寄存器：

- 八个 80 位 x87 寄存器。
- 八个 64 位 MMX 寄存器。（这些寄存器与 x87 寄存器重叠。）
- 原来的八个 128 位 SSE 寄存器增加到了十六个。



## 其他

![image-20240801143340414](./images/x86-64%20Assembly.assets/image-20240801143340414.png)



# 段

## .bss

`.bss`（Block Started by Symbol）是Unix和类Unix操作系统中程序的未初始化全局变量和静态局部变量存储的区域。它是在可执行文件格式（如ELF、a.out等）中定义的一部分，用于保存那些在程序编译时声明但没有明确赋值的变量。

1. **未初始化数据**：`.bss` 段包含了所有未初始化的全局变量和静态局部变量。这些变量在程序开始运行之前并不占用实际的内存空间；它们只存在于二进制文件的元数据中。当程序加载到内存中时，操作系统会为这些变量分配零值初始化的空间。
2. **节省磁盘空间**：由于`.bss`段中的数据在程序编译时并未被赋予具体的值，因此在磁盘上的可执行文件中不需要占用实际的字节来表示这些变量。相反，只需要记录每个变量的大小和位置信息。这样可以有效地减少可执行文件的大小。
3. **内存映射**：当一个程序被加载到内存中运行时，操作系统负责将`.bss`段映射到进程的虚拟地址空间，并为其中的每一个变量分配适当的内存并设置其初始值为0。
4. **动态调整**：在某些情况下，`.bss`段的大小可以在程序运行期间动态改变，但这通常需要特殊的编程技巧或使用特定的操作系统调用。
5. **与数据段的区别**：`.bss`段和数据段（.data）不同，后者包含已初始化的全局变量和静态局部变量。数据段中的变量在可执行文件中有明确的初始值，而`.bss`段中的变量则默认初始化为0。
6. **链接器的角色**：链接器在创建最终的可执行文件时，会合并来自多个源文件的所有`.bss`段，形成一个连续的内存区域，以便于操作系统的加载器处理。
7. **调试和优化**：了解`.bss`段可以帮助开发者更好地理解程序的内存布局，有助于进行性能优化和内存管理。此外，在调试过程中，知道哪些变量位于`.bss`段可以帮助定位和解决某些类型的错误。



## .data

`.DATA` 声明静态数据区。

数据类型修饰原语：

- `DB`: Byte		        1 Bytes
- `DW`: Word      	        2 Bytes
- `DD`: Double Word	4 Bytes
- `DQ`: Quad Word	   8 Bytes





# 调用约定

 **调用约定是一个协议，规定了如何调用以及如何从过程返回**。

给定一组 calling convention rules，程序员无需查看子函数的定义就可以确定如何将参数传给它，高级语言编译器只要遵循这些 rules，就可以使得汇编函数和高级语言函数互相调用。

Calling conventions 有多种。我们这里介绍使用最广泛的一种：**C 语言调用约定**（C Language Calling Convention）。遵循这个约定，可以使汇编代码安全地被 C/C++ 调用 ，也可以从汇编代码调用 C 函数库。



C 调用约定:

- 强烈依赖**硬件栈**的支持 (hardwared-supported stack)
- 基于 `push`, `pop`, `call`, `ret` 指令
- 子过程**参数通过栈传递**: 寄存器保存在栈上，子过程用到的局部变量也放在栈上





## x86 调用约定

在 x86 中不论是 Windows 平台还是 Linux 平台，所有的参数传递均通过**栈传递**。

在 **Windows** 平台中有 `stdcall` 和 `cdecl` 两种调用约定。

- 大多数C/C++编译器默认使用 `cdecl` 调用约定。
- Windows API函数 默认使用`stdcall` 调用约定。

在 **Linux** 平台中默认使用 `cdecl` 调用，为了兼容性和特定需求，其他调用约定（如 `stdcall` ）也可以通过编译器选项来支持。



**参数传递**

- 在`stdcall`调用约定中，参数从**右向左压入栈**中。
- 在`cdecl`调用约定中，同样是从**右向左压入栈**中，但是**调用者负责清理栈中的参数**，而不是被调用者。

**寄存器：**

- 参数总是通过栈传递，而非寄存器。

- EAX, ECX, EDX 是易失寄存器（caller-saved），**调用者负责保存**这些寄存器的内容。
- EBX, ESI, EDI, EBP 是非易失寄存器（callee-saved），**被调用者负责保存**这些寄存器的内容。

**栈管理：**

- 对于`stdcall`，**被调用者负责**清理栈上的参数。
- 对于`cdecl`，**调用者负责**清理栈上的参数。

**返回值传递：**

- **整型或指针**返回值通过 `eax` 寄存器返回。
- **浮点返回值**通常通过**浮点栈（FPU stack）**返回。

---

示例：

```assembly
0000118d <main>:
   0x0000118d <+0>:	lea    0x4(%esp),%ecx
   0x00001191 <+4>:	and    $0xfffffff0,%esp
   0x00001194 <+7>:	push   -0x4(%ecx)
   0x00001197 <+10>:	push   %ebp
   0x00001198 <+11>:	mov    %esp,%ebp
   0x0000119a <+13>:	push   %ecx
   0x0000119b <+14>:	sub    $0x14,%esp
   0x0000119e <+17>:	call   0x1232 <__x86.get_pc_thunk.ax>
   0x000011a3 <+22>:	add    $0x2e35,%eax
   0x000011a8 <+27>:	movl   $0x0,-0xc(%ebp)
   0x000011af <+34>:	push   $0x8
   0x000011b1 <+36>:	push   $0x7
   0x000011b3 <+38>:	push   $0x6
   0x000011b5 <+40>:	push   $0x5
   0x000011b7 <+42>:	push   $0x4
   0x000011b9 <+44>:	push   $0x3
   0x000011bb <+46>:	push   $0x2
   0x000011bd <+48>:	push   $0x1
   0x000011bf <+50>:	call   0x11d7 <sum>
   0x000011c4 <+55>:	add    $0x20,%esp
   0x000011c7 <+58>:	mov    %eax,-0xc(%ebp)
   0x000011ca <+61>:	mov    $0x0,%eax
   0x000011cf <+66>:	mov    -0x4(%ebp),%ecx
   0x000011d2 <+69>:	leave
   0x000011d3 <+70>:	lea    -0x4(%ecx),%esp
   0x000011d6 <+73>:	ret

000011d7 <sum>:
   0x000011d7 <+0>:	push   %ebp
   0x000011d8 <+1>:	mov    %esp,%ebp
   0x000011da <+3>:	push   %ebx
   0x000011db <+4>:	sub    $0x14,%esp
   0x000011de <+7>:	call   0x1232 <__x86.get_pc_thunk.ax>
   0x000011e3 <+12>:	add    $0x2df5,%eax
   0x000011e8 <+17>:	movl   $0x0,-0xc(%ebp)
   0x000011ef <+24>:	mov    0x8(%ebp),%ecx
   0x000011f2 <+27>:	mov    0xc(%ebp),%edx
   0x000011f5 <+30>:	add    %edx,%ecx
   0x000011f7 <+32>:	mov    0x10(%ebp),%edx
   0x000011fa <+35>:	add    %edx,%ecx
   0x000011fc <+37>:	mov    0x18(%ebp),%edx
   0x000011ff <+40>:	add    %edx,%ecx
   0x00001201 <+42>:	mov    0x1c(%ebp),%edx
   0x00001204 <+45>:	add    %edx,%ecx
   0x00001206 <+47>:	mov    0x20(%ebp),%edx
   0x00001209 <+50>:	add    %edx,%ecx
   0x0000120b <+52>:	mov    0x24(%ebp),%edx
   0x0000120e <+55>:	add    %ecx,%edx
   0x00001210 <+57>:	mov    %edx,-0xc(%ebp)
   0x00001213 <+60>:	sub    $0x8,%esp
   0x00001216 <+63>:	push   -0xc(%ebp)
   0x00001219 <+66>:	lea    -0x1fd0(%eax),%edx
   0x0000121f <+72>:	push   %edx
   0x00001220 <+73>:	mov    %eax,%ebx
   0x00001222 <+75>:	call   0x1040 <printf@plt>
   0x00001227 <+80>:	add    $0x10,%esp
   0x0000122a <+83>:	mov    -0xc(%ebp),%eax
   0x0000122d <+86>:	mov    -0x4(%ebp),%ebx
   0x00001230 <+89>:	leave
   0x00001231 <+90>:	ret
```



## x64 调用约定

### Windows

参数传递：

- **前四个整数**或**指针参数**使用寄存器传递：`RCX`, `RDX`, `R8`, `R9`。
- 其余的参数通过**栈传递**。
- **浮点参数**使用 **XMM0 到 XMM3** 寄存器传递，**超过四个浮点参数也通过栈传递**。

寄存器：

- `RCX`, `RDX`, `R8`, `R9` 用于传递前四个整数或指针参数。
- `XMM0` 到 `XMM3` 用于传递前四个浮点参数。
- `RAX`, `RCX`, `RDX`, `R8`, `R9`, `R10`, `R11` 是易失寄存器（caller-saved），**调用者负责保存**这些寄存器的内容。
- `RBX`, `RBP`, `RDI`, `RSI`, `R12` 到 `R15` 是非易失寄存器（callee-saved），**被调用者负责保存**这些寄存器的内容。



### Linux / Unix

参数传递：

- 前**六个整数**或**指针参数**使用寄存器传递：`RDI`, `RSI`, `RDX`, `RCX`, `R8`, `R9`。
- 其余的参数通过**栈传递**。
- **浮点参数使用 XMM0 到 XMM7 寄存器传递**，超过八个浮点参数也通过栈传递。

寄存器：

- `RDI`, `RSI`, `RDX`, `RCX`, `R8`, `R9` 用于传递前六个整数或指针参数。
- `XMM0` 到 `XMM7` 用于传递前八个浮点参数。
- `RAX`, `RCX`, `RDX`, `RSI`, `RDI`, `R8` 到 `R11` 是易失寄存器（caller-saved），**调用者负责保存**这些寄存器的内容。
- `RBX`, `RBP`, `R12` 到 `R15` 是非易失寄存器（callee-saved），**被调用者负责保存**这些寄存器的内容。



注意：虽然说**调用者/被调用者**有责任保存某些寄存器，但是如果**调用者不需要使用（或者能“忍受”值被修改）易失寄存器**，则可以不保存。同理，如果**被调用者不会修改非易失寄存器的值**，则也可以不保存。

---

栈管理：

- **调用者负责**分配足够的栈空间来存储所有**通过栈传递参数**。
- **被调用者负责**分配足够的栈空间来存储所有**通过寄存器传递的参数**。虽然前6个参数通过寄存器传递，但是被调用者不会直接使用寄存器中的函数，而是先将它们保存到栈上。
- **调用者负责**清理**栈传递的参数**。
- **被调用者负责**清理**寄存器传递的参数**

返回值传递：

- **整型或指针**返回值通过 rax 寄存器返回，而**浮点**返回值通过 xmm0 返回。



C++ 的调用约定类似。隐式第一个参数（`this` 指针）通过寄存器传递。接下来的三个参数通过剩余的寄存器传递，其余参数则通过栈传递。

---

示例：

```assembly
0000000000001149 <main>:
   0x0000000000001149 <+0>:	endbr64
   0x000000000000114d <+4>:	push   %rbp
   0x000000000000114e <+5>:	mov    %rsp,%rbp
   0x0000000000001151 <+8>:	sub    $0x10,%rsp
   0x0000000000001155 <+12>:	movl   $0x0,-0x4(%rbp)
   0x000000000000115c <+19>:	push   $0x8
   0x000000000000115e <+21>:	push   $0x7
   0x0000000000001160 <+23>:	mov    $0x6,%r9d
   0x0000000000001166 <+29>:	mov    $0x5,%r8d
   0x000000000000116c <+35>:	mov    $0x4,%ecx
   0x0000000000001171 <+40>:	mov    $0x3,%edx
   0x0000000000001176 <+45>:	mov    $0x2,%esi
   0x000000000000117b <+50>:	mov    $0x1,%edi
   0x0000000000001180 <+55>:	call   0x1193 <sum>
   0x0000000000001185 <+60>:	add    $0x10,%rsp
   0x0000000000001189 <+64>:	mov    %eax,-0x4(%rbp)
   0x000000000000118c <+67>:	mov    $0x0,%eax
   0x0000000000001191 <+72>:	leave
   0x0000000000001192 <+73>:	ret

0000000000001193 <sum>:
   0x0000000000001193 <+0>:	endbr64
   0x0000000000001197 <+4>:	push   %rbp
   0x0000000000001198 <+5>:	mov    %rsp,%rbp
   0x000000000000119b <+8>:	sub    $0x30,%rsp
   0x000000000000119f <+12>:	mov    %edi,-0x14(%rbp)
   0x00000000000011a2 <+15>:	mov    %esi,-0x18(%rbp)
   0x00000000000011a5 <+18>:	mov    %edx,-0x1c(%rbp)
   0x00000000000011a8 <+21>:	mov    %ecx,-0x20(%rbp)
   0x00000000000011ab <+24>:	mov    %r8d,-0x24(%rbp)
   0x00000000000011af <+28>:	mov    %r9d,-0x28(%rbp)
   0x00000000000011b3 <+32>:	movl   $0x0,-0x4(%rbp)
   0x00000000000011ba <+39>:	mov    -0x14(%rbp),%edx
   0x00000000000011bd <+42>:	mov    -0x18(%rbp),%eax
   0x00000000000011c0 <+45>:	add    %eax,%edx
   0x00000000000011c2 <+47>:	mov    -0x1c(%rbp),%eax
   0x00000000000011c5 <+50>:	add    %eax,%edx
   0x00000000000011c7 <+52>:	mov    -0x24(%rbp),%eax
   0x00000000000011ca <+55>:	add    %eax,%edx
   0x00000000000011cc <+57>:	mov    -0x28(%rbp),%eax
   0x00000000000011cf <+60>:	add    %eax,%edx
   0x00000000000011d1 <+62>:	mov    0x10(%rbp),%eax
   0x00000000000011d4 <+65>:	add    %eax,%edx
   0x00000000000011d6 <+67>:	mov    0x18(%rbp),%eax
   0x00000000000011d9 <+70>:	add    %edx,%eax
   0x00000000000011db <+72>:	mov    %eax,-0x4(%rbp)
   0x00000000000011de <+75>:	mov    -0x4(%rbp),%eax
   0x00000000000011e1 <+78>:	mov    %eax,%esi
   0x00000000000011e3 <+80>:	lea    0xe1a(%rip),%rax        # 0x2004
   0x00000000000011ea <+87>:	mov    %rax,%rdi
   0x00000000000011ed <+90>:	mov    $0x0,%eax
   0x00000000000011f2 <+95>:	call   0x1050 <printf@plt>
   0x00000000000011f7 <+100>:	mov    -0x4(%rbp),%eax
   0x00000000000011fa <+103>:	leave
   0x00000000000011fb <+104>:	ret
```



# 地址模式

在64位模式（也称为x64或AMD64）下，地址模式与传统的x86架构相比有了一些变化，这些变化旨在提高性能并支持更大的内存空间。

1. 64位寄存器的默认使用

- 在64位模式中，指令默认操作64位宽的寄存器。例如，使用`mov rax, [rbx]`指令时，它会自动从`rbx`开始的内存位置读取8字节（即64位）的数据，并将其加载到`rax`寄存器中。
- 这种默认行为简化了代码编写，同时也确保了对大内存的支持。



2. 立即数和常量地址的处理

- 对于需要立即数或常量地址的指令，64位模式引入了一种特殊的`mov`指令形式来处理64位立即数或地址。
- 然而，除了这种特殊形式的`mov`指令外，大多数其他指令仍然使用32位立即数或地址。这意味着，在多数情况下，立即数或地址仍然限制在32位范围内。



3. 新的RIP相对寻址模式

- x64架构引入了基于RIP（Instruction Pointer，指令指针）的相对寻址模式。这种寻址方式允许指令中的地址字段指定为相对于当前指令地址的一个偏移量。
- 当执行如`mov rax, [addr]`这样的指令时，实际上是从地址`addr + rip`处读取8字节的数据到`rax`寄存器中。这里，`rip`是指令执行时的当前指令指针值。
- RIP相对寻址特别适用于定位静态数据和函数地址，因为它可以减少代码大小并且有利于位置无关代码的生成。



# 内存模式

## 端序（Endianness）

端序（Endianness）是指多字节数据类型（如整数、浮点数等）在计算机内存中的存储顺序。也就是数据类型的高位字节和低位字节是如何排列的。

主要存在两种不同的端序：

### 大端序（Big-Endian, BE）

在大端序系统中，**最高有效字节（Most Significant Byte, MSB）被存储在最小的地址上**，而最低有效字节（Least Significant Byte, LSB）被存储在最大的地址上。

这种表示方法与人类阅读数字的习惯一致，从左到右，**先读高位再读低位**。



对于一个 **32 位整数 67305985** ，其二进制表示为：

```
00000100 00000011 00000010 00000001
```

在内存中存储为：

```
0x000: 00000100 00000011 00000010 00000001

0x000: 00000100
0x001: 00000011
0x002: 00000010
0x003: 00000001
```



### 小端序（Little-Endian, LE）

在小端序系统中，**最低有效字节被存储在最小的地址上**，而最高有效字节被存储在最大的地址上。

这种表示方法与人类阅读数字的习惯相反，从右到左，**先读低位再读高位**。



对于一个 **32 位整数 67305985** ，其二进制表示为：

```
00000100 00000011 00000010 00000001
```

在内存中存储为：

```
0x000: 00000001 00000010 00000011 00000100

0x000: 00000001
0x001: 00000010
0x002: 00000011
0x003: 00000100
```

注意：这里相当于**按字节进行了镜像**，但是**没有按位进行镜像**。



# 其他参考

## 常用指令集

### mov

`mov` 指令用于将数据从一个位置复制到另一个位置，但不会影响标志位。

它不执行任何算术或逻辑运算，只是简单地移动数据。它的语法形式如下：

- `mov reg, imm`：将立即数（常量）复制到寄存器。
- `mov reg, reg`：将一个寄存器的内容复制到另一个寄存器。
- `mov reg, mem`：将内存中的数据复制到寄存器。
- `mov mem, reg`：将寄存器中的数据复制到内存。



### lea

`lea` 指令（Load Effective Address）用于计算内存地址并将其存储在一个寄存器中。这个指令通常用于处理指针或数组索引等需要计算地址的情况。`lea` 不会访问内存，它只计算地址值。

```
lea eax, [ebx + ecx*4] ; 计算ebx加上ecx乘以4的结果，并将结果存储在eax中
```



### call

`call` 指令用于调用子程序（函数）。当遇到`call`指令时，处理器会保存当前的指令指针（IP），然后跳转到指定的目标地址开始执行。

```
call function         ; 调用名为function的子程序
```

相当于：

```
push ip
jmp function
```



### ret

`ret` 指令用于从子程序返回。当执行到`ret`指令时，处理器会恢复之前保存的指令指针（IP），从而让程序控制流返回到调用该子程序的地方继续执行。

```
ret                  ; 返回到调用者
```

相当于：

```
pop ip
```

`ret` 指令的工作原理是直接从栈中弹出返回地址并将指令指针设置为该地址，而不需要显式的 `jmp` 操作。



### leave

将 esp 恢复，在将 ebp 从栈中恢复。相当于：

```
mov esp,ebp
pop ebp
```

