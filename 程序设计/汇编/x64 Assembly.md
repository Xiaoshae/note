# x64 Assembly

x64 架构是 x86 的向后兼容扩展。它提供了一种新的 64 位模式和一种与 x86 完全相同的遗留 32 位模式。

术语“x64”包含了 AMD64 和 Intel64。这两种指令集几乎相同。



# Registers

x64 扩展了 x86 的 8 个通用寄存器至 64 位，并增加了 8 个新的 64 位寄存器。64 位寄存器的名称以“r”开头。例如，eax 的 64 位扩展被称为 rax。新增加的寄存器命名为 r8 至 r15。



每个寄存器的较低 32 位、16 位和 8 位可以直接在操作数中寻址。这包括像 esi 这样的寄存器，它们的最低 8 位以前是不可寻址的。

下表指定了 64 位寄存器较低部分的汇编语言名称：

| 64 位 | 低 32 位 | 低 16 位 | 低 8 位 |
| :---- | :------- | :------- | :------ |
| rbx   | ebx      | bx       | bl      |
| rax   | eax      | ax       | al      |
| rcx   | ecx      | cx       | cl      |
| rdx   | edx      | dx       | dl      |
| rsi   | esi      | si       | sil     |
| rdi   | edi      | di       | dil     |
| rbp   | ebp      | bp       | bpl     |
| rsp   | esp      | sp       | spl     |
| r8    | r8d      | r8w      | r8b     |
| r9    | r9d      | r9w      | r9b     |
| r10   | r10d     | r10w     | r10b    |
| r11   | r11d     | r11w     | r11b    |
| r12   | r12d     | r12w     | r12b    |
| r13   | r13d     | r13w     | r13b    |
| r14   | r14d     | r14w     | r14b    |
| r15   | r15d     | r15w     | r15b    |



## ABCD 通用寄存器

`RAX`、`RBX`、`RCX`和`RDX` 是通用寄存器（General-Purpose Registers）

- **rax** (Accumulator Register): 通常用于存储函数调用的返回结果，也用于乘法和除法指令中。
- **rbx** (Base Register): 通常用作通用寄存器，没有特定的用途。
- **rcx** (Count Register): 通常用于循环指令和字符串操作指令的计数器。
- **rdx** (Data Register): 通常用于乘法和除法指令，与 `rax` 一起存储结果。也可以用作通用寄存器。



## RSI RDI 变址寄存器

通常用于字符串操作和数据块的复制等任务中。这些寄存器的主要用途如下：

- **rsi**: 通常用于指向源数据的起始地址。
- **rdi**: 通常用于指向目标数据的起始地址。



```
global  _start

section .data
    s dd "Hello World!",0x0a
    t dd 13 DUP(0)


section .text

_start:
    mov rsi, s
    mov rdi, t
    mov rcx, 13

    rep movsb

    mov rax, 1
    mov rdi, 1

    mov rsi, t
    mov rdx, 13

    syscall

    mov rax, 60
    mov rdi, 0
    
    syscall
```



`rep movsb` 是一条x86汇编语言指令，用于重复执行字符串操作。

**指令解释**：

- **rep**: 表示重复执行接下来的字符串操作指令，直到计数器（通常是`ecx`寄存器，在32位模式下；或`rcx`寄存器，在64位模式下）减至0为止。
- **movsb**: 是一个单字节移动指令，它从源地址（由`esi`寄存器指向）读取一个字节，并将其写入目标地址（由`edi`寄存器指向）。同时，它会自动更新`esi`和`edi`寄存器的值，使其指向下一个字节。



`rep movsb` 指令本身不会直接控制复制的方向（前向或后向），但它会根据方向标志（Direction Flag, DF）的状态来确定如何更新源和目标指针。

默认情况下，DF 清零（0）时，`movsb` 指令向前移动（递增）源和目标指针；当 DF 设置为 1 时，它向后移动（递减）这些指针。

- `cld`（Clear Direction Flag）指令将 DF 清零，使复制向前进行。
- `std`（Set Direction Flag）指令将 DF 设置为 1，使复制向后进行。



## RSP RBP

`rsp` 寄存器是堆栈指针（Stack Pointer），它总是指向当前堆栈顶部的位置。

`rbp` 寄存器是基址指针（Base Pointer），它指向当前函数调用帧的底部。



## RIP 指令寄存器

RIP（Extended Instruction Pointer）是 x86 架构中的一个寄存器。

RIP 用于存储当前指令的地址，每当 CPU 执行完一条指令后，RIP 通常会自动递增到下一条指令的地址，从而控制程序的流程。



RIP寄存器不能使用 移动、加法、减法 等操作来更改，而是使用跳转操作来更改。



### jmp

jmp 将程序控制转移到指令流中的不同点，而不记录返回信息。

操作数指定要跳转到的指令的地址，此操作数可以是即时值、通用寄存器或内存位置。

```
global  _start

section .data
	adrs dq 0  ; 初始化为 0，稍后我们将把 skip 的地址存入这个位置

section .text
_start:
    mov rbx, 42
    mov rax, 1
    jmp skip
    
   ;jmp 0x00000000
   
   ;mov rcx,skip
   ;jmp rcx
   
   ;lea rcx, [skip]  ; 将 skip 标签的地址加载到 ecx 寄存器
   ;mov [adrs], ecx  ; 将 skip 的地址存入 adrs
   ;jmp [adrs]        ; 从 adrs 中读取地址，并跳转到该地址
   
    mov ebx, 13
skip:
    syscall
```



**扩展：条件转移指令参考 "EFLAG 标志寄存器" 部分**



##  RFLAG标志寄存器

注：标志寄存器的名称在不同位CPU中有区别，16位为**FLAG**，32位为**EFLAG**，64位为**RFLAG**。



RFLAG寄存器用途，灰色位保留。

![img](./images/x64%20Assembly.assets/f547c67fe9d872479f36f761f94b8a34.png)

**注：FLAG（16位）前16位与EFLAG一致；RFLAG（64位）前32位与EFLAG一致，后32位保留。**



### ZF

ZF是零标志位。它记录相关指令执行后，其结果是否为0。

- 如果计算结果为0，那么zf=1;
- 如果计算结果不为0，那么zf=0。



### PF

PF 是奇偶标志位。它记录相关指令执行后，其结果的所有 bit 位中 1的个数是否为偶数。

- 如果1的个数为偶数，pf=1；
- 如果1的个数为奇数，pf=0。



### SF

SF 是符号标志位。它记录相关指令执行后，其结果是否为负。

- 如果结果为负，sf=1;
- 如果结果非负，sf=0。



00000001B，可以看作为无符号数1，或有符号数+1;

10000001B，可以看作为无符号数129，也可以看作有符号数-127。



例1：

同一个二进制数据，计算机可以将它当作无符号数据来运算，也可以当作有符号数据来运算。比如:

```
mov al,10000001B
add al,1
```

结果：(al)=10000010B。

将 add 指令进行的运算当作**无符号数**的运算，那么 add 指令相当于计算 129+1,结果为 130(10000010B);

将 add 指令进行的运算当作**有符号数**的运算，那么 add 指令相当于计算-127+1，结果为-126(10000010B)。



例2：

```
mov al,10000001B
add al,01111111B
```

执行后，结果为 0，sf=0，表示：如果指令进行的是有符号数运算，那么结果为非负。



不管我们如何看待，CPU 在执行 add 等指令的时候，就已经包含了两种含义，也将得到用同一种信息来记录的两种结果。关键在于我们的程序需要哪一种结果。



### CF

CF 标志表示最近一次算术或逻辑操作是否产生了进位或借位。

- 当进行无符号加法时，如果最高有效位（MSB）产生了进位，则 CF 被置为 1；如果没有产生进位，则 CF 保持为 0。

  ```
  MOV RAX, 0xFFFFFFFF ; RAX = -1 (无符号为 4294967295)
  ADD RAX, 1          ; RAX + 1 = 0 (产生进位)
  ; 此时 CF = 1
  ```

- 当进行无符号减法时，如果 MSB 需要向更高位借位，则 CF 被置为 1；如果没有借位，则 CF 保持为 0。

  ```
  MOV RAX, 1
  SUB RAX, 2          ; RAX - 2 = -1 (无符号为 4294967295, 需要借位)
  ; 此时 CF = 1
  ```

  

### OF

OF 标志表示最近一次算术操作（通常是加法或减法）是否产生了带符号整数溢出。

- 当进行**带符号加法**时，如果正数加上正数的结果变成了负数，或者负数加上负数的结果变成了正数，则 OF 被置为 1；否则，OF 保持为 0。
- 当进行**带符号减法**时，如果正数减去负数的结果变成了负数，或者负数减去正数的结果变成了正数，则 OF 被置为 1；否则，OF 保持为 0。



### cmp

cmp 是比较指令，cmp的功能相当于减法指令，只是不保存结果。cmp指令执行后，将对标志寄存器产生影响。



### 条件转移指令

简化版本

| 指令 | 描述       | 有符号/无符号 | 检查的条件        |
| ---- | ---------- | ------------- | ----------------- |
| JE   | 当相等时   |               | ZF = 1            |
| JNE  | 当不等时   |               | ZF = 0            |
| JB   | 当小于     | 无符号        | CF = 1            |
| JNB  | 当大于等于 | 无符号        | CF = 0            |
| JA   | 当大于     | 无符号        | CF = 0 且 ZF = 0  |
| JNA  | 当小于等于 | 无符号        | CF = 1 或 ZF = 1  |
| JL   | 当小于     | 有符号        | SF ≠ OF           |
| JNL  | 当大于等于 | 有符号        | SF = OF           |
| JG   | 当大于     | 有符号        | ZF = 0 且 SF = OF |
| JNG  | 当小于等于 | 有符号        | ZF = 1 或 SF ≠ OF |



这些指令比较常用，它们都很好记忆，它们的第一个字母都是j，表示jump；后面的字母表示意义如下。

```
e:  表示 equal
ne: 表示 not equal
b:  表示 below
nb: 表示 not below
a:  表示 above
na: 表示 not above
l:  表示 less
nl: 表示 not less
g:  表示 greater
ng: 表示 not greater
```



完整版本

| 指令                 | 描述                                      | 有符号/无符号 | 检查的条件                   |
| -------------------- | ----------------------------------------- | ------------- | ---------------------------- |
| JO                   | 当发生溢出时跳转                          |               | OF = 1                       |
| JNO                  | 当没有发生溢出时跳转                      |               | OF = 0                       |
| JS                   | 当符号为负时跳转                          | 有符号        | SF = 1                       |
| JNS                  | 当符号为非负时跳转                        | 有符号        | SF = 0                       |
| JE / JZ              | 当相等时/当零时跳转                       |               | ZF = 1                       |
| JNE / JNZ            | 当不等时/当非零时跳转                     |               | ZF = 0                       |
| JP / JPE             | 当具有偶数位奇偶性时/当偶数位奇偶性时跳转 |               | PF = 1                       |
| JNP / JPO            | 当具有奇数位奇偶性时/当奇数位奇偶性时跳转 |               | PF = 0                       |
| JCXZ / JECXZ / JRCXZ | 当 CX/ECX/RCX 为零时跳转                  |               | CX = 0<br>ECX = 0<br>RCX = 0 |
| JB / JNAE / JC       | 当低于/当不大于或等于/当进位时跳转        | 无符号        | CF = 1                       |
| JNB / JAE / JNC      | 当不低于/当大于或等于/当没有进位时跳转    | 无符号        | CF = 0                       |
| JBE / JNA            | 当低于或等于/当不大于时跳转               | 无符号        | CF = 1 或 ZF = 1             |
| JA / JNBE            | 当高于/当不小于或等于时跳转               | 无符号        | CF = 0 且 ZF = 0             |
| JL / JNGE            | 当小于/当不大于或等于时跳转               | 有符号        | SF ≠ OF                      |
| JGE / JNL            | 当大于或等于/当不小于时跳转               | 有符号        | SF = OF                      |
| JLE / JNG            | 当小于或等于/当不大于时跳转               | 有符号        | ZF = 1 或 SF ≠ OF            |
| JG / JNLE            | 当大于/当不小于或等于时跳转               | 有符号        | ZF = 0 且 SF = OF            |



## R8 - R15

这 8 个寄存器是 x86-64 架构新增的寄存器，主要用于作为通用寄存器使用。

- **易失性寄存器**：在函数调用期间可能被编译器重写，如 `rax`, `rcx`, `rdx`, `r8`-`r11`。
- **非易失性寄存器**：在函数调用期间必须由函数调用者保存和恢复，如 `rbx`, `rbp`, `rsi`, `rdi`, `r12`-`r15`。



## 浮点寄存器

x64 处理器还提供了几组浮点寄存器：

- 八个 80 位 x87 寄存器。
- 八个 64 位 MMX 寄存器。（这些寄存器与 x87 寄存器重叠。）
- 原来的八个 128 位 SSE 寄存器增加到了十六个。



## 其他

![image-20240801143340414](./images/x64%20Assembly.assets/image-20240801143340414.png)



# 段

## .data

`.DATA` 声明静态数据区。

数据类型修饰原语：

- `DB`: Byte		        1 Bytes
- `DW`: Word      	        2 Bytes
- `DD`: Double Word	4 Bytes
- `DQ`: Quad Word	   8 Bytes



# 调用约定

与 x86 不同的是，C/C++ 编译器在 x64 上仅支持一种调用约定。该调用约定利用了 x64 上可用的大量寄存器：

参数传递：

- **前四个**整型或指针**参数**通过 **rcx、rdx、r8 和 r9** 寄存器传递。
- **前四个**浮点**参数**通过前四个 SSE 寄存器 **xmm0 至 xmm3** 传递。
- （**五个参数后**）任何额外的参数都**通过栈传递**。
- 调用者在栈上预留空间来保存通过寄存器传递的参数。被调用函数可以使用这个空间将寄存器的内容溢出到栈上。



返回值传递：

- 整型或指针返回值通过 rax 寄存器返回，而浮点返回值通过 xmm0 返回。



C++ 的调用约定类似。隐式第一个参数（`this` 指针）通过寄存器传递。接下来的三个参数通过剩余的寄存器传递，其余参数则通过栈传递。



# 地址模式

在64位模式（也称为x64或AMD64）下，地址模式与传统的x86架构相比有了一些变化，这些变化旨在提高性能并支持更大的内存空间。

1. 64位寄存器的默认使用

- 在64位模式中，指令默认操作64位宽的寄存器。例如，使用`mov rax, [rbx]`指令时，它会自动从`rbx`开始的内存位置读取8字节（即64位）的数据，并将其加载到`rax`寄存器中。
- 这种默认行为简化了代码编写，同时也确保了对大内存的支持。



2. 立即数和常量地址的处理

- 对于需要立即数或常量地址的指令，64位模式引入了一种特殊的`mov`指令形式来处理64位立即数或地址。
- 然而，除了这种特殊形式的`mov`指令外，大多数其他指令仍然使用32位立即数或地址。这意味着，在多数情况下，立即数或地址仍然限制在32位范围内。



3. 新的RIP相对寻址模式

- x64架构引入了基于RIP（Instruction Pointer，指令指针）的相对寻址模式。这种寻址方式允许指令中的地址字段指定为相对于当前指令地址的一个偏移量。
- 当执行如`mov rax, [addr]`这样的指令时，实际上是从地址`addr + rip`处读取8字节的数据到`rax`寄存器中。这里，`rip`是指令执行时的当前指令指针值。
- RIP相对寻址特别适用于定位静态数据和函数地址，因为它可以减少代码大小并且有利于位置无关代码的生成。
