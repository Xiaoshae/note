# 正则表达式

正则表达式（Regular Expression）是一种用于定义文本模式（Pattern）的语言。它使用一套特定的语法，由普通字符（如 `a`, `b`, `c`）和具有特殊含义的元字符（Metacharacters，如 `*`, `+`, `\d`）组成，来精确描述一个或一类字符串的特征。

正则表达式的语法本身只负责匹配内容，而对匹配到的文本执行何种具体操作（如查找、替换、切割），以及操作的范围（如作用于单个文件还是整个目录）和方式（如全局查找 `g`、忽略大小写 `i`），均不属于正则表达式语法的范畴。这些“后续任务”是由宿主工具（如 `sed`、`grep` 或编程语言中的 `re` 库）来定义和执行的。

在正则表达式的语法中，捕获组（Capturing Groups，即 `()`）是专门为辅助“提取”和“替换”而设计的。它本身不执行操作，但它在模式中“标记”了感兴趣的子字符串，以便宿主工具在执行提取时能获取这些数据，或在执行替换时通过反向引用（Backreference，如 `\1`）来使用它们。



正则表达式（Regular Expression）并没有一个像 W3C 制定 HTML/CSS 那样的**单一、统一的官方国际标准**。

简单来说，正则表达式主要分为两大流派：

1. **POSIX (Portable Operating System Interface)**：一个比较早期的、偏向传统的“标准”。
2. **PCRE (Perl Compatible Regular Expressions)**：目前事实上的“主流标准”，功能更强大。



**POSIX 标准（传统标准）**

Unix 时代，`grep`, `sed`, `awk` 等工具需要一种模式匹配语言，于是正则表达式被引入了工程界。

为了规范 Unix 系统上的工具行为，IEEE 制定了 POSIX 标准。这个标准定义了两种正则表达式规范：

- **BRE (Basic Regular Expressions)**：基本正则表达式。
  - **特点**：非常基础。像 `( )`（分组）和 `{ }`（量词）这样的元字符必须**转义**后才具有特殊含义，例如 `\(` 和 `\)`。
  - **使用者**：老牌的 `grep`（不带参数时）和 `sed`（不带参数时）。
- **ERE (Extended Regular Expressions)**：扩展正则表达式。
  - **特点**：比 BRE 更现代化一点。`( )` 和 `{ }` 等字符**不需要**转义，直接使用。
  - **使用者**：`egrep`（或 `grep -E`）和 `awk`。



**PCRE 标准（当今的主流）**

到了 90 年代，Perl 语言横空出世。Perl 的开发者 Larry Wall 极大地扩展了正则表达式的功能，使其变得异常强大和便捷。

这套正则表达式的语法和功能集被称为 **PCRE (Perl Compatible Regular Expressions)**，即“Perl 兼容正则表达式”。

因为 PCRE 非常强大好用，引入了大量 POSIX 所没有的强大功能，它迅速被其他语言和工具模仿和采用，逐渐成为了**事实上的主流标准**。

虽然大家都在向 PCRE 靠拢，但每种语言或工具的实现细节（称为 Regex "Flavor"，风味）都可能存在**微小的差异**。例如，JavaScript 曾经不支持后行断言（现在支持了），或者某些工具对 Unicode 的支持程度不同。



## 元字符

元字符（Metacharacters）是在正则表达式中具有特殊意义的字符。

它们用于指定模式匹配的规则，而不是直接匹配文本中的某个字符。

| 元字符 | 描述                                                         |
| ------ | ------------------------------------------------------------ |
| `.`    | 匹配除换行符以外的任意单个字符。                             |
| `^`    | 匹配字符串的开始位置。如果在多行模式下，还可以匹配每一行的开始位置。 |
| `$`    | 匹配字符串的结束位置。同样地，在多行模式下，可以匹配每一行的结束位置。 |
| `*`    | 匹配前面的子表达式零次或多次。                               |
| `+`    | 匹配前面的子表达式一次或多次。                               |
| `?`    | 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符         |
| `{}`   | 指定前面的子表达式的最小和最大重复次数，例如 `{2,4}` 表示匹配前面的子表达式至少两次，最多四次。 |
| `[]`   | 定义一个字符集，匹配括号内的任一字符。                       |
| `()`   | 定义一个子表达式或组，用于分组或捕获匹配的部分。             |
| `\`    | 转义符，用于取消下一个字符的特殊意义，或者用于表示某些特殊序列（如 `\d` 匹配任何数字，`\w` 匹配任何单词字符）。 |
| `|`    | 表示选择，用于指定多个可选项中的一个。                       |



## 字符类

一个字符类定义一组字符，其中的任一字符均可出现在输入字符串中以便成功匹配。



### 正字符组：[ ]

正字符组指定一个字符列表，其中的任何一个字符可出现在输入字符串中以便进行匹配。

此字符列表可以单独指定和/或作为范围指定。



#### 字符列表

用于指定各个字符列表的语法如下所示：

```
[character_group]
```

其中，character_group 是单个字符的列表，这些字符可出现在输入字符串中以便成功匹配。 

character_group 可以包含一个或多个文本字符、转义字符或字符类的任意组合。

示例：

```
[123789ABCXYZ]
```

![image-20241027140341626](./images/re%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.assets/image-20241027140341626.png)



#### 字符范围

用于指定字符范围的语法如下：

```
[firstCharacter-lastCharacter]
```

其中，*firstCharacter* 是范围的开始字符，*lastCharacter* 是范围的结束字符。 

字符范围是通过以下方式定义的一系列连续字符：

-  字符范围是通过以下方式定义的一系列连续字符：指定系列中的**第一个字符**，**连字符 (-)**，然后指定系列中的**最后一个字符**。

- 如果两个字符具有相邻的 Unicode 码位，则这两个字符是连续的。
-  firstCharacter 必须是码位较低的字符。
-  lastCharacter 必须是码位较高的字符。



> **注意**：如果连字符 `-` 出现在字符组的最开始或最末尾的位置，则它会被视为一个普通的字符，而不是范围分隔符，或者使用反斜杠 `\` 对其进行转义。
>
> - `[a-z-]` 匹配任何小写字母或连字符。
> - `[-a-z]` 同样匹配任何小写字母或连字符。
> - `[a\-z]` 在这里，连字符被转义，因此也匹配任何小写字母或连字符。



示例：

```
[0-9A-Z]
```

![image-20241026164806379](./images/re%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.assets/image-20241026164806379.png)



### 负字符组：[^]

负字符组指定一个字符列表，这些字符不得出现在输入字符串中以便进行匹配。 

此字符列表可以单独指定和/或作为范围指定。



#### 字符列表

用于指定各个字符列表的语法如下所示：

```
[^character_group]
```

*character_group* 是单个字符的列表，这些字符不可出现在输入字符串中以便成功匹配。

示例：

```
[^123ABCDEFGHJ]
```

![image-20241026165047422](./images/re%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.assets/image-20241026165047422.png)



#### 字符范围

用于指定字符范围的语法如下：

```
[^firstCharacter-lastCharacter]
```

其中，firstCharacter 是范围的开始字符，lastCharacter 是范围的结束字符。 

示例：

```
[^a-z0-5]
```

![image-20241026165140487](./images/re%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.assets/image-20241026165140487.png)



### 字符类列表

| 字符类 | 描述                               | 模式   | 匹配                                                 |
| ------ | ---------------------------------- | ------ | ---------------------------------------------------- |
| `\w`   | 与任何**单词字符**匹配。           | `\w`   | `"ID A1.3"` 中的 `"I"`、`"D"`、`"A"`、`"1"` 和 `"3"` |
| `\W`   | 与任何**非单词字符**匹配。         | `\W`   | `"ID A1.3"` 中的 `" "` 和 `"."`                      |
| `\s`   | 与任何**空白**匹配。               | `\w\s` | `"ID A1.3"` 中的 `"D "`                              |
| `\S`   | 与任何**非空白字符**匹配。         | `\s\S` | `"a b_c"` 中的 `"a"`、`"b"`、`"_"`、`"c"`            |
| `\d`   | 与任何**十进制**数字匹配。         | `\d`   | `"4 = IV"` 中的 `"4"`                                |
| `\D`   | 与任何**不是十进制数**的字符匹配。 | `\D`   | `"4 = IV"` 中的 `" "`、`"="`、`" "`、`"I"` 和 `"V"`  |

**单词字符 (\w)**：匹配任何**字母、数字或下划线**。

**空白字符 (\s)**：匹配任何**空白字符，包括空格、制表符（Tab）、换行符等**。

**十进制数字 (\d)**：匹配任何**0-9之间的数字**。



### 非打印字符

| 字符 | 描述                                                         |
| :--- | :----------------------------------------------------------- |
| \cx  | 匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。 |
| \f   | 匹配一个换页符。等价于 \x0c 和 \cL。                         |
| \n   | 匹配一个换行符。等价于 \x0a 和 \cJ。                         |
| \r   | 匹配一个回车符。等价于 \x0d 和 \cM。                         |



## 数量词

| 贪婪限定符      | 惰性限定符       | 描述             |
| :-------------- | :--------------- | :--------------- |
| `*`             | `*?`             | 匹配零次或多次。 |
| `+`             | `+?`             | 匹配一次或多次。 |
| `?`             | `??`             | 匹配零次或一次。 |
| `{` n `}`       | `{` n `}?`       | 恰好匹配 n 次。  |
| `{` n `,}`      | `{` n `,}?`      | 至少匹配 n 次。  |
| `{` n `,` m `}` | `{` n `,` m `}?` | 匹配 n 到 m 次。 |

数量 `n` 和 `m` 是整数常量。 

通常，限定符是贪婪的， 它们使正则表达式引擎匹配尽可能多的特定模式实例。 

向限定符追加 `?` 字符可使它成为惰性的， 它会使正则表达式引擎匹配尽可能少的实例。



## 定位点

| 定位点 | 说明                                                         |
| :----- | :----------------------------------------------------------- |
| `^`    | 默认情况下，匹配必须出现在字符串的开头；在多行模式中，必须出现在该行的开头。 |
| `$`    | 默认情况下，匹配必须出现在字符串的末尾，或在字符串末尾的 `\n` 之前；在多行模式中，必须出现在该行的末尾，或在该行末尾的 `\n` 之前。 |
| `\A`   | 匹配必须仅出现在字符串的开头位置（无多行支持）。             |
| `\Z`   | 匹配必须出现在字符串的末尾，或出现在字符串末尾的 `\n` 之前。 |
| `\z`   | 匹配必须仅出现在字符串的末尾。                               |
| `\G`   | 匹配必须从上一个匹配结束的位置开始；如果以前没有匹配项，则从开始进行匹配的字符串中的位置开始。 |
| `\b`   | 匹配必须出现在字边界。                                       |
| `\B`   | 匹配不得出现在字边界上。                                     |

`\b` 定位符指定匹配必须出现单词字符（ `\w` 语言元素）和非单词字符（ `\W` 语言元素）之间的边界上。

单词字符包括字母数字字符和下划线；

非单词字符包括不为字母数字字符或下划线的任何字符。



> 注意：\A \Z \z \G 在 C# 中被支持，在其他语言未测试。



## 匹配组



### 匹配的子表达式

以下分组构造捕获匹配的子表达式：

```
( subexpression )
```

此处，子表达式是任何有效的正则表达式模式。 

使用括号的捕获按正则表达式中左括号的顺序，从 1 开始，从左到右自动编号。 

命名的捕获组总是在非命名捕获组之后最后排序。 

编号为零的捕获是与整个**正则表达式模式匹配的文本**（将所有捕获的文本拼接）。





通过使用正则表达式中的反向引用构造。 使用语法 `\数字`在同一正则表达式中引用匹配的子表达式，其中 `数字` 是捕获的表达式的初始数字。

例如，如果你想匹配两个相同的单词，可以使用以下正则表达式：

```
\b(\w+)\b\s+\1\b
```

- `\b` 是单词边界。
- `(\w+)` 是第一个捕获组，匹配一个或多个单词字符。
- `\s+` 匹配一个或多个空白字符。
- `\1` 是对第一个捕获组的反向引用，确保第二个单词与第一个单词相同。





### 命名匹配的子表达式

以下分组构造捕获匹配的子表达式，并允许你按名称或编号访问它：

名称是有效的组名称，而子表达式是任何有效的正则表达式模式。 名称 不得包含任何标点符号字符，并且不能以数字开头。

```
(?<name>subexpression)
```

或：

```
(?'name'subexpression)
```





命名反向引用使用 `\k<name>` 的语法，在同一正则表达式中引用匹配的子表达式，其中 `name` 是捕获组的名称。命名捕获组使用 `(?<name>...)` 的语法定义。这使得代码更具可读性。

**示例 ：匹配两个相同的单词（使用命名捕获组）**

```
\b(?<word>\w+)\b\s+\k<word>\b
```

- `\b` 是单词边界。
- `(?<word>\w+)` 是一个命名捕获组，名称为 `word`，匹配一个或多个单词字符。
- `\s+` 匹配一个或多个空白字符。
- `\k<word>` 是对名为 `word` 的捕获组的反向引用，确保第二个单词与第一个单词相同。



### 非捕获组

以下分组构造不会捕获与子表达式匹配的子字符串：

```
(?:subexpression)
```

当一个限定符应用到一个组，但组捕获的子字符串并非所需时，通常会使用非捕获组构造。

> 注意：如果正则表达式包含嵌套的分组构造，则外部非捕获组构造不适用于内部嵌套组构造。



正则表达式 `(?:\b(?:\w+)\W*)+\.` 匹配由句号终止的语句。

因为正则表达式重点介绍句子，而不是个别单词，所以分组构造以独占方式用作限定符。

| 模式                | 描述                                                         |
| :------------------ | :----------------------------------------------------------- |
| `\b`                | 在单词边界处开始匹配。                                       |
| `(?:\w+)`           | 匹配一个或多个单词字符。 不将匹配的文本分配给捕获的组。      |
| `\W*`               | 匹配零个或多个非单词字符。                                   |
| `(?:\b(?:\w+)\W*)+` | 一次或多次匹配跟在零个或多个非单词字符后面以单词边界开头的一个或多个单词字符的模式。 不将匹配的文本分配给捕获的组。 |
| `\.`                | 匹配句点。                                                   |



### 组选项

以下分组构造应用或禁用子表达式中指定的选项：

```
(?imnsx-imnsx: subexpression )
```

例如， `(?i-s:)` 将打开不区分大小写并禁用单行模式。 



 正则表达式选项：

暂略



示例中的正则表达式 `\b(?i:d\w+)\s` 使用分组构造中的内联选项，以启用不区分大小写的匹配和在识别所有以字母“d”开头的单词时忽略模式空白。

| 模式        | 描述                                                      |
| :---------- | :-------------------------------------------------------- |
| `\b`        | 在单词边界处开始匹配。                                    |
| `(?i:d\w+)` | 使用不区分大小写的匹配，匹配后跟一个或多个单词字符的“d”。 |
| `\s`        | 与空白字符匹配。                                          |

![image-20241027112431335](./images/re%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.assets/image-20241027112431335.png)



### 零宽度正预测先行断言

零宽度正预测先行断言的语法是：

```
(?= subexpression )
```

零宽度正预测先行断言（Positive Lookahead Assertion）是一种正则表达式中的高级特性，用于在不消耗字符的情况下进行条件匹配。

若要成功匹配，则输入字符串必须匹配子表达式中的正则表达式模式，但不会将匹配的字符包含在最终的匹配结果中。



**工作原理**

1. **条件检查**：`(?= subexpression )` 会检查当前位置之后的字符串是否匹配 `subexpression`。
2. **不消耗字符**：即使 `subexpression` 匹配成功，也不会消耗任何字符，即不会影响后续的匹配过程。
3. **不包含在结果中**：匹配成功的 `subexpression` 不会被包含在最终的匹配结果中。



示例 : 匹配输入字符串中谓词“is”前的单词

```
\b\w+(?=\sis\b)
```

 ![image-20241027113857744](./images/re%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.assets/image-20241027113857744.png)



### 零宽度负预测先行断言

零宽度负预测先行断言的语法是：

```
(?! subexpression )
```

若要成功匹配，则输入字符串**不得匹配**子表达式中的正则表达式模式，尽管匹配的子字符串未包含在匹配结果中。

零宽度负预测先行断言通常用在正则表达式的开头或结尾。 正则表达式的开头可以定义当其定义了要被匹配的相似但更常规的模式时，不应被匹配的特定模式。 



匹配未以“un”开头的单词

```
\b(?!un)\w+\b
```

| 模式     | 描述                                                      |
| :------- | :-------------------------------------------------------- |
| `\b`     | 在单词边界处开始匹配。                                    |
| `(?!un)` | 确定接下来的两个的字符是否为“un”。 如果没有，则可能匹配。 |
| `\w+`    | 匹配一个或多个单词字符。                                  |
| `\b`     | 在单词边界处结束匹配。                                    |

![image-20241027130801493](./images/re%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.assets/image-20241027130801493.png)



### 零宽度正回顾后发断言

零宽度正回顾后发断言的语法是：

```
(?<= subexpression )
```

若要成功匹配，则 子表达式 **必须在**输入字符串当前位置左侧出现，尽管 subexpression 未包含在匹配结果中。

零宽度正预测后发断言通常在正则表达式的开头使用。 它们定义的模式是一个匹配的前提条件，但它不是匹配结果的一部分。

示例 : 匹配二十一世纪年份的最后两个数字

```
(?<=\b20)\d{2}\b
```

| 模式        | 描述                                                       |
| :---------- | :--------------------------------------------------------- |
| `\d{2}`     | 匹配两个十进制数字。                                       |
| `(?<=\b20)` | 如果两个十进制数字的字边界以小数位数“20”开头，则继续匹配。 |
| `\b`        | 在单词边界处结束匹配。                                     |

![image-20241027131117133](./images/re%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.assets/image-20241027131117133.png)



### 零宽度负回顾后发断言

零宽度负回顾后发断言的语法是：

```
(?<! subexpression )
```

若要成功匹配，则 子表达式 **不得在**输入字符串当前位置的左侧出现，尽管 subexpression 未包含在匹配结果中。

零宽度负回顾后发断言通常在正则表达式的开头使用。 它们定义的模式预先排除在后面的字符串中的匹配项。 

示例 : 匹配除周末之外的一周的任何一天（也就是星期六和星期日都没有）。

```
(?<!(Saturday|Sunday) )\b\w+ \d{1,2}, \d{4}\b
```

| 模式                      | 描述                                                         |
| :------------------------ | :----------------------------------------------------------- |
| `\b`                      | 在单词边界处开始匹配。                                       |
| `\w+`                     | 匹配一个或多个后跟空白字符的单词字符。                       |
| `\d{1,2},`                | 匹配空白字符和逗号后面的一个或两个十进制数字。               |
| `\d{4}\b`                 | 匹配四个十进制数字并在单词边界处结束匹配。                   |
| `(?<!(Saturday|Sunday) )` | 如果匹配以字符串“星期六”或者“星期日”开头，后跟一个空格，则匹配成功。 |

![image-20241027131703258](./images/re%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.assets/image-20241027131703258.png)



### 原子组

> 注意：此格式在 C# 中可以正常使用，其他地方未测试。

原子组（在其他一些正则表达式引擎中称为非回溯子表达式、原子子表达式或一次性子表达式）的语法是：

```
(?> subexpression )
```

通常，如果正则表达式包含一个可选或可替代匹配模式并且备选不成功的话，正则表达式引擎可以在多个方向上分支以将输入的字符串与某种模式进行匹配。 

如果未找到使用第一个分支的匹配项，则正则表达式引擎可以备份或回溯到使用第一个匹配项的点并尝试使用第二个分支的匹配项。 此过程可继续进行，直到尝试所有分支。



原子组中，正则表达式引擎将在输入字符串中匹配尽可能多的字符。 在没有任何进一步匹配可用时，它将不回溯以尝试备用模式匹配。

如果你知道回溯不会成功，则建议使用此选项。 防止正则表达式引擎执行不需要的搜索可以提高性能。 



回溯正则表达式成功匹配一系列重复字符，在字边界上其后为相同字符，但非回溯正则表达式不会匹配。

```C#
string[] inputs = { "cccd.", "aaad", "aaaa" };
string back = @"(\w)\1+.\b";
string noback = @"(?>(\w)\1+).\b";

// The example displays the following output:
//    cccd.:
//       Backtracking : cccd
//       Nonbacktracking: cccd
//    aaad:
//       Backtracking : aaad
//       Nonbacktracking: aaad
//    aaaa:
//       Backtracking : aaaa
//       Nonbacktracking: No match
```

非回溯正则表达式 `(?>(\w)\1+).\b` 的定义如下表所示。

| 模式          | 描述                                                         |
| :------------ | :----------------------------------------------------------- |
| `(\w)`        | 匹配单个单词字符，并将其分配给第一捕获组。                   |
| `\1+`         | 一次或多次匹配的第一个捕获子字符串的值。                     |
| `.`           | 匹配任意字符。                                               |
| `\b`          | 在单词边界处结束匹配。                                       |
| `(?>(\w)\1+)` | 匹配一个重复的字字符的一个或多个匹配项，但不执行回溯以匹配在字边界上的最后一个字符。 |