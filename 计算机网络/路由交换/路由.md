

# 静态路由

```
ip route-static [目标网络号] [目标子网掩码] [下一跳IP]
```

```
ip route-static 192.168.20.0 255.255.255.0 192.168.10.254
```

如果你想要配置的是一条直连网络的静态路由（通常不需要下一跳地址）命令如下：

```
ip route-static 192.168.0.0 255.255.255.0 GigabitEthernet 0/0/0 
```



# 默认路由

默认路由，也称为缺省路由。默认路由通常以`0.0.0.0/0`的形式出现，意味着“任何目的地”。可以匹配任何IP地址。

在配置默认路由时，网络管理员需要指定一个下一跳地址，这将是默认路由的出口。

```
ip route-static 0.0.0.0 0.0.0.0 192.168.1.254
```





# 浮动路由

浮动路由，也称为浮动静态路由或备份路由，是为了解决主路由失败时的冗余问题。

通常会有多条路径到达同一目的地，配置两个或更多的静态路由到同一目的地，但具有不同的优先级。

优先级数值越小，表示该路由的优先级越高。



例如：前往目的地D网段。可以通过B接口或者C接口出去，首先添加一条D网段通过B接口出去（高优先级），在添加一条D网段通过C接口出去（低优先级）。

默认情况下，会从B接口出去，如果B接口故障，则会从C接口出去。

```
ip route-static 192.168.100.0 255.255.255.0 172.16.1.254 preference 50
ip route-static 192.168.100.0 255.255.255.0 172.16.2.254 preference 60
```



# 路由策略（过滤）

路由策略是指在网络设备上应用的一组规则，用来决定如何处理路由信息。它影响的是路由表中的条目，即路由信息本身，而不是直接决定单个数据包的转发路径。

路由策略主要作用于路由协议（如OSPF, BGP等）所学习或发布的路由信息。它可以过滤、修改或重分发这些路由信息。

## 基于 ACL 的路由过滤

对于命名型ACL，使用**rule**命令配置过滤规则时，只有**source**参数指定的源地址范围和**time-range**参数指定的时间段对配置规则有效。

使用ACL进行过滤时，可以采用的策略如下表所示：

| 情况                                                         | 过滤结果                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| ACL规则的动作是**permit**。                                  | 该路由正常发布。                                             |
| ACL规则的动作是**deny**。                                    | 该路由不会发布。                                             |
| 路由的网段不在ACL规则指定的范围内。                          | 该路由默认不发布。                                           |
| ACL中不存在规则                                              | 引用该ACL的路由策略中涉及的所有路由不发布。                  |
| 当ACL规则的匹配顺序为配置方式时，系统根据规则编号从小到大的顺序进行匹配。 | 此时有两种过滤方式：黑名单方式：可以在同一个ACL中先配置动作是**deny**的编号较小的规则，用于过滤掉不希望发布的路由，然后再配置动作是**permit**的编号较大的规则，用于发布其他路由。白名单方式：可以在同一个ACL中先配置动作是**permit**的编号较小的规则，用于允许希望发布的路由，然后再配置动作是**deny**的编号较大的规则，用于过滤掉其他不希望发布的路由。 |



1. 创建并进入ACL视图。

    ```
    acl { name basic-acl-name [ basic ] | [ number ] basic-acl-number }
    ```

2. 配置ACL规则。

    ```
    rule [ rule-id ] [ name rule-name ] { deny | permit } [ fragment-type { fragment } | source { source-ip-address { source-wildcard | 0 | src-netmask } | any } | time-range time-name | vpn-instance vpn-instance-name ] *
    ```





## 基于 IP前缀列表 的路由过滤

**了解IPv4地址前缀列表**

地址前缀列表是一种包含一组路由信息过滤规则的过滤器，用户可以在规则中定义前缀和掩码长度范围，用于匹配路由信息的目的网段地址或下一跳地址。地址前缀列表进行匹配的依据有两个：

- 掩码长度：地址前缀列表匹配的对象是IP地址前缀，前缀由IP地址和掩码长度共同定义。例如，10.1.1.1/16这条路由，掩码长度是16，这个地址的有效前缀为16位，即10.1.0.0。
- 掩码长度范围：对于前缀相同，掩码不同的路由，可以指定待匹配的前缀掩码长度范围来实现精确匹配或者在一定掩码长度范围内匹配。



**地址前缀匹配规则**

一个地址前缀列表中可以创建多个索引项，每个索引对应一条过滤规则。待过滤路由按照索引号从小到大的顺序进行匹配：

- 当匹配上某一索引项时，如果该索引项是Permit，则这条路由被允许通过；如果该索引项是Deny，则这条路由被拒绝通过。
- 当遍历了地址前缀列表中的所有索引项，都没有匹配上，那么这条路由就被拒绝通过。

![img](./images/%E8%B7%AF%E7%94%B1.assets/ip-prefix.png)

地址前缀列表过滤路由的原则可以总结为：顺序匹配、唯一匹配、默认拒绝。

- 顺序匹配：按索引号从小到大顺序进行匹配。同一个地址前缀列表中的多条表项设置不同的索引号，可能会有不同的过滤结果，实际配置时需要注意。
- 唯一匹配：待过滤路由只要与一个表项匹配，就不会再去尝试匹配其他表项。
- 默认拒绝：默认所有未与任何一个表项匹配的路由都视为未通过地址前缀列表的过滤。因此在一个地址前缀列表中创建了一个或多个deny模式的表项后，需要创建一个表项来允许所有其他路由通过。



### 地址前缀中的掩码匹配规则

地址前缀列表和ACL相比，配置简单，应用灵活，可以对路由的掩码进行匹配。

地址前缀列表可以通过**ip ip-prefix**命令进行配置，常用格式如下：

**ip ip-prefix** *ip-prefix-name* [ **index** *index-number* ] { **permit** | **deny** } *ipv4-address* *mask-length* [ **greater-equal** *greater-equal-value* ] [ **less-equal** *less-equal-value* ]

其中*ipv4-address* *mask-length* [ **greater-equal** *greater-equal-value* ] [ **less-equal** *less-equal-value* ]用于限定过滤路由的网络号及掩码范围。

**表13-5** 地址前缀列表中地址范围的表示

| 参数                                    | 含义                                    |
| --------------------------------------- | --------------------------------------- |
| *ipv4-address*                          | 用于指定网络号。                        |
| *mask-length*                           | 用于限定网络号的前多少位需严格匹配。    |
| **greater-equal** *greater-equal-value* | 表示掩码大于等于*greater-equal-value*。 |
| **less-equal** *less-equal-value*       | 表示掩码小于等于*less-equal-value*。    |

当待过滤的路由已匹配当前表项的网络号时，掩码长度可以进行精确匹配或者在一定掩码长度范围内匹配。

- 如果不配置**greater-equal** 和**less-equal**，则进行精确匹配，即只匹配掩码长度为*mask-length*的路由。
- 如果只配置**greater-equal**，则匹配的掩码长度范围为[*greater-equal-value*，32]，*greater-equal-value*取值要大于等于*mask-length*的取值。
- 如果只配置**less-equal**，则匹配的掩码长度范围为[*mask-length*，*less-equal-value*]。
- 如果同时配置**greater-equal** 和**less-equal**，则匹配的掩码长度范围为[*greater-equal-value*，*less-equal-value*]。



全0为通配地址。当前缀为全0时，可以在其后指定掩码长度以及掩码长度范围：

- 若指定掩码长度，则表示具有该掩码长度的所有路由都被允许通过（Permit）或拒绝通过（Deny）。
- 若指定掩码长度范围，则表示掩码长度范围内的所有路由都被允许通过或拒绝通过。



***masklen* <= *greater-equal-value* <= *less-equal-value* <= 32**

1. 匹配缺省路由

    ```
    ip ip-prefix aa index 10 permit 0.0.0.0 0
    ```

    注意：只有缺省路由被permit

2. 匹配某个网段的路由

    ```
    ip ip-prefix aa index 10 permit 172.16.0.0 16
    ```

    注意：允许所有属于`172.16.0.0/16`网络段的路由通过（ **不包括172.16.0.0/16 划分的子网**）

3. 匹配某个网段的路由（包含子网）

    ```
    ip ip-prefix aa index 10 permit 172.16.0.0 16 greater-equal 16
    ```

    ```
    ip ip-prefix aa index 10 permit 172.16.0.0 16 less-equal 32
    ```

4. 允许部分子网通过

    ```
    ip ip-prefix aa index 10 permit 172.16.0.0 16 greater-equal 16 less-equal 24
    ```

    ```
    ip ip-prefix aa index 10 permit 172.16.0.0 16 less-equal 24
    ```

    ```
    ip ip-prefix aa index 10 permit 172.16.0.0 greater-equal 16 less-equal 24
    ```



### 应用 ACL 和 IP前缀列表的匹配规则

1. 进入RIP进程视图。

    ```
    rip [ process-id ]
    ```

2. **RIP对路由进行过滤**，可以采用的策略如下所示：

| 操作                                                         | 命令                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 配置基于ACL过滤学到的路由信息                                | **filter-policy** *acl-number* **import** [ *interface-type* *interface-number* ] |
| 配置基于目的地址前缀过滤邻居发布的路由信息                   | **filter-policy gateway** *ip-prefix-name* **import**        |
| 配置基于ACL-name过滤学到的路由信息                           | **filter-policy** **acl-name** *acl-name* **import** [ *interface-type* *interface-number* ] |
| 配置对指定接口学到的路由进行基于目的地址前缀的过滤和基于邻居过滤学到的路由信息 | **filter-policy ip-prefix** *ip-prefix-name* [ **gateway** *ip-prefix-name* ] **import** [ *interface-type* *interface-number* ] |

**注意：import 对接受的路由进行过滤，export 对发布的路由进行过滤。**



### RIP 配置示例

在 R1 上有基于 ACL 和 IP前缀两种配置，在 R2 和 R3 上 两种规则的配置是一样的。

R1

```
#
interface GigabitEthernet0/0/0
 ip address 192.168.10.1 255.255.255.0
#

#
interface LoopBack0
 ip address 172.16.0.1 255.255.255.0
#
interface LoopBack1
 ip address 172.16.10.1 255.255.255.0
#
interface LoopBack2
 ip address 172.16.20.1 255.255.255.0
#
interface LoopBack3
 ip address 172.16.30.1 255.255.255.0
#
interface LoopBack4
 ip address 172.17.100.1 255.255.255.0
#
interface LoopBack5
 ip address 172.16.10.129 255.255.255.128
#

# 基于 ACL
#
acl number 2000
 rule 5 permit source 172.16.0.0 0.0.255.128
#

#
rip 1
 version 2
 network 172.16.0.0
 network 172.17.0.0
 network 192.168.10.0
 filter-policy 2000 export GigabitEthernet0/0/0
 import-route direct
#

# 基于 IP 前缀
#
ip ip-prefix route index 10 permit 172.16.0.0 16 greater-equal 16 less-equal 25
#

#
rip 1
 version 2
 network 172.16.0.0
 network 172.17.0.0
 network 192.168.10.0
 filter-policy ip-prefix route export GigabitEthernet0/0/0
 import-route direct
#
```



r2

```
#
interface GigabitEthernet0/0/0
 ip address 192.168.10.254 255.255.255.0
#
interface GigabitEthernet0/0/1
 ip address 192.168.20.1 255.255.255.0
#

#
rip 1
 version 2
 network 192.168.10.0
 network 192.168.20.0
#
```



r3

```
#
interface GigabitEthernet0/0/1
 ip address 192.168.20.254 255.255.255.0
#

#
rip 1
 version 2
 network 192.168.20.0
#
```



## Filter-Policy

filter-policy也是一个很常用的路由信息过滤工具。

由于距离矢量路由协议（例如RIP）和链路状态路由协议（例如OSPF）原理上的差异，filter-policy应用在这两种路由协议的时候过滤规则也有所不同。

距离矢量路由协议和链路状态路由协议原理对比：

| 路由类型         | 路由传递原理                                                 |
| ---------------- | ------------------------------------------------------------ |
| 距离矢量路由协议 | 各路由设备之间传递的是路由信息。这种路由信息对于报文来说相当于“路标”，设备依靠“路标”来指导报文转发，路标指向哪里报文就转发到哪里。 |
| 链路状态路由协议 | 各路由设备之间传递的是LSA信息。LSA信息的集合（LSDB）形成整个网络的拓扑结构，相当于一张地图，设备依靠“地图+最短路径算法”为报文找到最佳的转发路径。 |



**filter-policy在距离矢量路由协议中的应用**

![img](./images/%E8%B7%AF%E7%94%B1.assets/download.png)

在距离矢量路由协议中，设备之间传递的是路由信息，如果需要对这种路由信息进行某种过滤，可以使用filter-policy实现，出方向和入方向的生效位置。

如果要过滤掉上游设备到下游设备的路由，只需要在上游设备配置filter-policy export或者在下游设备上配置filter-policy import。



**filter-policy在链路状态路由协议中的应用**

![img](./images/%E8%B7%AF%E7%94%B1.assets/download-1733362777738-19.png)

在链路状态路由协议中，各路由设备之间传递的是LSA信息，然后设备根据LSA汇总成的LSDB信息计算出路由表。以OSPF为例，filter-policy生效规则如下：

- **filter-policy import** 命令实际上是对**OSPF计算出来的路由进行过滤（不添加到路由表中）**，**不是对发布和接收的LSA进行过滤**。
- **filter-policy export** 命令用来对**引入的路由在发布时进行过滤**，只将满足条件的外部路由转换为Type5 LSA（AS-external-LSA）并发布出去。这样可以在引入外部路由时进行特定的过滤，防止形成路由环路。



### RIP接收的路由做过滤示例

三台交换机通过RIP交互路由，在SwitchA的RIP进程中引入了三条静态路由（作为测试路由），用户要求在SwitchB上部署filter-policy import，把192.168.3.0/24这条路由拒绝，其他路由放行。

![img](./images/%E8%B7%AF%E7%94%B1.assets/download-1733363010135-22.png)

1. 在SwitchB上定义一个地址前缀列表，“抓取”符合条件的路由。

    ```
    [SwitchB] ip ip-prefix huawei index 10 deny 192.168.3.0 24      //拒绝这条
    [SwitchB] ip ip-prefix huawei index 20 permit 0.0.0.0 0 less-equal 32   //允许所有
    ```

2. 在SwitchB的RIP视图中，部署filter-policy import。

    ```
    [SwitchB] rip
    [SwitchB-rip-1] filter-policy ip-prefix huawei import Vlanif10
    ```

从上面的实验结果来看，在SwitchB上部署filter-policy import以后，SwitchB和SwitchC的路由表中都不存在192.168.3.0/24这条路由了。

由于RIP是距离矢量路由协议，它是将自己的路由表通告给它的邻居交换机，当SwitchB的路由表中192.168.3.0/24这条路由被过滤以后，SwitchC也就无法再通过RIP学习到这条路由。也就是说，对于距离矢量路由协议，如果一台设备的路由表被进行了过滤，那么它会继续影响它下游的设备的路由表。

> **filter-policy export**和**filter-policy import**命令在RIP进程下配置，如果基于接口或者协议对路由进行过滤，则一个接口或协议只能配置一个策略；在没有指定接口和协议的情况下，就认为是配置全局过滤策略，同样只能配置一个策略，如果重复配置，新的策略将覆盖之前的策略。



### filter-policy对OSPF接收的路由过滤（区域内）示例

三台交换机同属于OSPF Area 0区域，SwitchA发布测试网段10.1.1.0/24，要求在SwitchB上部署**filter-policy import**，使得SwitchB的路由表中不允许出现10.1.1.0/24这条路由。

![img](./images/%E8%B7%AF%E7%94%B1.assets/download-1733363073603-25.png)

1. 在SwitchB上定义一个地址前缀列表，“抓取”符合条件的路由。

    ```
    [SwitchB] ip ip-prefix huawei index 10 deny 10.1.1.0 24           //拒绝这条
    [SwitchB] ip ip-prefix huawei index 20 permit 0.0.0.0 0 less-equal 32     //允许所有
    ```

2. 在SwitchB的OSPF视图中，部署filter-policy import。

    ```
    [SwitchB] ospf
    [SwitchB-ospf-1] filter-policy ip-prefix huawei import
    ```

通过SwitchB和SwitchC的路由表可以看到，虽然在SwitchB上10.1.1.0/24这条路由已经被过滤掉，但是LSA信息会继续传递给SwitchC，所以SwitchC的路由表中继续存在10.1.1.0/24这条路由。

这样的结果也验证了一开始在注意事项中给出的结论：在链路状态路由协议中，filter-policy只能过滤路由信息，不能过滤LSA信息。



### 通过filter-policy对OSPF接收的路由过滤（区域间）

相对于上一个场景，这个场景的区别之处是划分了两个不同的区域，SwitchB和SwitchC之间传递的是Type3 LSA，这个Type3 LSA是SwitchB上根据区域间路由生成的。配置方法跟上一个场景一样，此处不再赘述。

![img](./images/%E8%B7%AF%E7%94%B1.assets/download-1733363113862-28.png)

由于现在划分不同的区域，SwitchC上的10.1.1.0/24这条路由是由SwitchB根据自身学习的路由产生的Type3-LSA描述的，而SwitchB上的这条路由被过滤掉了，因此不能够再产生描述区域间路由的这个Type3-LSA，因此SwitchC上不会再学习到10.1.1.0/24这条路由。



## Route-Policy

Route-Policy是一种比较复杂的过滤器，它不仅可以匹配给定路由信息的某些属性，还可以在条件满足时改变路由信息的属性。

Route-Policy由节点号、匹配模式、if-match子句（条件语句）和apply子句（执行语句）这四个部分组成。

![img](./images/%E8%B7%AF%E7%94%B1.assets/download-1733362674199-8.png)

**节点号**

一个Route-Policy可以由多个节点（node）构成。路由匹配Route-Policy时遵循以下两个规则：

- 顺序匹配：在匹配过程中，系统按节点号从小到大的顺序依次检查各个表项，因此在指定节点号时，要注意符合期望的匹配顺序。
- 唯一匹配：Route-Policy各节点号之间是“或”的关系，只要通过一个节点的匹配，就认为通过该过滤器，不再进行其它节点的匹配。



**匹配模式**

节点的匹配模式有两种：permit和deny。

- permit指定节点的匹配模式为允许。当路由项**通过该节点的过滤后（命中 if-match）**，将执行该节点的apply子句，不进入下一个节点；如果路由项**没有通过该节点过滤（没命中 if-match）**，将进入下一个节点继续匹配。
- deny指定节点的匹配模式为拒绝。当路由项满足该节点的if-match子句时**（命中 if-match），将被拒绝通过该节点**，不进入下一个节点；如果路由项不满足该节点的if-match子句**（不命中 if-match），将进入下一个节点继续匹配**。**拒绝模式下 apply 子句（永远）不会被执行**。

> 通常在多个deny节点后设置一个不含if-match子句和apply子句的permit模式的Route-Policy，用于允许其它所有的路由通过。



**if-match子句（条件语句）**

if-match子句用来定义一些匹配条件。Route-Policy的每一个节点可以含有多个if-match子句，也可以不含if-match子句。如果某个permit节点没有配置任何if-match子句，则该节点匹配所有的路由。



**apply子句（执行语句）**

apply子句用来指定动作。路由通过Route-Policy过滤时，系统按照apply子句指定的动作对路由信息的一些属性进行设置。Route-Policy的每一个节点可以含有多个apply子句，也可以不含apply子句。如果只需要过滤路由，不需要设置路由的属性，则不使用apply子句。



**Route-Policy匹配规则**

Route-Policy每个node节点的过滤结果要综合以下两点：

- Route-Policy的**node节点的匹配模式**（**permit**或**deny**）。**简称为：Mode**
- Route-Policy的**node节点 if-match 子句**的匹配模式（**permit**或**deny**）。**简称为：Rule**

示例：

```
#
acl number 2001
 rule 5 deny source 172.16.16.0 0    // 拒绝 172.16.16.0。Rule 为 deny
#

#
route-policy RP permit node 10       // 在这个节点，172.16.16.0这条路由被拒绝，继续往下。 Mode 为 permit
 if-match acl 2001
#
```

对于每一个node节点，以上**两点（Mode 和 Rule）的排列组合会出现4种情况**。

| Rule       | Mode       | 匹配结果                                                     |
| ---------- | ---------- | ------------------------------------------------------------ |
| **permit** | **permit** | 匹配该节点**if-match**子句的路由在本节点允许通过Route-Policy，匹配结束。不匹配**if-match**子句的路由进行Route-Policy下一个节点的匹配。 |
|            | **deny**   | 匹配该节点**if-match**子句的路由在本节点不允许通过Route-Policy，匹配结束。不匹配**if-match**子句的路由进行Route-Policy下一个节点的匹配。 |
| **deny**   | **permit** | 匹配该节点**if-match**子句的路由在本节点不允许通过Route-Policy，继续进行Route-Policy下一个节点的匹配。不匹配**if-match**子句的路由进行Route-Policy下一个节点的匹配。 |
|            | **deny**   | 匹配该节点**if-match**子句的路由在本节点不允许通过Route-Policy，继续进行Route-Policy下一个节点的匹配。不匹配**if-match**子句的路由进行Route-Policy下一个节点的匹配。 |

默认所有未匹配的路由将被拒绝通过Route-Policy。如果Route-Policy中定义了一个以上的节点，应保证各节点中至少有一个节点的匹配模式是**permit**。因为Route-Policy用于路由信息过滤时：

- 如果某路由信息没有通过任一节点，则认为该路由信息没有通过该Route-Policy。
- 如果Route-Policy的所有节点都是**deny**模式，则没有路由信息能通过该Route-Policy。



四种组合情况中，前两种比较好理解，也比较常用。后两种相对难理解一点，这里以第三种情况为例进行说明：

假设if-match子句中包含的匹配条件是deny，node节点对应的匹配条件permit，配置如下：

```
#
acl number 2001
 rule 5 deny source 172.16.16.0 0    //拒绝172.16.16.0
#
acl number 2002
 rule 5 permit source 172.16.16.0 0  //允许172.16.16.0
#
route-policy RP permit node 10       //在这个节点，172.16.16.0这条路由被拒绝，继续往下
 if-match acl 2001
#
route-policy RP permit node 20       //在这个节点，172.16.16.0这条路由被允许
 if-match acl 2002
#
```

这种情况下，有一个关键点就是在node 10，172.16.16.0这条路由被拒绝，同时会继续往下匹配，到node 20这个节点的时候172.16.16.0又被允许了，所以Route-Policy的最终匹配结果是允许172.16.16.0这条路由。



### if-match

**if-match** 支持以下过滤器：

- **ip-prefix** 地址前缀列表
- **as-path-filter** AS 属性
- **community-filter** 团体属性
- **extcommunity-filter** 扩展团体属性
- **rd-filter** RD 属性

- **interface** 接口
- **route-type** 路由类型



**if-match as-path-filter**、**if-match community-filter**、**if-match extcommunity-filter**、**if-match interface**和**if-match route-type** 五个命令的**各自if-match**子句间是“或”的关系。

**这五个命令**与**其它命令的if-match**子句间仍是**“与”的关系**。

**其他类型的过滤器是“与”的关系**（即路由信息必须同时满足所有**if-match**子句）



> **if-match**子句匹配未配置的过滤器时，默认该**if-match**子句匹配成功。
>
> 对于同一个路由策略节点，命令**if-match acl**和命令**if-match ip-prefix**不能同时配置，后配置的命令会覆盖先配置的命令。



1. **route-policy** *route-policy-name* { **permit** | **deny** } **node** *node*，进入Route-Policy视图
2. 根据实际情况配置路由策略中的**if-match**子句。



匹配基本ACL：**if-match acl** { *acl-number* | *acl-name* }



匹配路由信息的as-path属性过滤器：**if-match as-path-filter** { *as-path-filter-number* &<1-16> | *as-path-filter-name* }



匹配路由信息的团体属性过滤器：

- **if-match community-filter** { *basic-comm-filter-num* [ **whole-match** ] | *adv-comm-filter-num* } &<1-16>
- **if-match community-filter** *comm-filter-name* [ **whole-match** ]



匹配BGP路由信息的扩展团体属性：**if-match extcommunity-filter** { { *basic-extcomm-filter-num* | *adv-extcomm-filter-num* } &<1-16> | *extcomm-filter-name* }



匹配路由信息的开销值：**if-match cost** { *cost* | **greater-equal** *greater-equal-value* [ **less-equal** *less-equal-value* ] | **less-equal** *less-equal-value* }



匹配路由信息的出接口：**if-match interface** { *interface-type* *interface-number* } &<1-16>



匹配IPv4的路由信息（下一跳或源地址）：**if-match ip** { **next-hop** | **route-source** } { **acl** { *acl-number* | *acl-name* } | **ip-prefix** *ip-prefix-name* }



匹配IPv6的路由信息（目的地址、下一跳或路由源地址）：**if-match ipv6** { **address** | **next-hop** | **route-source** } **prefix-list** *ipv6-prefix-name*



匹配地址前缀列表：**if-match ip-prefix** *ip-prefix-name*



匹配rd属性过滤器：**if-match rd-filter** *rd-filter-number*



匹配路由信息的类型

- 匹配OSPF各类型路由信息：**if-match route-type** { **external-type1** | **external-type1or2** | **external-type2** | **internal** | **nssa-external-type1** | **nssa-external-type1or2** | **nssa-external-type2** }
- 匹配IS-IS各level路由信息：**if-match route-type** { **is-is-level-1** | **is-is-level-2** }



匹配路由信息的标记域：**if-match tag** *tag*



### Apply

**Apply**子句用来为路由策略指定动作，用来设置匹配成功的路由的属性。在一个节点中，如果没有配置**apply**子句，则该节点仅起过滤路由的作用。如果配置一个或多个**apply**子句，则通过节点匹配的路由将执行所有**apply**子句。



1. 执行命令**route-policy** *route-policy-name* { **permit** | **deny** } **node** *node*，进入Route-Policy视图。
2. 根据实际情况配置路由策略中的**apply**子句。



设置BGP路由的AS_Path属性：**apply as-path** { { *as-number-plain* | *as-number-dot* } &<1-10> { **additive** | **overwrite** } | **none** **overwrite** }



设置备份出接口：**apply backup-interface** *interface-type* *interface-number*



设置备份下一跳：**apply backup-nexthop** { *ip-address* | **auto** }



删除指定的BGP路由的团体属性：**apply comm-filter** { *basic-comm-filter-number* | *adv-comm-filter-number* | *comm-filter-name* } **delete**

> 当需要删除几个团体属性时，可通过一条**ip community-filter**命令仅配置一个团体属性的方法，将需要删除的团体属性都分条配置到一个团体属性过滤器，最后应用包含**apply comm-filter delete**命令的路由策略删除该团体属性过滤器中的所有团体属性。



删除全部BGP路由的团体属性：**apply community** **none**



设置BGP路由的团体属性：**apply community** { *community-number* | *aa:nn* | **internet** | **no-advertise** | **no-export** | **no-export-subconfed** } &<1-32> [ **additive** ]



设置路由的开销值：**apply cost** [ **+** | **-** ] *cost*

设置路由的开销类型

- 设置IS-IS的开销类型：**apply cost-type** { **external** | **internal** }
- 设置OSPF的开销类型：**apply cost-type** { **type-1** | **type-2** }



设置EBGP路由的衰减参数：**apply dampening** *half-life-reach* *reuse* *suppress* *ceiling*



设置BGP路由的扩展团体属性（Route-Target）：**apply extcommunity** { **rt** { *as-number:nn* | *4as-number:nn* | *ipv4-address:nn* } } &<1-16> [ **additive** ]



设置IPv4路由的下一跳地址：**apply ip-address next-hop** { *ipv4-address* | **peer-address** }

设置IPv6路由的下一跳地址：**apply ipv6 next-hop** { **peer-address** | *ipv6-address* }



设置IS-IS的路由级别：**apply isis** { **level-1** | **level-1-2** | **level-2** }

设置BGP路由的本地优先级：**apply local-preference** *preference*

设置BGP路由的Origin属性：**apply origin** { **egp** { *as-number-plain* | *as-number-dot* } | **igp** | **incomplete** }

设置路由引入到OSPF的特定区域：**apply ospf** { **backbone** | **stub-area** }

设置路由协议的优先级：**apply preference** *preference*

设置BGP路由的首选值：**apply preferred-value** *preferred-value*

设置路由的标记域：**apply tag** *tag*



### 示例

```
#
ip ip-prefix ip-group index 10 permit 192.168.100.0 24
#

#
route-policy route-group permit node 10
 if-match ip-prefix ip-group
 apply ip-address next-hop 172.16.20.2
#
route-policy direct permit node 20
#

#
ospf 1
 filter-policy route-policy route-group import
 area 0.0.0.0
  network 172.16.20.0 0.0.0.255
 area 0.0.0.1
  network 172.16.30.0 0.0.0.255
  stub
#
```

注：不知道为什么 apply ip-address next-hop 172.16.20.2 没有生效。



## 配置路由策略生效时间

**操作步骤**

1. 执行命令**system-view**，进入系统视图。

2. 执行命令**route-policy-change notify-delay** *delay-time*，设置路由策略应用延迟时间。

    延迟时间的取值范围是1秒～180秒。

    缺省情况下，路由策略变化后，RM将立即通知协议应用新策略。

3. 执行命令**quit**，退回用户视图。

4. （可选）执行命令**refresh bgp** **all** { **export** | **import** }，配置BGP协议立即应用新策略。

    如果配置策略命令后，需要立即看到策略过滤的效果。可以通过执行这个命令，配置BGP协议立即应用新策略。

    受该定时器影响的相关的策略有访问控制列表、地址前缀列表、AS路径过滤器、团体属性过滤器、扩展团体属性过滤器、RD属性过滤器和Route-Policy。

    

**检查配置结果**

完成配置后，可以按以下指导来检查配置结果。

- 使用**display current-configuration** **|** **include** **notify-delay**命令查看路由策略应用延迟时间。



## 维护路由策略

路由策略的维护包括清除地址前缀列表统计数据。

**操作步骤**

- 在确认需要清除IPv4地址前缀列表统计数据，请在用户视图下执行**reset ip ip-prefix** [ *ip-prefix-name* ]命令。
- 在确认需要清除IPv6地址前缀列表统计数据，请在用户视图下执行**reset ip ipv6-prefix** [ *ipv6-prefix-name* ]命令。



# 策略路由

策略路由是一种基于数据包的某些特征（如源地址、目的地址、协议类型、端口号等）来决定其转发路径的方法，而不依赖于标准的最长匹配路由查找。

PBR直接作用于数据包，根据预设的条件判断并决定每个数据包的转发行为。



