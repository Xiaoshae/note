# Kubernetes 对象



## Node

一个 Pod 总是运行在某个 **Node（节点）** 上。节点是 Kubernetes 中工作机器， 可以是虚拟机或物理计算机，具体取决于集群。每个 Node 都由控制面管理。 节点可以有多个 Pod，Kubernetes 控制面会自动处理在集群中的节点上调度 Pod。 控制面的自动调度考量了每个节点上的可用资源。

每个 Kubernetes 节点至少运行：

- kubelet，负责 Kubernetes 控制面和节点之间通信的进程；它管理机器上运行的 Pod 和容器。
- 容器运行时（如 Docker）负责从镜像仓库中拉取容器镜像、解压缩容器以及运行应用。



![img](./images/%E5%AF%B9%E8%B1%A1.assets/module_03_nodes.svg)



## Pod

Pod 是 Kubernetes 抽象出来的，**它是一组一个或多个应用容器（如 Docker）的组合**， 以及这些容器的一些共享资源。这些资源包括：

- 卷形式的共享存储
- 集群内唯一的 IP 地址，用于联网（**共享 IP 地址**）



**卷（Volumes）** 是 Kubernetes 提供的一种机制，用于在 Pod 中创建共享存储空间。它允许 Pod 中的一个或多个容器访问和共享数据，比如文件、配置或数据库。

在 Kubernetes 中，**Volumes 不是容器内部的临时存储（容器内部的存储通常会随着容器删除而消失，容器内部的存储不会共享）**，而是一个更持久或共享的存储方式。

**Pod 中的容器可以共同访问同一个 Volume（这是可选的，不必共享给这个 Pod 内的所有容器）**，这意味着多个容器可以读取、写入和共享同一份数据，而不需要通过网络或其他复杂方式传输。

Volumes 可以是多种类型，例如：

- **临时卷**：如 EmptyDir，只在 Pod 运行期间存在，用于容器之间临时共享数据。Pod 被删除（例如，因为 Pod 被重新调度、崩溃或手动删除），EmptyDir 卷及其中的数据就会立即消失
- **持久卷**：如 PersistentVolume (PV)，连接到外部存储系统（如云盘、NFS 网络文件系统），即使 Pod 被删除，数据也可以保留。



一个 Pod 可以包含多个容器，这些容器是“相对紧耦合”的，意思是它们**功能上紧密相关，但不是完全相同的（例如，一个容器处理主逻辑，另一个提供辅助服务）**。文本举例说，Pod 可能包含：

- 一个容器运行 Node.js 应用（例如，一个 web 服务器）。
- 另一个容器提供数据或服务给这个 Node.js 应用（例如，存储或处理数据的容器）。
- 这样，两个容器可以协同工作，而不需要通过网络通信来连接它们。



Pod 是 Kubernetes 平台上的原子单元。当我们在 Kubernetes 上创建 Deployment 时， 该 Deployment 会创建其中包含容器的 Pod（而不是直接创建容器）。

每个 Pod 都与被调度所在的节点绑定，并保持在那里直到（根据重启策略）终止或删除。 **如果节点发生故障，则相同的 Pod 会被调度到集群中的其他可用节点上。**

![img](./images/%E5%AF%B9%E8%B1%A1.assets/module_03_pods.svg)

### 在容器上执行命令

一旦 Pod 启动并运行，我们就可以直接在容器上执行命令。 为此，我们使用 `exec` 子命令，并将 Pod 的名称作为参数。 让我们列出环境变量：

```bash
kubectl exec "$POD_NAME" -- env
```



另外值得一提的是，由于 Pod 中只有一个容器，所以容器本身的名称可以被省略。

接下来，让我们在 Pod 的容器中启动一个 bash 会话：

```shell
kubectl exec -ti $POD_NAME -- bash
```



现在我们有了一个在运行 Node.js 应用的容器上打开的控制台。 该应用的源代码位于 `server.js` 文件中：

```shell
cat server.js
```



你可以通过运行 `curl` 命令查看应用是否启动：

```shell
curl http://localhost:8080
```



## Deployment

**Kubernetes Deployment** 指挥 Kubernetes 如何创建和更新应用的实例。创建 Deployment 后，Kubernetes 控制平面将 Deployment 中包含的应用实例调度到集群中的各个节点上。

创建应用实例后，Kubernetes Deployment 控制器会持续监视这些实例。 如果托管实例的节点关闭或被删除，则 Deployment 控制器会将该实例替换为集群中另一个节点上的实例。 **这提供了一种自我修复机制来解决机器故障维护问题。**



### 命令行

可以使用 Kubernetes 命令行界面 **kubectl** 创建和管理 Deployment。 kubectl 使用 Kubernetes API 与集群进行交互。

创建 Deployment 时，你需要**指定应用的容器镜像以及要运行的副本数**。如果后续需求发生变化，可以通过更新 Deployment 来调整相关配置。



使用 `kubectl create deployment` 命令在 Kubernetes 部署一个应用。需要提供 Deployment 命令以及应用镜像位置（包括托管在 Docker hub 之外的镜像的完整仓库地址）

```
kubectl create deployment hello-nginx --image=docker.io/library/nginx:latest
```

- 在 Kubernetes 集群中创建一个 Deployment。
- 该 Deployment 会自动启动一个或多个 Pod，每个 Pod 运行一个基于 Nginx 镜像的容器。
- 默认情况下，如果不指定副本数，Kubernetes 会创建一个副本（即 1 个 Pod）。



通过创建 Deployment 部署应用。这个过程中执行了以下一些操作：

- 搜索应用实例可以运行的合适节点（我们只有一个可用的节点）
- 调度应用在此节点上运行
- 配置集群在需要时将实例重新调度到新的节点上



要列出你的 Deployment，使用 `kubectl get deployments` 命令：

```bash
root@k8s-master:~# kubectl get deployments
NAME          READY   UP-TO-DATE   AVAILABLE   AGE
hello-nginx   1/1     1            1           10s
```

- 有 1 个 Deployment 运行应用的单个实例。这个实例运行在节点上的一个容器内。



在 Kubernetes 内运行的 Pod 运行在一个私有的、隔离的网络上。 默认这些 Pod 可以从同一 Kubernetes 集群内的其他 Pod 和服务看到，但超出这个网络后则看不到。

kubectl proxy 命令可以创建一个代理，将通信转发到集群范围的私有网络。 **你需要打开第二个终端窗口来运行此代理**，按下 Ctrl-C 此代理可以被终止，且在此代理运行期间不会显示任何输出。

```bash
root@k8s-master:~# kubectl proxy
Starting to serve on 127.0.0.1:8001
```



> kubectl proxy 是 Kubernetes 提供的命令行工具，用于在本地启动一个 HTTP 代理服务器（默认监听 8001 端口）。它的核心功能是允许通过本地 8001 端口访问 Kubernetes API——当请求发送到该端口时，代理会自动完成认证，并将请求安全地转发到 API 服务器的默认端口（如 6443）。用户可以通过该代理执行资源查询、对象创建、Pod 管理等操作，其功能与直接访问 API 服务器相同，特别适合在本地开发或调试时使用。



通过 kubectl proxy 命令启动的代理服务器，你可以访问 Kubernetes API 服务器上托管的所有 API 端点。 例如，我们可以使用以下 `curl` 命令直接通过 API 查询版本：

```
curl http://localhost:8001/version
```



Kubernetes 设计了代理功能（proxy endpoint），允许 API 服务器充当反向代理，将外部请求路由到 Pod 的特定端口。

```
curl http://localhost:8001/api/v1/namespaces/default/pods/hello-nginx-5b954f8776-x42c6/proxy/
```

```html
<!DOCTYPE html>
<html>
<head>
<title>Welcome to nginx!</title>
<style>
html { color-scheme: light dark; }
body { width: 35em; margin: 0 auto;
font-family: Tahoma, Verdana, Arial, sans-serif; }
</style>
</head>
<body>
<h1>Welcome to nginx!</h1>
<p>If you see this page, the nginx web server is successfully installed and
working. Further configuration is required.</p>

<p>For online documentation and support please refer to
<a href="http://nginx.org/">nginx.org</a>.<br/>
Commercial support is available at
<a href="http://nginx.com/">nginx.com</a>.</p>

<p><em>Thank you for using nginx.</em></p>
</body>
</html>
```



当然，用户也可以**直接访问 Kubernetes API 服务器的默认端口 6443**，但这种方式**需要手动配置认证信息**（认证**证书文件存放在 /etc/kubernetes/pki/ 目录**下）。

```bash
curl https://10.40.1.240:6443/api/v1/namespaces/default/pods/hello-nginx-5b954f8776-x42c6/proxy/ --cert apiserver-kubelet-client.crt --key apiserver-kubelet-client.key --cacert ca.crt
```

```html
<!DOCTYPE html>
<html>
<head>
<title>Welcome to nginx!</title>
<style>
html { color-scheme: light dark; }
body { width: 35em; margin: 0 auto;
font-family: Tahoma, Verdana, Arial, sans-serif; }
</style>
</head>
<body>
<h1>Welcome to nginx!</h1>
<p>If you see this page, the nginx web server is successfully installed and
working. Further configuration is required.</p>

<p>For online documentation and support please refer to
<a href="http://nginx.org/">nginx.org</a>.<br/>
Commercial support is available at
<a href="http://nginx.com/">nginx.com</a>.</p>

<p><em>Thank you for using nginx.</em></p>
</body>
</html>
```

