# 权限管理

## 文件权限

```
drwxr-xr-x 2 pete penguins 4096 Dec 1 11:45 .
```

文件权限由四个部分组成，每个部分都有特定的含义。

**第一部分是文件类型**，由权限字符串的第一个字符表示。例如：

- **d** 表示这是一个目录
- **-** 表示这是一个普通文件

**接下来的三个部分分别代表不同用户的权限**，每组包含 3 个字符：

1. **前 3 位** 表示**文件所有者**的权限
2. **中间 3 位** 表示**同组用户**的权限
3. **最后 3 位** 表示**其他用户**的权限



```
d | rwx | r-x | r-x 
```

- r：可读
- w：可写
- x：可执行（基本上是一个可执行程序）
- -：无权限



在上面的例子中，我们可以看到用户 pete 对文件拥有读、写和执行权限。组 penguins 拥有读和执行权限。最后，其他用户（其他人）也拥有读和执行权限。 



### chmod

`chmod` 的**符号模式**允许灵活组合，包括使用不同的操作符（如 +、-、=）和权限对象（如 u、g、o、a）它的一般语法为：

```
chmod [who][operator][permissions] file...
```

**who (权限对象)**：指定权限应用于谁。选项包括：

- `u`：用户/所有者 (user/owner)。
- `g`：组 (group)。
- `o`：其他人 (others)。
- `a`：所有人 (all)，这是默认值，如果不指定 `who`，会自动使用 `a`。
- 可以组合多个，例如 `ug` 表示用户和组，`ugo` 表示所有人（等同于 `a`）。

**operator (操作符)**：指定如何修改权限。选项包括：

- `+`：添加权限（如果权限不存在，则添加；如果存在，则保持）。
- `-`：移除权限（如果权限存在，则移除；如果不存在，则保持）。
- `=`：设置权限（完全覆盖原有权限，只保留指定的权限，其他权限会被移除）。

**permissions (权限)**：指定要操作的具体权限。常见选项包括：

- `r`：读权限。
- `w`：写权限。
- `x`：执行权限。
- 其他特殊权限如 **setuid (u+s)、setgid (g+s)、sticky bit (+t / o+t)** 但我们重点讨论基本权限。
- 可以组合多个权限，例如 `rwx` 表示读、写和执行权限。
- 还有一些特殊形式，如 `X`：如果对象是目录，则始终添加执行权限；如果对象是文件，则不进行更改。



**组合规则**：

- **多个权限对象**：您可以在一个命令中指定多个 `who`，如 `ug`，表示同时操作用户和组。
- **多个操作**：一个 `chmod` 命令可以包含多个 `[who][operator][permissions]` 组合，用逗号分隔，例如 `u+rwx,g+rx,o-r`。每个组合是独立的，但会顺序应用到同一个文件。
- **顺序和覆盖**：操作符的顺序很重要。如果您使用 `=`，它会覆盖原有权限；如果使用 `+` 或 `-`，它会基于当前权限进行修改。



**示例 1：简单组合**

```
chmod u+x,g+w example.txt
```

- `u+x`：为用户 (owner) 添加执行权限。
- `g+w`：为组 (group) 添加写权限。



**示例 2：使用多个权限对象和混合操作符**

```
chmod ug=rwX,o-wx example.txt
```

- `ug=rwX`：为用户和组设置权限为读、写和执行。
- `o-wx`：为其他人移除写和执行权限。



**示例 3：默认对象和全面添加/移除**

```
chmod +rwx,a-w example.txt
```

- `+rwx`：默认对象是 `a` (所有人)，所以为所有人添加读、写和执行权限。
- `a-w`：为所有人移除写权限。
- 最终权限：`r-x r-x r-x`



`chmod` 数字模式使用 3 位或 4 位八进制数字来表示文件权限。每位数字对应一组权限（所有者、组、其他人），数字是通过权限值的和计算得出的，它的一般语法为：

```
chmod [octal-mode] file...
```

- `[octal-mode]`：一个 3 位或 4 位的八进制数字（例如 755 或 4755）。
- `file...`：一个或多个文件或目录的名称。



3 位数字：表示标准权限，顺序为：

- 第一位：所有者 (user/owner) 的权限。
- 第二位：组 (group) 的权限。
- 第三位：其他人 (others) 的权限。
- 例如，755 表示：所有者有 rwx（7），组有 r-x（5），其他人有 r-x（5）。

4 位数字（可选）：添加特殊权限，顺序为：

- 第一位：特殊权限，包括（**可同时设置**）：
  - 4：setuid (设置用户 ID)
  - 2：setgid (设置组 ID)
  - 1：sticky bit (粘滞位，通常用于目录)
  - 0：无权限
- 后三位：与 3 位数字相同。



**权限值**

- 4：读权限 (r)
- 2：写权限 (w)
- 1：执行权限 (x)
- 0：无权限 (---)



对于每个权限组（所有者、组、其他人），您需要将对应的权限值相加来得到一个数字。

- `rwx = 4 (r) + 2 (w) + 1 (x) = 7`
- `rw- = 4 (r) + 2 (w)         = 6`
- `r-x = 4 (r)         + 1 (x) = 5`
- `r-- = 4 (r)                 = 4`
- `--x =                 1 (x) = 1`
- `--- = 0`



**示例 1：基本 3 位数字设置**

```
chmod 755 example.txt
```

- 第一位 7 rwx：所有者权限 
- 第二位 5 rx   ：组权限
- 第三位 5 rx   ：其他人权限



**示例 3: 使用 4 位数字添加特殊权限**

```
chmod 4755 example.txt
```

- 第一位 4 setuid：特殊权限
- 第二位 7 rwx：所有者权限
- 第三位 5 rx：组权限
- 第四位 5 rx：其他人权限



### chown

除了修改文件的权限，你还可以修改文件的组和用户所有权。



**修改用户所有权**

这条命令会将 myfile 的所有者设置为 patty。

```
chown patty myfile
```



**修改组所有权**

这条命令会将 myfile 的组设置为 whales。

```
chgrp whales myfile
```



**同时修改用户和组所有权**

如果在用户名后添加冒号和组名，可以同时设置用户和组。

```
chown patty:whales myfile
```



### umask

**umask** 是一个命令，用于设置新创建的文件或目录的默认权限。它不是直接添加权限，而是指定要从默认权限中**移除**某些权限。

在 Linux 系统中，新建文件默认权限是 666（rw-rw-rw-），而新建目录默认权限是777（即rwxrwxrwx）。

umask 命令接受一个3位八进制数字（例如022或021），这些数字表示要移除的权限位，大多数 Linux 发行版的默认 umask 是 022。



umask的值是通过位运算从默认权限中“减去”权限来计算新权限的。具体公式是：

- 新权限 = 默认权限 & (~umask)
- 其中，~表示“取反”（NOT运算），意思是 umask 指定的位会被移除。



1. 将默认权限转换为二进制

默认权限：666



转换为二进制：

```
110 | 110 | 110
```

- 解释：666 表示所有者、组和其他用户的权限均为 rw-，二进制为 110（6）每组。



2. 将 umask 转换为二进制

umask：022



转换为二进制：

```
000 | 010 | 010
```

- 解释：022 表示所有者不移除权限（000），组和其他人移除写权限（010）。





3. ~umask（按位取反）

取反结果：

```
111 | 101 | 101
```

- 解释：对 umask 的二进制位取反，000 变为 111，010 变为 101。



4. 默认权限 & ~umask（按位与操作）

使用您指定的格式，按行显示计算过程：

```
110 | 110 | 110   // 默认权限111 | 101 | 101   // ~umask110 | 100 | 100   // 结果（按位与后）
```

- 解释：
  - 第一组：110 & 111 = 110
  - 第二组：110 & 101 = 100
  - 第三组：110 & 101 = 100
    这表示新权限的二进制为 110 | 100 | 100。



5. 将结果转换为十进制（八进制权限）

- 二进制结果：110 | 100 | 100
- 转换为十进制：
  - 110 = 6
  - 100 = 4
  - 100 = 4
- 所以，新权限为：**644**



其实计算只需**默认权限 - umask** 即可：666 - 022 = 644



### setuid

Set User ID（SUID）允许用户以程序文件所有者的身份运行程序，而不是以他们自己的身份。

普通用户使用 passwd 来修改当前用户的密码。passwd 程序需要读写 **/etc/shadow** 文件，但该文件的权限为 **root:root ( rw- | --- | --- )**，因此以普通用户身份运行时无法访问 **/etc/shadow** 文件，从而无法修改密码。为此，passwd 程序被设置了 **setuid** 权限，使其在运行时以 root 身份执行，便可访问 **/etc/shadow** 文件进行修改。



**修改 SUID**

和普通权限一样，有两种方法可以修改 SUID 权限。

*符号方式：*

```
chmod u+s myfile
```



*数字方式：*

```
chmod 4755 myfile
```



在权限字符串中（如`ls -l`命令的输出），SUID 通常显示在用户权限组的执行位上：

- 如果文件**有用户执行**权限，SUID 会显示为小写 **s**（例如：`-rwsr-xr-x`）。
- 如果文件**没有用户执行**权限，SUID 位虽然设置了，但会显示为大写 **S**（例如：`-rwSr-xr-x`）。



### setgid

Set Group ID（SGID）权限位允许程序以该组成员的身份运行。

```
-rwxr-sr-x 1 root tty 19024 Dec 14 11:45 /usr/bin/wall
```



**修改 SGID**

```
chmod g+s myfile
chmod 2555 myfile
```

SGID 的数字表示是 2。



### Sticky Bit

最后一个特殊权限位是粘滞位（sticky bit），这个权限位“粘住”一个文件或目录，这意味着只有所有者或 root 用户可以删除或修改该文件。这对于共享目录非常有用。

```
drwxrwxrwxt 6 root root 4096 Dec 15 11:45 /tmp
```

你会在这里看到一个特殊的权限位 **t**，这意味着每个人都可以在 /tmp 目录中添加、写入和修改文件，但只有 root 可以删除 /tmp 目录。



**修改粘滞位**

```
chmod +t mydir
chmod 1755 mydir
```





### 进程权限

在类 Unix 操作系统中，每个用户都由一个唯一的整数编号来标识，这个编号称为用户ID（UserID）。

对于一个进程，有三种类型的 UID 可以根据任务权限动态更改，这三种不同的 UID 分别是：

1. 真实用户 ID（Real UserID）
2. 有效用户 ID（Effective UserID）
3. 保存用户 ID（Saved UserID）



**真实用户ID：** RUID 标识了进程的原始所有者，即启动该进程的用户的ID，且**不会直接影响**进程的运行时权限。

**有效用户ID：** EUID 是进程权限的核心，它决定了进程在运行时实际拥有的权限，系统在检查文件访问、系统调用等操作时，会**优先参考 EUID**。

**保存用户ID：** SUID 用于保存进程的原始 EUID，当进程的特权被提升时，它会存储原来的 EUID 值，从而允许进程在需要时**安全地切换回非特权状态**。



如果一个非 root 用户运行该进程，则该进程的**有效用户 ID（EUID）**将变为**0**（即 root），而**真实用户 ID（RUID）**保持与原用户相同。

在执行非特权任务时，**有效用户 ID（EUID）**会更改为较低的特权值，并将原来的 EUID 保存到**保存用户 ID（SUID）**中，以便任务完成后**切换回特权状态**。



### 选项参考

#### chmod

**-v, --verbose**

这个选项为每个处理的文件或目录输出详细的诊断信息，包括权限更改前后的状态。这有助于用户确认命令是否按预期执行。



**-c, --changes**

 如果您要批量更改多个文件的权限，但只关心哪些文件真正被修改了，可以使用这个选项来查看更改详情，而不被无关信息干扰。



**-f, --silent, --quiet**

这个选项抑制（不显示）大多数错误消息，例如当命令无法更改文件权限时（如权限不足），它不会输出警告或错误信息。这可以使输出更简洁，尤其在自动化脚本中。



**--preserve-root**

这个选项在命令尝试递归操作（使用 `-R`）时，如果目标是根目录（'/'），则会使命令失败，从而保护系统核心文件不被意外修改。



**--no-preserve-root**

这个选项指示命令**不要特别对待根目录（'/'）**，即**允许在根目录上进行递归操作**（如果结合 `-R` 使用）。

**这是一个默认行为，因此如果不指定其他选项，它会自动生效。**



**--reference=RFILE**

这个选项使用指定文件 **RFILE** 的权限模式作为参考，直接将目标文件的权限设置为与 **RFILE** 相同。如果 **RFILE** 是一个符号链接，则会自动解析到实际文件。

如果您有一个模板文件（如 `template.txt`），想让其他文件继承它的权限，可以使用 `--reference=template.txt file1 file2`。



**-R, --recursive**

这个选项使命令递归地处理文件和目录，即不仅更改指定文件，还会遍历目录下的所有子目录和文件。



#### chown

**--dereference**

默认选项，命令会影响符号链接的引用目标（即符号链接指向的实际文件或目录），而不是符号链接本身。

例如，如果一个符号链接指向文件 A，命令会更改 A 的所有者，而不是链接本身。这通常**是预设行为**，因为大多数情况下，用户希望影响真实文件。



**-h, --no-dereference**

直接影响符号链接本身，而不是它指向的文件。这只在支持更改符号链接所有者的系统上有效（如某些 Linux 版本）。

例如，如果您有一个符号链接 B 指向文件 A，使用此选项会更改 B 的所有者，而不影响 A。这在需要精确控制符号链接属性的场景中有用。



**--from=CURRENT_OWNER:CURRENT_GROUP**

仅在文件当前的所有者和/或组与指定的 CURRENT_OWNER 和 CURRENT_GROUP 匹配时，才更改所有者和/或组。

您可以省略部分参数，例如只指定 CURRENT_OWNER，而忽略 CURRENT_GROUP（在这种情况下，只检查所有者是否匹配）。

这用于条件性更改，例如确保只修改特定用户拥有的文件，避免意外操作。



**-H** (仅在与 -R 结合使用时生效)

如果命令行参数中有一个符号链接指向目录，则遍历该目录，但不会自动遍历其他遇到的符号链接。

这是一个部分递归选项，用于精确控制符号链接的处理行为。如果多个遍历选项同时指定，只以最后一个为准。



**-L** (仅在与 -R 结合使用时生效)

遍历所有遇到的符号链接指向的目录。这意味着命令会完全跟随符号链接，递归处理所有相关目录，非常彻底。但如果符号链接形成循环，可能导致无限递归或错误。



**-P** (仅在与 -R 结合使用时生效)

不遍历任何符号链接（默认行为）。命令只会处理命令行中直接指定的文件和目录，而忽略任何符号链接。这提供了一种安全的方式，避免意外影响符号链接指向的内容。



**其他选项和 chmod 基本一致**



## ACL（扩展权限）

访问控制列表（ACLs）是 Linux 中一种灵活的权限机制，允许您基于每个用户和每个组设置细粒度的权限。它是对标准 Unix 权限模型的扩展，尤其适用于**多个用户或组需要访问某一个文件或目录**的场景。



在 Linux 中，每个文件和目录都关联有一个 ACL。ACL 由多个条目组成，每条条目定义了特定用户或组的权限。ACL 条目共有三种类型：

- **用户条目**：定义特定用户的权限。
- **组条目**：定义特定组的权限。
- **其他条目**：定义未匹配用户和组条目的用户的权限。

每条条目都包含一组权限，与标准的读取（`r`）、写入（`w`）和执行（`x`）权限类似。



您可以使用 `getfacl` 命令查看文件或目录的 ACL。例如：

```
# file: test/
# owner: root
# group: root
user::rwx
group::r-x
other::r-x
```

ACLs 中的 **owner 和 group** 表示**标准文件权限**中文件**所属的用户和组**。`user::`、`group::` 和 `other::` 分别对应**标准文件权限**下的**用户、组和其他**。



### 修改 ACLs

您可以使用 `setfacl` 命令修改文件或目录的 ACL。例如，要为 `bob` 授予 `myfile.txt` 的读取和写入权限，可以使用以下命令：

```
setfacl -m u:bob:rw myfile.txt
```



使用 getfacl 查看文件修改后的 ACL

```
# file: myfile.txt
# owner: root
# group: root
user::rw-
user:bob:rw-
group::r--
mask::rw-
other::r--
```

`user::rw- `和 `group::r--` 等为标准文件权限，`user:xx:rw-` 等是为扩展文件权限，如 `user::bob:rw-` 为扩展文件权限，



您也可以使用 `-x` 选项删除某个 ACL 条目。例如，要删除 `bob` 的权限，可以使用：

```
setfacl -x u:bob myfile.txt
```



### mask

mask 是一个特殊的 ACL 条目，通常表示为 "mask::rwx"（例如 mask::r--）。它是一个权限掩码，用于限制 ACL 扩展文件权限中用户（如 "u:john"）和用户组（如 "g:developers"）的实际有效权限，它不影响标准权限条目。

当系统检查权限时，会将 ACL 条目中的权限（例如一个用户的 rwx）与 mask 进行逻辑与（AND）操作。只有与 mask 兼容的部分权限才会生效。



假设有一个文件名为 "example.txt"，其 ACL 设置如下（使用 `getfacl` 查看）：

```
# file: example.txt
# owner: root
# group: root
user::rw-          # 所有者权限
user:john:rwx      # 命名用户 john 的权限
group::r--         # 组权限
mask::r--          # mask 权限
other::r--         # others 权限
```

对于所有者（user::rw-），mask 不起作用，因为它是标准文件权限，所以实际权限是 rw-。

对于命名用户 "john"（user:john:rwx），系统会将 rwx 与 mask::r-- 进行逻辑与操作：

- rwx (读、写、执行) 与 r-- (只读) 的结果是 r-- (只读)。
- 因此，"john" 的实际有效权限是 r--，即使 ACL 中定义了 rwx。

对于组或其他条目，mask 同样会应用逻辑。



### 选项参考

#### getfacl

**-a, --access**

只显示文件的访问控制列表（ACL），而不显示默认ACL。

在文件系统上，ACL 包括访问ACL（定义当前文件的权限）和默认ACL（用于目录的继承）。使用此选项时，命令只会输出访问ACL 的条目，例如用户、组和权限掩码。忽略任何默认规则。



**-d, --default**

只显示默认访问控制列表（ACL），通常适用于目录。

默认ACL 定义了目录下新建文件或子目录的初始权限设置。它不会影响当前文件，但会自动应用于目录中的新对象。使用此选项时，命令只输出默认ACL 的条目，而忽略访问ACL。



**-c, --omit-header**

不显示输出中的注释头信息，只输出ACL 条目本身。



**-e, --all-effective**

打印所有有效的权限，包括计算后的实际可访问权限。

ACL 中的权限可能受到掩码（mask）或其他规则的影响，导致实际有效权限与定义权限不同。此选项会计算并显示这些有效权限，例如如果一个用户的权限被掩码限制，它会显示实际可用的权限。



**-E, --no-effective**

不打印有效的权限，只显示原始的ACL 条目。

与 `-e` 选项相反，此选项忽略权限计算，只输出ACL 中定义的原始权限（如直接设置的用户权限）。



**-s, --skip-base**

跳过那些只包含基本条目（即标准权限，没有扩展ACL）的文件。

基本条目指的是标准的 Unix 权限（如所有者、组和 others），而扩展ACL 是额外的权限设置。如果一个文件只包含基本条目，此选项会忽略它，只处理有扩展ACL 的文件。



**-R, --recursive**

递归处理子目录，遍历目录树中的所有文件和子目录。

默认情况下，`getfacl` 只处理指定的文件或目录。此选项会进入子目录并处理其中的所有内容，直到目录树结束。



**-L, --logical**

在递归处理时，遵循符号链接（symlinks）。



**-P, --physical**

在递归处理时，不遵循符号链接，只处理物理路径。

当使用 `-R` 选项时，如果遇到符号链接，此选项会跟随链接指向的实际路径继续处理。这意味着命令会处理链接的目标文件或目录。



**-t, --tabular**

使用表格格式输出，使输出更易读和结构化。

与 `-L` 相反，此选项会忽略符号链接，仅处理链接本身而不进入其目标。这避免了意外处理外部路径。



**-n, --numeric**

使用数字ID（如UID和GID）代替用户名和组名。



**--one-file-system**

在递归处理时，跳过不同文件系统的文件，只处理当前文件系统。



**-p, --absolute-names**

在输出路径时，不去除前导的 '/'，始终使用绝对路径。



#### setfacl

**-m, --modify=acl**

修改文件或目录的当前 ACL 条目。

此选项允许您添加或更新 ACL 条目，例如为特定用户或组设置权限。ACL 条目通常采用格式如 "u:username:rw-" 或 "g:groupname:r--"。它会合并到现有 ACL 中，而不会覆盖整个 ACL。如果指定多个条目，可以用逗号分隔。



**-M, --modify-file=file**

从指定文件中读取 ACL 条目，并用于修改文件或目录的当前 ACL。

该文件应包含 ACL 条目（例如，通过 `getfacl` 输出），`setfacl` 会读取这些条目并应用到目标文件。这类似于 `-m` 选项，但条目来自外部文件，方便批量操作。



**-x, --remove=acl**

从文件或目录的 ACL 中移除指定的条目。

 指定要移除的 ACL 条目，例如 "u:username"，会删除该用户相关的权限条目，但不会影响其他条目。如果指定多个条目，用逗号分隔。



**-X, --remove-file=file**

从指定文件中读取 ACL 条目，并从文件或目录的 ACL 中移除这些条目。

 与 `-x` 类似，但条目列表来自外部文件。该文件应包含要移除的 ACL 条目，`setfacl` 会逐一匹配并删除。



**-b, --remove-all**

移除文件或目录的所有扩展 ACL 条目，只保留标准权限。



**-k, --remove-default**

移除目录的默认 ACL 条目。

默认 ACL 只适用于目录，用于定义子目录或文件的继承权限。此选项会删除这些默认条目，但不会影响当前目录的访问 ACL。



**--set=acl**

完全替换文件或目录的当前 ACL，包括所有条目。

指定一个新的 ACL 条目列表，会覆盖现有 ACL。这不同于 `-m`（修改），它会彻底重写权限设置。



**--set-file=file**

从指定文件中读取 ACL 条目，并完全替换文件或目录的当前 ACL。

与 `--set` 类似，但条目来自外部文件。该文件应包含完整的 ACL 配置，`setfacl` 会用它覆盖目标文件的 ACL。



**--mask**

在设置或修改 ACL 时，重新计算有效权限掩码 (mask)。

ACL 中的掩码定义了最大有效权限；此选项确保在操作后，掩码被更新以反映新的权限设置，从而影响实际可访问权限。



**-n, --no-mask**

在设置或修改 ACL 时，不重新计算有效权限掩码。

与 `--mask` 相反，此选项保持现有掩码不变，即使 ACL 条目发生变化。这可能导致实际权限与预期不符。



**-d, --default**

使操作应用于目录的默认 ACL，而不是当前 ACL。

此选项将 `-m`, `-x`, `--set` 等操作定向到默认 ACL，用于设置子目录或文件的继承权限。



**-R, --recursive**

**-L, --logical**

**-P, --physical**



**--restore=file**

从指定文件中还原 ACL 设置（相当于 `getfacl -R` 的逆操作）。

该文件应是 `getfacl` 的输出，包含 ACL 条目；`setfacl` 会使用这些条目恢复目标文件的权限。



例如，假设您有一个文件夹 **/tmp/testdir**，首先运行 **getfacl -R /tmp/testdir > acl_backup.txt** 保存权限（这会保存 /tmp/testdir 及其子文件），然后修改权限后，使用 **setfacl --restore=acl_backup.txt** 即可还原所有文件和子目录的 ACL 设置。



**--test**

以测试模式运行，不实际修改 ACL，只显示预期的变化。

此选项模拟操作过程，输出将要应用的 ACL 修改，但不会保存任何变化。



## 文件系统属性

Linux 允许为文件设置额外的属性，这些属性可以影响权限行为，例如使文件不可删除或不可修改。

chattr 属性：使用 `chattr` 命令设置文件属性，例如：

- `i` 属性：使文件不可修改、删除或重命名（类似于不可变标志）。
- 示例：`chattr [ +i / -i ] example.txt`（文件变得只读/可写）。
- 查看：`lsattr example.txt`





## **Capabilities**



## MAC

安全模块和强制访问控制