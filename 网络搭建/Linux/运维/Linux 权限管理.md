# 权限管理

## 文件权限

```
drwxr-xr-x 2 pete penguins 4096 Dec 1 11:45 .
```

文件权限由四个部分组成，每个部分都有特定的含义。

**第一部分是文件类型**，由权限字符串的第一个字符表示。例如：

- **d** 表示这是一个目录
- **-** 表示这是一个普通文件

**接下来的三个部分分别代表不同用户的权限**，每组包含 3 个字符：

1. **前 3 位** 表示**文件所有者**的权限
2. **中间 3 位** 表示**同组用户**的权限
3. **最后 3 位** 表示**其他用户**的权限



```
d | rwx | r-x | r-x 
```

- r：可读
- w：可写
- x：可执行（基本上是一个可执行程序）
- -：无权限



在上面的例子中，我们可以看到用户 pete 对文件拥有读、写和执行权限。组 penguins 拥有读和执行权限。最后，其他用户（其他人）也拥有读和执行权限。 



### chmod

`chmod` 的**符号模式**允许灵活组合，包括使用不同的操作符（如 +、-、=）和权限对象（如 u、g、o、a）它的一般语法为：

```
chmod [who][operator][permissions] file...
```

**who (权限对象)**：指定权限应用于谁。选项包括：

- `u`：用户/所有者 (user/owner)。
- `g`：组 (group)。
- `o`：其他人 (others)。
- `a`：所有人 (all)，这是默认值，如果不指定 `who`，会自动使用 `a`。
- 可以组合多个，例如 `ug` 表示用户和组，`ugo` 表示所有人（等同于 `a`）。

**operator (操作符)**：指定如何修改权限。选项包括：

- `+`：添加权限（如果权限不存在，则添加；如果存在，则保持）。
- `-`：移除权限（如果权限存在，则移除；如果不存在，则保持）。
- `=`：设置权限（完全覆盖原有权限，只保留指定的权限，其他权限会被移除）。

**permissions (权限)**：指定要操作的具体权限。常见选项包括：

- `r`：读权限。
- `w`：写权限。
- `x`：执行权限。
- 其他特殊权限如 **setuid (u+s)、setgid (g+s)、sticky bit (+t / o+t)** 但我们重点讨论基本权限。
- 可以组合多个权限，例如 `rwx` 表示读、写和执行权限。
- 还有一些特殊形式，如 `X`：如果对象是目录，则始终添加执行权限；如果对象是文件，则不进行更改。



**组合规则**：

- **多个权限对象**：您可以在一个命令中指定多个 `who`，如 `ug`，表示同时操作用户和组。
- **多个操作**：一个 `chmod` 命令可以包含多个 `[who][operator][permissions]` 组合，用逗号分隔，例如 `u+rwx,g+rx,o-r`。每个组合是独立的，但会顺序应用到同一个文件。
- **顺序和覆盖**：操作符的顺序很重要。如果您使用 `=`，它会覆盖原有权限；如果使用 `+` 或 `-`，它会基于当前权限进行修改。



**示例 1：简单组合**

```
chmod u+x,g+w example.txt
```

- `u+x`：为用户 (owner) 添加执行权限。
- `g+w`：为组 (group) 添加写权限。



**示例 2：使用多个权限对象和混合操作符**

```
chmod ug=rwX,o-wx example.txt
```

- `ug=rwX`：为用户和组设置权限为读、写和执行。
- `o-wx`：为其他人移除写和执行权限。



**示例 3：默认对象和全面添加/移除**

```
chmod +rwx,a-w example.txt
```

- `+rwx`：默认对象是 `a` (所有人)，所以为所有人添加读、写和执行权限。
- `a-w`：为所有人移除写权限。
- 最终权限：`r-x r-x r-x`



`chmod` 数字模式使用 3 位或 4 位八进制数字来表示文件权限。每位数字对应一组权限（所有者、组、其他人），数字是通过权限值的和计算得出的，它的一般语法为：

```
chmod [octal-mode] file...
```

- `[octal-mode]`：一个 3 位或 4 位的八进制数字（例如 755 或 4755）。
- `file...`：一个或多个文件或目录的名称。



3 位数字：表示标准权限，顺序为：

- 第一位：所有者 (user/owner) 的权限。
- 第二位：组 (group) 的权限。
- 第三位：其他人 (others) 的权限。
- 例如，755 表示：所有者有 rwx（7），组有 r-x（5），其他人有 r-x（5）。

4 位数字（可选）：添加特殊权限，顺序为：

- 第一位：特殊权限，包括（**可同时设置**）：
  - 4：setuid (设置用户 ID)
  - 2：setgid (设置组 ID)
  - 1：sticky bit (粘滞位，通常用于目录)
  - 0：无权限
- 后三位：与 3 位数字相同。



**权限值**

- 4：读权限 (r)
- 2：写权限 (w)
- 1：执行权限 (x)
- 0：无权限 (---)



对于每个权限组（所有者、组、其他人），您需要将对应的权限值相加来得到一个数字。

- `rwx = 4 (r) + 2 (w) + 1 (x) = 7`
- `rw- = 4 (r) + 2 (w)         = 6`
- `r-x = 4 (r)         + 1 (x) = 5`
- `r-- = 4 (r)                 = 4`
- `--x =                 1 (x) = 1`
- `--- = 0`



**示例 1：基本 3 位数字设置**

```
chmod 755 example.txt
```

- 第一位 7 rwx：所有者权限 
- 第二位 5 rx   ：组权限
- 第三位 5 rx   ：其他人权限



**示例 3: 使用 4 位数字添加特殊权限**

```
chmod 4755 example.txt
```

- 第一位 4 setuid：特殊权限
- 第二位 7 rwx：所有者权限
- 第三位 5 rx：组权限
- 第四位 5 rx：其他人权限



### chown

除了修改文件的权限，你还可以修改文件的组和用户所有权。



**修改用户所有权**

这条命令会将 myfile 的所有者设置为 patty。

```
chown patty myfile
```



**修改组所有权**

这条命令会将 myfile 的组设置为 whales。

```
chgrp whales myfile
```



**同时修改用户和组所有权**

如果在用户名后添加冒号和组名，可以同时设置用户和组。

```
chown patty:whales myfile
```



### umask

**umask** 是一个命令，用于设置新创建的文件或目录的默认权限。它不是直接添加权限，而是指定要从默认权限中**移除**某些权限。

在 Linux 系统中，新建文件默认权限是 666（rw-rw-rw-），而新建目录默认权限是777（即rwxrwxrwx）。

umask 命令接受一个3位八进制数字（例如022或021），这些数字表示要移除的权限位，大多数 Linux 发行版的默认 umask 是 022。



umask的值是通过位运算从默认权限中“减去”权限来计算新权限的。具体公式是：

- 新权限 = 默认权限 & (~umask)
- 其中，~表示“取反”（NOT运算），意思是 umask 指定的位会被移除。



1. 将默认权限转换为二进制

默认权限：666



转换为二进制：

```
110 | 110 | 110
```

- 解释：666 表示所有者、组和其他用户的权限均为 rw-，二进制为 110（6）每组。



2. 将 umask 转换为二进制

umask：022



转换为二进制：

```
000 | 010 | 010
```

- 解释：022 表示所有者不移除权限（000），组和其他人移除写权限（010）。





3. ~umask（按位取反）

取反结果：

```
111 | 101 | 101
```

- 解释：对 umask 的二进制位取反，000 变为 111，010 变为 101。



4. 默认权限 & ~umask（按位与操作）

使用您指定的格式，按行显示计算过程：

```
110 | 110 | 110   // 默认权限111 | 101 | 101   // ~umask110 | 100 | 100   // 结果（按位与后）
```

- 解释：
  - 第一组：110 & 111 = 110
  - 第二组：110 & 101 = 100
  - 第三组：110 & 101 = 100
    这表示新权限的二进制为 110 | 100 | 100。



5. 将结果转换为十进制（八进制权限）

- 二进制结果：110 | 100 | 100
- 转换为十进制：
  - 110 = 6
  - 100 = 4
  - 100 = 4
- 所以，新权限为：**644**



其实计算只需**默认权限 - umask** 即可：666 - 022 = 644



### setuid

Set User ID（SUID）允许用户以程序文件所有者的身份运行程序，而不是以他们自己的身份。

普通用户使用 passwd 来修改当前用户的密码。passwd 程序需要读写 **/etc/shadow** 文件，但该文件的权限为 **root:root ( rw- | --- | --- )**，因此以普通用户身份运行时无法访问 **/etc/shadow** 文件，从而无法修改密码。为此，passwd 程序被设置了 **setuid** 权限，使其在运行时以 root 身份执行，便可访问 **/etc/shadow** 文件进行修改。



**修改 SUID**

和普通权限一样，有两种方法可以修改 SUID 权限。

*符号方式：*

```
chmod u+s myfile
```



*数字方式：*

```
chmod 4755 myfile
```



在权限字符串中（如`ls -l`命令的输出），SUID 通常显示在用户权限组的执行位上：

- 如果文件**有用户执行**权限，SUID 会显示为小写 **s**（例如：`-rwsr-xr-x`）。
- 如果文件**没有用户执行**权限，SUID 位虽然设置了，但会显示为大写 **S**（例如：`-rwSr-xr-x`）。



### setgid

Set Group ID（SGID）权限位允许程序以该组成员的身份运行。

```
-rwxr-sr-x 1 root tty 19024 Dec 14 11:45 /usr/bin/wall
```



**修改 SGID**

```
chmod g+s myfile
chmod 2555 myfile
```

SGID 的数字表示是 2。



### Sticky Bit

最后一个特殊权限位是粘滞位（sticky bit），这个权限位“粘住”一个文件或目录，这意味着只有所有者或 root 用户可以删除或修改该文件。这对于共享目录非常有用。

```
drwxrwxrwxt 6 root root 4096 Dec 15 11:45 /tmp
```

你会在这里看到一个特殊的权限位 **t**，这意味着每个人都可以在 /tmp 目录中添加、写入和修改文件，但只有 root 可以删除 /tmp 目录。



**修改粘滞位**

```
chmod +t mydir
chmod 1755 mydir
```





### 进程权限

在类 Unix 操作系统中，每个用户都由一个唯一的整数编号来标识，这个编号称为用户ID（UserID）。

对于一个进程，有三种类型的 UID 可以根据任务权限动态更改，这三种不同的 UID 分别是：

1. 真实用户 ID（Real UserID）
2. 有效用户 ID（Effective UserID）
3. 保存用户 ID（Saved UserID）



**真实用户ID：** RUID 标识了进程的原始所有者，即启动该进程的用户的ID，且**不会直接影响**进程的运行时权限。

**有效用户ID：** EUID 是进程权限的核心，它决定了进程在运行时实际拥有的权限，系统在检查文件访问、系统调用等操作时，会**优先参考 EUID**。

**保存用户ID：** SUID 用于保存进程的原始 EUID，当进程的特权被提升时，它会存储原来的 EUID 值，从而允许进程在需要时**安全地切换回非特权状态**。



如果一个非 root 用户运行该进程，则该进程的**有效用户 ID（EUID）**将变为**0**（即 root），而**真实用户 ID（RUID）**保持与原用户相同。

在执行非特权任务时，**有效用户 ID（EUID）**会更改为较低的特权值，并将原来的 EUID 保存到**保存用户 ID（SUID）**中，以便任务完成后**切换回特权状态**。



### 选项参考

#### chmod

**-v, --verbose**

这个选项为每个处理的文件或目录输出详细的诊断信息，包括权限更改前后的状态。这有助于用户确认命令是否按预期执行。



**-c, --changes**

 如果您要批量更改多个文件的权限，但只关心哪些文件真正被修改了，可以使用这个选项来查看更改详情，而不被无关信息干扰。



**-f, --silent, --quiet**

这个选项抑制（不显示）大多数错误消息，例如当命令无法更改文件权限时（如权限不足），它不会输出警告或错误信息。这可以使输出更简洁，尤其在自动化脚本中。



**--preserve-root**

这个选项在命令尝试递归操作（使用 `-R`）时，如果目标是根目录（'/'），则会使命令失败，从而保护系统核心文件不被意外修改。



**--no-preserve-root**

这个选项指示命令**不要特别对待根目录（'/'）**，即**允许在根目录上进行递归操作**（如果结合 `-R` 使用）。

**这是一个默认行为，因此如果不指定其他选项，它会自动生效。**



**--reference=RFILE**

这个选项使用指定文件 **RFILE** 的权限模式作为参考，直接将目标文件的权限设置为与 **RFILE** 相同。如果 **RFILE** 是一个符号链接，则会自动解析到实际文件。

如果您有一个模板文件（如 `template.txt`），想让其他文件继承它的权限，可以使用 `--reference=template.txt file1 file2`。



**-R, --recursive**

这个选项使命令递归地处理文件和目录，即不仅更改指定文件，还会遍历目录下的所有子目录和文件。



#### chown

**--dereference**

默认选项，命令会影响符号链接的引用目标（即符号链接指向的实际文件或目录），而不是符号链接本身。

例如，如果一个符号链接指向文件 A，命令会更改 A 的所有者，而不是链接本身。这通常**是预设行为**，因为大多数情况下，用户希望影响真实文件。



**-h, --no-dereference**

直接影响符号链接本身，而不是它指向的文件。这只在支持更改符号链接所有者的系统上有效（如某些 Linux 版本）。

例如，如果您有一个符号链接 B 指向文件 A，使用此选项会更改 B 的所有者，而不影响 A。这在需要精确控制符号链接属性的场景中有用。



**--from=CURRENT_OWNER:CURRENT_GROUP**

仅在文件当前的所有者和/或组与指定的 CURRENT_OWNER 和 CURRENT_GROUP 匹配时，才更改所有者和/或组。

您可以省略部分参数，例如只指定 CURRENT_OWNER，而忽略 CURRENT_GROUP（在这种情况下，只检查所有者是否匹配）。

这用于条件性更改，例如确保只修改特定用户拥有的文件，避免意外操作。



**-H** (仅在与 -R 结合使用时生效)

如果命令行参数中有一个符号链接指向目录，则遍历该目录，但不会自动遍历其他遇到的符号链接。

这是一个部分递归选项，用于精确控制符号链接的处理行为。如果多个遍历选项同时指定，只以最后一个为准。



**-L** (仅在与 -R 结合使用时生效)

遍历所有遇到的符号链接指向的目录。这意味着命令会完全跟随符号链接，递归处理所有相关目录，非常彻底。但如果符号链接形成循环，可能导致无限递归或错误。



**-P** (仅在与 -R 结合使用时生效)

不遍历任何符号链接（默认行为）。命令只会处理命令行中直接指定的文件和目录，而忽略任何符号链接。这提供了一种安全的方式，避免意外影响符号链接指向的内容。



**其他选项和 chmod 基本一致**